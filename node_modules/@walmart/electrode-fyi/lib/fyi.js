"use strict";

const Levels = require("./levels");
const ColorPrefix = require("./color-prefix");
const checkColor = require("./check-color");

/* eslint-disable no-invalid-this,prefer-const,prefer-spread */

const fyi = {};

const logFyi2 = (level, args) => {
  args = Array.prototype.slice.call(args, 0);
  args.unshift(global.ElectrodeFyiColor ? ColorPrefix[level] : `FYI ${level}:`);
  fyi._logger[level].apply(fyi._logger, args);
};

const setLevel = level => {
  if (level) {
    const x = Levels[level.toLowerCase()];
    if (x) {
      fyi._level = x;
    }
  }
};

const updateLevel = () => {
  if (global.ElectrodeFyiLevel !== undefined && fyi._levelStr !== global.ElectrodeFyiLevel) {
    const x = global.ElectrodeFyiLevel;
    fyi._levelStr = x;
    if (Levels[x] === undefined) {
      logFyi2("error", [`global.ElectrodeFyiLevel ${x} is invalid`]);
    } else {
      logFyi2("warn", [`fyi level has been changed by global.ElectrodeFyiLevel to ${x}`]);
      setLevel(x);
    }
  }
};

const checkEnv = () => {
  global.ElectrodeFyiColor = checkColor(global.ElectrodeFyiColor);
  if (process.env.ELECTRODE_FYI_LEVEL !== undefined) {
    const x = process.env.ELECTRODE_FYI_LEVEL;
    if (Levels[x] === undefined) {
      logFyi2("error", [`env ELECTRODE_FYI_LEVEL ${x} is invalid`]);
    } else {
      if (global.ElectrodeFyiLevel !== undefined) {
        logFyi2("warn", [`overriding global.ElectrodeFyiLevel with env ELECTRODE_FYI_LEVEL ${x}`]);
      }
      global.ElectrodeFyiLevel = process.env.ELECTRODE_FYI_LEVEL;
      updateLevel();
    }
  }
};

function logFyi() {
  updateLevel();
  if (fyi._level <= Levels[this]) {
    logFyi2(this, arguments);
  }
}

function createLimiter(type) {
  return (tag, limit) => {
    let count = 0;
    let limitFunction;
    limitFunction = function() {
      if (count > limit) return;
      if (count === limit) {
        fyi[type](`${tag}: too many fyi ${type}s, supressing all further ${type}s.`);
        limitFunction.end = true;
      } else {
        fyi[type].apply(fyi, Array.prototype.slice.apply(arguments));
      }
      count++;
    };
    limitFunction.end = false;
    return limitFunction;
  };
}

function assert(cond, msg) {
  if (!cond) {
    if (typeof msg === "function") {
      msg = msg();
    }
    const err = new Error(msg);
    fyi.error(err.stack);
    throw err;
  }
}

const limitError = createLimiter("error");
const limitWarn = createLimiter("warn");
const limitInfo = createLimiter("info");

Object.assign(fyi, {
  _logger: console,
  _setLogger: logger => (fyi._logger = logger || console),
  _level: Levels.info,
  _levelStr: "info",
  _updateLevel: updateLevel,
  _setLevel: setLevel,
  _checkEnv: checkEnv,
  info: logFyi.bind("info"),
  warn: logFyi.bind("warn"),
  error: logFyi.bind("error"),
  assert,
  limitError,
  limitWarn,
  limitInfo
});

module.exports = fyi;

fyi._checkEnv();
