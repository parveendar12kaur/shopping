"use strict";

/* eslint-disable no-magic-numbers */

const _ = require("lodash");
const fs = require("fs");
const Path = require("path");
const optionalRequire = require("optional-require")(require);
const fyi = require("@walmart/electrode-fyi");
const tryCatch = require("@walmart/try-catch");

const HTTP_REDIRECT = 302;
const HTTP_REDIRECT_LEGACY = 320;
const HTTP_PERMANENTLY_CODE = 301;

/**
 * Load stats.json which is created during build.
 * The file contains bundle files which are to be loaded on the client side.
 *
 * @param {string} stats - optional, path of stats.json
 * @param {any} defaultStats - optional, if unable to load then resolve with this.
 * @returns {object} an object that's the webpack stats.json
 */
function loadStats(stats, defaultStats) {
  const path = stats || "dist/server/stats.json";
  return optionalRequire(Path.resolve(path), { default: defaultStats });
}

/**
 * Load assets.json if CDN is enabled.
 *
 * @param {Object} options - options for electrode-index-page Hapi plugin
 * @returns {Object} mapping of static files to CDN urls
 */
function loadCdnAssets(options) {
  if (!options.cdn.enabled) {
    fyi.info("electrode-index-page: options.cdn.enabled is not true - CDN will be disabled.");
    return {};
  }

  const assetsPath = options.assetsPath || options.cdn.mapping || options.cdn.assetsPath;

  let assets;

  const warn = msg => {
    if (!assets) {
      fyi.warn("electrode-index-page:", msg, assetsPath, "- CDN will be disabled");
    }
  };

  if (!assetsPath) return warn("invalid options.cdn.assetsPath");

  const stat = tryCatch(() => fs.lstatSync(assetsPath));

  if (stat && stat.isDirectory()) {
    assets = optionalRequire(Path.resolve(assetsPath, "config/assets.json"), false);
    warn("unable to find config/assets.json under options.cdn.assetsPath");
  } else {
    assets = optionalRequire(Path.resolve(assetsPath));
    warn("unable to load assets from options.cdn.assetsPath");
  }

  return assets || {};
}

function isRedirectNeeded(status) {
  return [HTTP_REDIRECT, HTTP_REDIRECT_LEGACY, HTTP_PERMANENTLY_CODE].indexOf(status) > -1;
}

/**
 * assets contain CDN mapping information, in format of {`filePath`: `url`}
 * filePath will differ on different environments, e.g. local, production
 * this function looks for file names inside keys and return corresponding urls
 * in a simpler format, e.g. {js: 'jsUrl', css: 'cssUrl'}
 *
 * @param {String} chunk name of the bundle chunk
 * @param {Object} cdnAssets contains raw mapping of static files to CDN urls
 * @param {Object} stats contains bundled files which are to be loaded on the client side.
 * @returns {Object} a simpler mapping of static files to CDN urls
 */
function parseChunkAssets(chunk, cdnAssets, stats) {
  const assetChunk = stats.assetsByChunkName[chunk];

  // get the original webpack JS and CSS bundle filename from stats
  const jsBundlePath = assetChunk[0];
  const cssBundlePath = assetChunk[1];

  // Necessary for IE9 CSS Split
  // https://jira.walmart.com/browse/GPRDT-541
  const splitPattern = /^\.*style\.[a-f0-9]{5,40}\-[0-9]{1,2}\.css$/;
  const splitCss = assetChunk
    .slice(2)
    .filter(asset => splitPattern.test(asset))
    .map(css => `/js/${css}`);

  const result = {
    js: `/js/${jsBundlePath}`,
    css: `/js/${cssBundlePath}`
  };

  // look inside CDN assets to find mapping of the original
  // webpack filename to CDN URL of the uploaded asset
  Object.keys(cdnAssets).forEach(key => {
    // first check split CSS
    for (let i = 0; i < splitCss.length; i++) {
      if (_.includes(key, splitCss[i].substr("/js/".length))) {
        splitCss[i] = cdnAssets[key];
        return;
      }
    }

    // check JS bundle and then CSS bundle
    if (_.includes(key, jsBundlePath)) {
      // match JS webpack filename, take CDN URL for JS
      result.js = cdnAssets[key];
    } else if (_.includes(key, cssBundlePath)) {
      // match CSS webpack filename, take CDN URL for CSS
      result.css = cdnAssets[key];
    }
  });

  result.splitCss = splitCss.length && splitCss;
  return result;
}

function parseAssets(stats, assets) {
  const chunks = stats.assetsByChunkName;

  return _.mapValues(chunks, (bundleData, chunk) => parseChunkAssets(chunk, assets, stats));
}

/**
 * Determine if we're running in an app using the internal archetype under the
 * @walmart scope. This can be either the Builder-based version of the archetype
 * or the Gulp-based version.
 *
 * @returns {Boolean} Whether or not the internal archetype is being used.
 */
function isInternalArchetype() {
  const name = "@walmart/electrode-archetype-react-app";
  // The easiest way to detect the Builder-based archetype is to check whether
  // this environment variable is set.
  const archetype = process.env.npm_package_config_archetype || "";
  if (archetype.indexOf(name) >= 0) {
    return true;
  }
  // Fall back to detecting whether the internal archetype is installed at all;
  // this doesn't completely guarantee that it's actually being used, but it's
  // a good indicator. This will detect both the Builder- and Gulp-based
  // versions.
  return Boolean(optionalRequire(`${name}/package.json`, { default: false }));
}

function getPwaManifest(assets) {
  const manifest = _.find(assets, asset => {
    return _.endsWith(asset.name, "manifest.json");
  });

  return manifest ? `/js/${manifest.name}` : "";
}

function getDevBundle(options, chunkName, fileName) {
  const devServer = options.devServer;
  const path = `${devServer.protocol}://${devServer.host}:${devServer.port}/js/`;

  // For backwards compatibility, use the path without `chunkName` in it if
  // we're on the internal archetype and don't have the `bundleChunkSelector`
  // function configured.
  return isInternalArchetype() && !options.bundleChunkSelector
    ? `${path}${fileName}`
    : `${path}${chunkName}.${fileName}`;
}

/**
 * Helper method to parse out and check the manual shelf CCM value for TTL Caching.
 * @param {array} ccmListCacheValue - Value from CCM i.e. ["shelf_id_one=1: 100000"]
 * @param {string} shelfPageUrl - shelf page URL i.e. /search/0/0/shelf_id_one=1&test...
 * @return {number} - value from ccm or 0
 */
function findManShelfValueWhitelist(ccmListCacheValue, shelfPageUrl) {
  if (ccmListCacheValue && shelfPageUrl) {
    for (let i = 0; i < ccmListCacheValue.length; i++) {
      const value = ccmListCacheValue[i];
      if (typeof value === "string") {
        const split = value.split(":");
        if (shelfPageUrl.match(split[0].trim())) {
          return parseInt(split[1]) || 0;
        }
      }
    }
  }
  return 0;
}

/*
 * The files webpack generated are uploaded to CDN (pronto), which returns new
 * unique URLs for each file.
 *
 * In order to translate the webpack generated filename to the CDN URL, filenames
 * are extracted from the assets.json file along with the corresponding CDN URL.
 *
 * This mapping is then returned in the Index template.
 * Any file loaded with the webpack cdn-file-loader are then loaded by looking
 * up the CDN URL using the file's webpack generated name.
 *
 * So we only need the file name, without all the full path info.
 */

function mapCdnAssets(assets) {
  return assets ? _.mapKeys(assets, (url, filePath) => Path.basename(filePath)) : undefined;
}

module.exports = {
  loadStats,
  loadCdnAssets,
  mapCdnAssets,
  isRedirectNeeded,
  parseChunkAssets,
  parseAssets,
  isInternalArchetype,
  getPwaManifest,
  getDevBundle,
  findManShelfValueWhitelist
};
