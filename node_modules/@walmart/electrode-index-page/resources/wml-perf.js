"use strict";

module.exports = function () {
  var native = window.performance || {};
  var wml = window._wml = window._wml || {};
  var entries = [],
      start = void 0,
      now = void 0;

  if (native.now) {
    wml.hasPerfNow = function () {
      return true;
    };
    start = native.now();
    now = native.now.bind(native);
  } else {
    //
    // Without native performance.now, we can only make relative measurements
    // using Date as a time line reference, but the actual time value is fairly meaningless.
    //
    // ** Reporting logic should check _wml.hasPerfNow() to be true and treat the
    //    marked timing differently.
    //
    wml.hasPerfNow = function () {
      return false;
    };
    start = new Date().getTime();
    now = function now() {
      return new Date().getTime() - start;
    };
  }

  // new entry
  function newEntry(duration, type, name, startTime) {
    return { duration: duration, entryType: type, name: name, startTime: startTime };
  }

  // find entry
  // type = type of entry
  // value = value of entry to match
  // count = max # to match
  function findEntry(type, value, count) {
    var result = [];
    var found = 0;
    count = isNaN(count) ? entries.length : count;
    for (var i = 0; i < entries.length && found < count; i++) {
      if (entries[i][type] === value) {
        result.push(entries[i]);
        found++;
      }
    }
    return result;
  }

  // find entry by name
  // name = name of entry
  // count = max # to match
  function findEntriesByName(name, count) {
    return findEntry("name", name, count);
  }

  // find entry by type
  // t = type of entry
  // c = max # to match
  function findEntriesByType(type, count) {
    return findEntry("entryType", type, count);
  }

  function getNative(x) {
    return x.mark && x.measure && x.getEntries && x.getEntriesByType && x.getEntriesByName && x;
  }

  wml.perf = getNative(native) || {
    entries: entries,
    start: start,
    now: now,
    mark: function mark(name) {
      entries.push(newEntry(0, "mark", name, now()));
    },
    measure: function measure(name, mark1, mark2) {
      if (!name || !mark1 || !mark2) return;
      var x1 = findEntriesByName(mark1, 1)[0],
          x2 = findEntriesByName(mark2, 1)[0];
      if (x1 && x2) {
        entries.push(newEntry(x2.startTime - x1.startTime, "measure", name, x1.startTime));
      }
    },
    getEntries: function getEntries() {
      return entries;
    },
    getEntriesByType: function getEntriesByType(type) {
      return findEntriesByType(type);
    },
    getEntriesByName: function getEntriesByName(name) {
      return findEntriesByName(name);
    },
    _feN: findEntriesByName,
    _feT: findEntriesByType
  };

  wml.perf.mark("index-start");
};