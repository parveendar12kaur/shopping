"use strict";

/* eslint-disable no-magic-numbers, consistent-return */

const pageTypes = require("./page-types").pageTypes;
const categoryCache = require("./category-cache");

const _ = require("lodash");

const typeToRegexMap = {
  browse: new RegExp("^/(?:browse|search)/(?!autocomplete)(?:[^/]+/){0,2}([0-9_]+)"),
  category: new RegExp("^/(?:category|cp)/(?:[^/]+/)?(\\d+)"),
  topic: new RegExp("^/(?:topic|tp|c)/(?:[^/]+/)?([a-zA-Z-_]+)"),
  storeTopic: new RegExp("^/(?:topic|c/store)/(\\d+)/([a-zA-Z-_]+)"),
  brand: new RegExp("^/(?:brand)/(?:[^/]+/)?([a-zA-Z-_]+)"),
  marketing: new RegExp("^/(?:mk)/(?:[^/]+/)?([a-zA-Z-_]+)")
};

const regexOrder = ["storeTopic", "topic", "browse", "category", "brand", "marketing"];

const DEFAULT_TIMEOUT = 900;

const buildMetadataUrl = (metadataUrl, type, pageId) => {
  return `${metadataUrl}/${type}/__/${pageId}.json.gz`;
};

class MetadataFetch {
  constructor(options, cb) {
    this.tag = "SEO Metadata fetch";
    this.setup(options);

    if (cb) {
      if (!this.url) {
        return cb(Error("Invalid url"));
      } else {
        return this.fetch(
          {
            compress: true,
            noInject: true,
            timeout: this.timeout
          },
          (err, seoTags) => {
            if (err) return cb(err);
            seoTags.canonical = seoTags.metaCanon || this.getCanonicalUrl();
            cb(null, seoTags);
          }
        );
      }
    }
  }

  setup(options) {
    if (!_.isEmpty(options.sourceUrl)) {
      const typeAndId = MetadataFetch.derivePageFromPath(options.sourceUrl);
      this.pageType = typeAndId.type;
      this.pageId = typeAndId.id;
    } else {
      this.pageType = options.pageType;
      this.pageId = options.pageId;
    }

    if (options.config && this.pageType && this.pageId) {
      this.url = buildMetadataUrl(options.config.serverUrl, this.pageType, this.pageId);
    }
    this.request = options.request;
    this.timeout = options.timeout || DEFAULT_TIMEOUT;
  }

  getUrl() {
    return this.url || null;
  }

  getCanonicalUrl() {
    if (this.pageId && this.pageType === pageTypes.category) {
      return categoryCache.resolveCategoryPath(this.pageId);
    }
    return null;
  }

  static derivePageFromPath(path) {
    let id = null;
    let type = pageTypes.default;

    if (path) {
      _.each(regexOrder, key => {
        const match = path.match(typeToRegexMap[key]);
        if (match) {
          id = key === "storeTopic" ? `store-${match[1]}-${match[2]}` : match[1];
          type = pageTypes[key];
          return false; // break
        }
      });
    }

    return { id, type };
  }
}

MetadataFetch.prototype.fetch = require("./fetch").fetch;

module.exports = {
  metadataFetch: (options, cb) => new MetadataFetch(options, cb),
  _MetadataFetch: MetadataFetch
};
