"use strict";

/* eslint-disable no-magic-numbers, no-return-assign */
/* istanbul ignore next */
const CLIENT_DIR = process.env.NODE_ENV === "production" ? "../../minified" : "../client";
const React = require("react");
const ReactDOMServer = require("react-dom/server");
const Hoek = require("hoek");
const Path = require("path");
const resolveDeviceType = require("@walmart/psych/lib/resolve-device-type");
const pkg = require("../../package.json");
const Promise = require("bluebird");
const _ = require("lodash");
const getExperimentationData = require("../get-exp-data");
const IndexTemplate = require("../templates/index").default;
const ErrorTemplate = require("../templates/error").default;
const mapCdnAssets = require("../map-cdn-assets");
const clientCdnMap = require(`${CLIENT_DIR}/client-cdn-map`);
const Stream = require("stream");
const PageMetadata = require("@walmart/electrode-seo-metadata").PageMetadata;
const clientRewriteCdn = require(`${CLIENT_DIR}/rewrite-cdn-host`);
const wmlPerf = require(`${CLIENT_DIR}/wml-perf`);
const addURIEncoding = require("../utils/add-uri-encoding");
const findManShelfValueWhitelist = require("../utils/find-manual-shelf-value-whitelist");
const removeURIEncoding = require(`${CLIENT_DIR}/remove-uri-encoding`);
const Cookies = require("@walmart/electrode-cookies");

const utils = require("./utils");

const loadStats = utils.loadStats;
const loadAssets = utils.loadAssets;
const isRedirectNeeded = utils.isRedirectNeeded;
const parseAssets = utils.parseAssets;
const getPwaManifest = utils.getPwaManifest;
const getDevBundle = utils.getDevBundle;
const getIconStats = utils.getIconStats;
const getCriticalCSS = utils.getCriticalCSS;
const getBundleProps = utils.getBundleProps;

const HTTP_OK = 200;
const HTTP_ERROR_500 = 500;
const MILLI_SECONDS = 1000;

/**
 * Why the magic-number 4097? it's just that the browser doesn't parse
 * and display anything until it has received enough data to bother parsing it.
 * Sending your chunks of 4097 gives the browser a push to parse part of the document
 *
 * highWaterMark - the maximum number of bytes to store in the internal
 * buffer before ceasing to read from the underlying resource.
 */
const STREAM_BUFFER_BYTES = 4097;

/**
 * Tries to import bundle chunk selector function if the corresponding option is set in the
 * webapp plugin configuration. The function takes Hapi `request` object as an argument and
 * returns the chunk name.
 *
 * @param {Object} options - webapp plugin configuration options
 * @return {Function} function that selects the bundle based on the Hapi request object
 */
function resolveChunkSelector(options) {
  if (options.bundleChunkSelector) {
    return require(Path.join(process.cwd(), options.bundleChunkSelector)); // eslint-disable-line
  }

  // If nothing is specified, default to the chunk name "main", which is reserved by the
  // Webpack for cases when app has a single entry point.
  return () => ({
    css: "main",
    js: "main"
  });
}

function makeRouteHandler(options) {
  const addCDNMapping = () => {
    if (options.cdn.enabled) {
      const cdnMap = mapCdnAssets(options.assetsPath);
      if (cdnMap) {
        const md = JSON.stringify(cdnMap, null, 2);
        const cdnMapScript = `window._wml.cdn={
          md:${md},
          map:${clientCdnMap.toString()}}/*CDN*/;`;
        options.unbundledJS.enterHead.unshift(cdnMapScript);
      }
    }
  };

  const addRewriteCdnHost = () => {
    const rewriteCdnScript = `(${clientRewriteCdn.rewriteCdnHost.toString()})()/*RCDN*/;`;
    options.unbundledJS.preBundle.unshift(rewriteCdnScript);
  };

  addCDNMapping();
  addRewriteCdnHost();
  options.unbundledJS.firstScripts.unshift(`(${wmlPerf.toString()})();`);

  const assets = options.__internals.assets;
  const assetsDll = options.__internals.assetsDll;
  const iconStats = getIconStats(options.iconStats);
  const criticalCSS = getCriticalCSS(options.criticalCSS);
  const pwaManifest = options.__internals.pwaManifest;

  const WEBPACK_DEV = options.webpackDev;
  const RENDER_JS = options.renderJS;
  const RENDER_SS = options.serverSideRendering;
  const DOM_STREAM = options.domStream || false;
  const CONTENT_MARKER = "{{SSR_CONTENT}}";
  const CCM_SSR_SWITCH_NAME = `server.app.ccm["electrode-react"].disableServerRenderingConfig`; // eslint-disable-line

  const chunkSelector = resolveChunkSelector(options);

  /* eslint max-statements: [2, 40] */
  return function routeHandler(request, reply, userContent) {
    const mode = request.query.__mode || "";
    const renderJs = RENDER_JS && mode !== "nojs";
    let renderSs = RENDER_SS && mode !== "noss" && !request.app.disableSSR;

    // If SSR is still enabled at this point, check to see if the CCM switch
    // has been set to disable Server Side Rendering
    if (renderSs && `${_.get(request, CCM_SSR_SWITCH_NAME, false)}` === "true") {
      renderSs = false;
    }

    // Persist disabled SSR in request if flag not set
    // For the benefit of electrode-redux-router-engine
    if (!renderSs) {
      request.app.disableSSR = true;
    }

    const earlyFlush = DOM_STREAM || request.query.domStream;
    const isMobile = resolveDeviceType(request.headers) === "mobile";

    const chunk = chunkSelector(request);
    const jsChunk = chunk.js;
    const cssChunk = chunk.css;

    const bundleCss = () => {
      return WEBPACK_DEV ? getDevBundle(options, cssChunk, "style.css") : assets[cssChunk].css;
    };

    const bundleSplitCss = () => {
      return WEBPACK_DEV ? null : assets[cssChunk].splitCss;
    };

    const bundleJs = () => {
      return WEBPACK_DEV ? getDevBundle(options, jsChunk, "bundle.dev.js") : assets[jsChunk].js;
    };

    const bundleJsDll = () => {
      return WEBPACK_DEV ? null : Object.keys(assetsDll).map(dllChunk => assetsDll[dllChunk].js);
    };

    const conditionalStyles = renderedMarkup => {
      // If we have no split css files, just return the
      // markup as is
      const chunkAssets = assets[cssChunk];
      if (!chunkAssets || !chunkAssets.splitCss) {
        return renderedMarkup;
      }

      // Welcome to hacksville, population: you
      // This awful action is to insert a conditional
      // comment, something that JSX cannot handle itself.
      // See this issue on the react repo for details:
      // https://github.com/facebook/react/issues/1035
      const pattern = /(<link id="bundledCss".*\/>).*<link data\-href="(.*\.css)"\/>/;

      return renderedMarkup.replace(pattern, (m, p1, p2) => {
        const splitFiles = p2.split(";");
        let splits = "";

        splitFiles.forEach((cssPath, i) => {
          splits += `<link key=${i} rel="stylesheet" type="text/css" href="${cssPath}"/>\n`;
        });

        return `
<!--[if !IE 9]><!-->${p1}<!--<![endif]-->
<!--[if IE 9]>\n${splits}<![endif]-->
        `;
      });
    };

    const renderIndex = statusCode => {
      const element = React.createElement(IndexTemplate, {
        render: {
          js: renderJs
        },
        bundles: {
          js: renderJs && bundleJs(),
          jsDll: renderJs && bundleJsDll(),
          css: bundleCss(),
          splitCss: bundleSplitCss()
        },
        pwaManifest: pwaManifest,
        iconStats: iconStats,
        criticalCSS: criticalCSS,
        uiConfig: options.uiConfig,
        envInfo: options.envInfo,
        unbundledJS: options.unbundledJS,
        typekitId: options.typekitId,
        dnsPrefetch: options.dnsPrefetch,
        metaTags: options.metaTags.app,
        unbundledStyle: options.unbundledStyle,
        bodyBundleInHeader: options.bodyBundleInHeader,
        content: CONTENT_MARKER,
        bundleProps: getBundleProps(request, options),
        jwt: request.app.jwt,
        correlationId: request.app.correlationId,
        ccm: request.app.uiCCM || request.server.app.uiCCM,
        excludeTorbitContentCheck: options.excludeTorbitContentCheck,
        noPciCompliance: options.noPciCompliance,
        statusCode: statusCode || "",
        expoPrefix: options.expoPrefix,
        isMobile: isMobile,
        request
      });

      return conditionalStyles(ReactDOMServer.renderToStaticMarkup(element));
    };

    const renderMetadata = () => {
      const renderedElements = request.app.pageMetadata.getHeadElements().map(elementInfo => {
        return ReactDOMServer.renderToStaticMarkup(
          React.createElement(elementInfo.el, elementInfo.elProps, elementInfo.value)
        );
      });

      const seoTags = JSON.stringify(
        addURIEncoding(_.assign(request.app.pageMetadata.getSourceData(), request.app.seoTags))
      );

      renderedElements.push(
        `<script>window._wml.seoTags = (${removeURIEncoding.toString()})(${seoTags});</script>`
      ); // eslint-disable-line

      if (request.app.relm) {
        const relm = JSON.stringify(request.app.relm);
        renderedElements.push(`<script>window._wml.relm = ${relm};</script>`);
      }

      return renderedElements.join("");
    };

    const getErrorContent = statusCode => {
      // if a `NewYork=1` cookie is present, show the redesigned error page
      const isNewYork = Cookies.get("NewYork", { request }) === "1";
      const element = React.createElement(ErrorTemplate, { statusCode, isNewYork });
      return ReactDOMServer.renderToStaticMarkup(element);
    };

    /*
     * In order to support early flush SSR:
     *
     * 1. Start the async requests for expData and userContent
     * 2. Render index immediately, but for the async data user content
     *    - A static marker {{SSR_CONTENT}} for html, to be replaced by the real content
     *    - prefetch to be sent right before </head>
     * 3. If early flush on, then send index up to the </head> tag.
     * 4. Wait for async data
     * 5. If error occurred or redirect requested
     *    - If early flush on, then send <meta> redirect
     *      (to 404/500 page or requested redirect page).
     *    - If early flush off and need to redirect, then use reply to redirect.
     *    - Else continue work.
     * 6. If early flush off, then send index up to the </head> tag.
     * 7a. If error occurred, send error content and stop.
     * 7b. Send expData and prefetch from async result
     * 8. Send the remaining index up to marker {{SSR_CONTENT}}
     * 9. Send content from async result
     * 10. Send rest of index after {{SSR_CONTENT}}
     *
     */

    const callUserContent = content => {
      const x = content(request);
      return !x.catch
        ? x
        : x.catch(err => {
            request.log(["error"], { err: err });
            return {
              status: err.status || HTTP_ERROR_500,
              html: err.toString()
            };
          });
    };

    const renderSSRContent = content => {
      return _.isFunction(content)
        ? callUserContent(content)
        : Promise.resolve(_.isObject(content) ? content : { html: content });
    };

    let index;
    let headMark;
    let stream;

    // step 1: Start the async requests for expData and userContent
    const expDataAsync = getExperimentationData(request);
    const seoAsync = request.app.seoAsync || Promise.resolve();
    const ccmReady = request.app.ccmReady || Promise.resolve();
    const userContentAsync = ccmReady.then(() => renderSSRContent(userContent));
    /*
     * Will add Cache headers to control Akamai caching or browser caching.
     * This functionality will be controlled by the property `ccmPathToCacheTTLValue` defined
     * in the configuration and passed as an option to the web-app.
     * The `ccmPathToCacheTTLValue` is the path to the CCM value where we can find the TTL
     * in milliseconds. A zero value means that we do not want cache enable.
     */
    const setCacheControlHeaders = status => {
      const cacheTTLCCMValueInMs = _.get(
        request,
        `server.app.ccm${options.ccmPathToCacheTTLValue}`
      );
      request.log(["debug"], {
        msg: "cacheTTLCCMValueInMs",
        cacheTTLCCMValueInMs: cacheTTLCCMValueInMs
      });

      const ccmCacheCookieListDisablements = _.get(
        request,
        `server.app.ccm${options.ccmPathToCookieListDisablements}`,
        ""
      );

      const ccmCacheManualShelTTLWhiteList = _.get(
        request,
        `server.app.ccm${options.ccmPathToManualShelfTTLWhitelist}`,
        ""
      );

      const ccmListCacheCookies = ccmCacheCookieListDisablements.split(",");
      const ccmListCacheManualShelf = ccmCacheManualShelTTLWhiteList.split(",");
      let enableTTLCache = true;
      let customMaxAge = 0;
      const shelfPagePath = _.get(request, "url.path", "");

      // modify ttl caching times based on specified manual shelf pages from ccm whitelist
      if (ccmListCacheManualShelf && ccmListCacheManualShelf !== null) {
        const customTTLValue = findManShelfValueWhitelist(ccmListCacheManualShelf, shelfPagePath);
        if (customTTLValue) {
          customMaxAge = customTTLValue;
        }
      }

      // disable caching if any disablements are listed from CCM
      if (ccmCacheCookieListDisablements && ccmCacheCookieListDisablements !== null) {
        ccmListCacheCookies.map(cookieName => {
          const cookieValue = Cookies.get(cookieName.trim(), { request });
          if (cookieValue) {
            enableTTLCache = false;
          }
        });
      }

      // determine whether or not to enable TTL caching based on CCM values
      const maxAgeToggle =
        (cacheTTLCCMValueInMs && cacheTTLCCMValueInMs !== "0") || customMaxAge !== 0;

      if (maxAgeToggle && enableTTLCache) {
        const parsedValue = customMaxAge || parseInt(cacheTTLCCMValueInMs);
        const ttl = isNaN(parsedValue) ? 0 : parsedValue;
        const maxAge = Math.floor(ttl / MILLI_SECONDS);
        const now = new Date();
        const expires = new Date(Date.now() + ttl);
        reply(stream)
          .code(status || HTTP_OK)
          .header("Cache-Control", `max-age=${maxAge}, must-revalidate, public`)
          .header("Expires", expires.toString())
          .header("Last-Modified", now.toString())
          .type("text/html");
      } else {
        reply(stream)
          .type("text/html")
          .code(status || HTTP_OK);
      }
    };

    const sendHead = status => {
      headMark = index.indexOf("</head>");
      stream = new Stream.PassThrough({ highWaterMark: STREAM_BUFFER_BYTES });
      setCacheControlHeaders(status);
      stream.write("<!DOCTYPE html>");
      stream.write(index.substring(0, headMark));
    };

    const sendMetaRedirect = reUrl => {
      stream.write(`<meta http-equiv="refresh" content="0;URL=${reUrl}" /></head>`);
      stream.end();
    };

    const sendErrorStatus = status => {
      stream.write(`<meta name="robots" content="noindex" />`);
      stream.write("</head><body>");
      stream.write(getErrorContent(status));
      stream.write("</body></html>");
      stream.end();
    };

    const writeExpData = expData => {
      if (options.noPciCompliance) {
        if (expData) {
          stream.write("<script>window._exp = ");
          stream.write(JSON.stringify(expData));
          stream.write(";</script>");
        }
      } else {
        // WARNING: When application has "PCI compliance" enabled, it is desired to ensure that
        // the generated HTML has a least possible number of variations from request to request
        // since any unaccounted variation causes the generated HTML to have a _different_ SHA
        // and therefore triggers PCI compliance violation alerts.
        // Below we generate a script to populate expo data _even_ when the data is empty, to
        // not let Torbit generate different SHAs for responses with Expo data.
        const data = { expData: expData || {} };
        stream.write(`<script id="tb-djs-wml-exp-data" type="application/json">`);
        stream.write(JSON.stringify(data));
        stream.write("</script><script>");
        stream.write(
          `window._exp=window._Dyn.create("#tb-djs-wml-exp-data").get("expData");</script>`
        );
      }
    };

    const writePrefetchData = content => {
      if (content && content.prefetch) {
        const needScript = !content.prefetch.startsWith("<script");
        if (needScript) stream.write("<script>");
        stream.write(content.prefetch);
        if (needScript) stream.write("</script>");
      }
    };

    request.app.pageMetadata = new PageMetadata(
      {
        defaults: _.merge(
          {
            title: options.pageTitle,
            titleSuffix: options.pageTitleSuffix
          },
          options.metaTags.seo
        ),
        peeps: seoAsync.then(() => _.get(request.app, "seoTags.peeps")),
        preso: _.get(request.app, "seoTags.preso")
      },
      _.get(options, "metaTags.seoOptions")
    );

    Promise.try(() => ccmReady)
      .then(() => (index = renderIndex())) // step 2: render index
      .then(() => {
        // step 3: if early flush on, then send index up to the </head> tag
        if (earlyFlush) {
          sendHead();

          // signal torbit to flush head up to now
          stream.write(`<meta name="tbflush"/>`);
        }

        // step 4: wait for async data
        return Promise.join(expDataAsync, userContentAsync, seoAsync);
      })
      .then(asyncData => {
        const expData = asyncData[0];
        const content = asyncData[1];
        const status = (content && content.status) || HTTP_OK;
        // step 5: check error or redirect
        if (status !== HTTP_OK) {
          if (isRedirectNeeded(status)) {
            return earlyFlush
              ? sendMetaRedirect(content.path)
              : reply.redirect(content.path).code(status);
          } else if (earlyFlush) {
            return sendErrorStatus(status);
          }
        }

        // step 6: if early flush off, then send index up to </head> tag
        if (!earlyFlush) {
          sendHead(status);
        }

        // step 7a: If error occurred, send error content and stop.
        if (status !== HTTP_OK) {
          return sendErrorStatus(status);
        }

        // step 7b: Send expData and prefetch from async result
        writeExpData(expData);
        writePrefetchData(content);

        stream.write(renderMetadata());

        // step 8: Send the remaining index up to marker {{SSR_CONTENT}}
        const contentMark = index.indexOf(CONTENT_MARKER);
        stream.write(index.substring(headMark, contentMark));

        // step 9: Send content from async result if we're doing SSR
        if (renderSs && content && content.html) {
          stream.write(content.html);
        }

        // step 10: Send rest of index after {{SSR_CONTENT}}
        stream.write(index.substring(contentMark + CONTENT_MARKER.length));

        return stream.end();
      })
      .catch(err => {
        request.log(["error"], { err: err });

        const status = err.status || HTTP_ERROR_500;
        if (stream) {
          sendErrorStatus(status);
        } else {
          reply(err.message).code(status);
        }
      });
  };
}

const RegisterRoutes = (server, options, next) => {
  const env = process.env;

  const pluginOptionsDefaults = {
    pageTitle: "Untitled Electrode Web Application",
    metaTags: {
      app: {
        charSet: { charSet: "utf-8" },
        httpEquiv: { httpEquiv: "X-UA-Compatible", content: "IE=edge,chrome=1" },
        viewport: "width=device-width, initial-scale=1.0"
      },
      seo: {}
    },
    unbundledJS: {
      firstScripts: [],
      enterHead: [],
      preBundle: [],
      postBundle: []
    },
    unbundledStyle: null,
    bodyBundleInHeader: false,
    typekitId: "fqp0lia",
    expData: null,
    webpackDev: env.WEBPACK_DEV === "true",
    renderJS: true,
    serverSideRendering: true,
    iconStats: "dist/server/iconstats.json",
    criticalCSS: "dist/js/critical.css",
    devServer: {
      protocol: "http",
      host: "localhost",
      port: env.WEBPACK_DEV_MIDDLEWARE === "true" ? env.PORT || "3000" : "2992"
    },
    bundleProps: {},
    paths: {},
    cdn: {
      enabled: false,
      mapping: "" // file path of assets.json
    },
    stats: "", // optional, path of stats.json,
    statsDll: "dist/server/stats.dll.json",
    excludeTorbitContentCheck: false,
    envInfo: {
      APP_SHA: env.APP_SHA,
      APP_VERSION: env.APP_VERSION
    },
    expoPrefix: null // optional, for expo cookies prefix
  };

  const pluginOptions = Hoek.applyToDefaults(pluginOptionsDefaults, options);

  // provide a default main chunk for dev/hot mode where webpack
  // doesn't spit out stats to disk
  const defaultMainStats = {
    assetsByChunkName: {
      main: ["", ""]
    }
  };

  const defaultEmptyStats = { assetsByChunkName: {} };

  return Promise.join(
    loadStats(pluginOptions.stats, defaultMainStats),
    loadStats(pluginOptions.statsDll, defaultEmptyStats),
    loadAssets(pluginOptions.cdn),
    (stats, statsDll, assets) => {
      pluginOptions.__internals = {
        pwaManifest: getPwaManifest(stats.assets),
        assets: parseAssets(stats, assets),
        assetsDll: parseAssets(statsDll, assets)
      };

      const uiConfig = server.settings.app.config.ui || {};
      const basePath = uiConfig.basePath || "/";
      pluginOptions.uiConfig = uiConfig;

      const resolveContent = info => {
        const content = info.content || info;
        if (pluginOptions.serverSideRendering !== false) {
          if (!_.isString(content) && !_.isFunction(content) && content.module) {
            const mod = Path.join(process.cwd(), content.module);
            const fullPath = require.resolve(mod);
            const xrequire = require;
            return { resolveTime: Date.now(), fullPath, xrequire, content: xrequire(mod) };
          }
          return { content };
        }
        return { content: { status: 200, html: "" } };
      };

      const route = (info, path, method) => {
        const handler = makeRouteHandler(_.merge({}, pluginOptions, info.options));
        let content;

        server.route({
          method,
          path: Path.posix.join(basePath, path),
          config: info.config || {},
          handler: (request, reply) => {
            if (request.app.webpackDev) {
              const wpd = request.app.webpackDev;
              if (!wpd.valid) {
                content = { content: "<!-- Webpack still compiling -->" };
              } else if (wpd.hasErrors) {
                content = { content: "<!-- Webpack compile has errors -->" };
              } else if (!content || content.resolveTime < wpd.compileTime) {
                if (content && content.fullPath) {
                  delete content.xrequire.cache[content.fullPath];
                }
                content = resolveContent(info);
              }
            } else if (!content) {
              content = resolveContent(info);
            }

            return handler(request, reply, content.content);
          }
        });
      };

      _.each(pluginOptions.paths, (pathInfo, path) => {
        _.each(pathInfo.methods || ["get"], methods => {
          route(pathInfo, path, methods);
        });
      });

      next();
    }
  ).catch(err => {
    next(err);
  });
};

RegisterRoutes.attributes = { pkg };

module.exports = RegisterRoutes;
