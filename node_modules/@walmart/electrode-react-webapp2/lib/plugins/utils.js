"use strict";

/* eslint-disable no-magic-numbers */

const _ = require("lodash");
const fs = require("fs");
const Path = require("path");
const Promise = require("bluebird");

const HTTP_REDIRECT = 302;
const HTTP_REDIRECT_LEGACY = 320;
const HTTP_PERMANENTLY_CODE = 301;

/**
 * Load stats.json which is created during build.
 * The file contains bundle files which are to be loaded on the client side.
 *
 * @param {string} stats - optional, path of stats.json
 * @param {any} defaultStats - optional, if unable to load then resolve with this.
 * @returns {Promise.<Object>} an object containing an array of file names
 */
function loadStats(stats, defaultStats) {
  const path = stats || "dist/server/stats.json";
  return Promise.resolve(Path.join(process.cwd(), path))
    .then(require)
    .catch(() => defaultStats);
}

/**
 * Load assets.json if CDN is enabled.
 *
 * @param {Object} cdn - CDN mapping information
 * @returns {Promise.<Object>} mapping of static files to CDN urls
 */
function loadAssets(cdn) {
  if (!cdn || !cdn.enabled) {
    return Promise.resolve({});
  }

  if (!cdn.mapping) {
    return Promise.reject(new Error("missing mapping file"));
  }

  return Promise.resolve(Path.join(process.cwd(), cdn.mapping)).then(require);
}

function isRedirectNeeded(status) {
  return [HTTP_REDIRECT, HTTP_REDIRECT_LEGACY, HTTP_PERMANENTLY_CODE].indexOf(status) > -1;
}

/**
 * assets contain CDN mapping information, in format of {`filePath`: `url`}
 * filePath will differ on different environments, e.g. local, production
 * this function looks for file names inside keys and return corresponding urls
 * in a simpler format, e.g. {js: 'jsUrl', css: 'cssUrl'}
 *
 * @param {String} chunk name of the bundle chunk
 * @param {Object} assets contains raw mapping of static files to CDN urls
 * @param {Object} stats contains bundled files which are to be loaded on the client side.
 * @returns {Object} a simpler mapping of static files to CDN urls
 */
function parseChunkAssets(chunk, assets, stats) {
  const jsBundlePath = stats.assetsByChunkName[chunk][0];
  const cssBundlePath = stats.assetsByChunkName[chunk][1];

  // Necessary for IE9 CSS Split
  // https://jira.walmart.com/browse/GPRDT-541
  const splitPattern = /style\.[a-f0-9]{5,40}\-[0-9]{1,2}\.css$/;
  const splitCss = stats.assetsByChunkName[chunk]
    .filter(asset => splitPattern.test(asset))
    .map(css => `/js/${css}`);

  const result = {
    js: `/js/${jsBundlePath}`,
    css: `/js/${cssBundlePath}`
  };

  Object.keys(assets).forEach(key => {
    if (_.includes(key, jsBundlePath)) {
      result.js = assets[key];
    } else if (_.includes(key, cssBundlePath)) {
      result.css = assets[key];
    } else {
      _.forEach(splitCss, (path, i) => {
        if (_.includes(key, path.substr("/js/".length))) {
          splitCss[i] = assets[key];
        }
      });
    }
  });

  result.splitCss = splitCss.length && splitCss.join(";");
  return result;
}

function parseAssets(stats, assets) {
  const chunks = stats.assetsByChunkName;

  return _.mapValues(chunks, (bundleData, chunk) => parseChunkAssets(chunk, assets, stats));
}

/**
 * Determine if we're running in an app using the internal archetype under the
 * @walmart scope. This can be either the Builder-based version of the archetype
 * or the Gulp-based version.
 *
 * @returns {Boolean} Whether or not the internal archetype is being used.
 */
function isInternalArchetype() {
  // The easiest way to detect the Builder-based archetype is to check whether
  // this environment variable is set.
  const archetype = process.env.npm_package_config_archetype || "";
  if (archetype.indexOf("@walmart/electrode-archetype-react-app") >= 0) {
    return true;
  }
  // Fall back to detecting whether the internal archetype is installed at all;
  // this doesn't completely guarantee that it's actually being used, but it's
  // a good indicator. This will detect both the Builder- and Gulp-based
  // versions.
  try {
    require.resolve("@walmart/electrode-archetype-react-app");
  } catch (err) {
    return false;
  }
  return true;
}

function getPwaManifest(assets) {
  const manifest = _.find(assets, asset => {
    return _.endsWith(asset.name, "manifest.json");
  });

  return manifest ? `/js/${manifest.name}` : "";
}

function getDevBundle(options, chunkName, fileName) {
  const devServer = options.devServer;
  const path = `${devServer.protocol}://${devServer.host}:${devServer.port}/js/`;

  // For backwards compatibility, use the path without `chunkName` in it if
  // we're on the internal archetype and don't have the `bundleChunkSelector`
  // function configured.
  return isInternalArchetype() && !options.bundleChunkSelector
    ? `${path}${fileName}`
    : `${path}${chunkName}.${fileName}`;
}

function getIconStats(iconStatsPath) {
  let iconStats;
  try {
    iconStats = fs.readFileSync(Path.resolve(process.cwd(), iconStatsPath)).toString();
    iconStats = JSON.parse(iconStats);
  } catch (err) {
    return "";
  }
  if (iconStats && iconStats.html) {
    return iconStats.html;
  }
  return iconStats;
}

function getCriticalCSS(path) {
  const criticalCSSPath = Path.resolve(process.cwd(), path);

  try {
    const criticalCSS = fs.readFileSync(criticalCSSPath).toString();
    return criticalCSS;
  } catch (err) {
    return "";
  }
}

function getArtifactId(req) {
  return _.get(
    req,
    "server.app.config.services.providers['@walmart/electrode-ccm-client'].options.artifactId",
    ""
  );
}

function getAppCCM(req, artifactId) {
  return _.get(req, `server.app.ccm.${artifactId}`, {});
}

function getBundleProps(req, options) {
  let ccmAsync;
  const asyncOption = {};
  const deferOption = {};
  if (options.ccmMap) {
    const artifactId = getArtifactId(req);
    const appCCM = getAppCCM(req, artifactId);
    const keyPath = options.ccmMap.asyncEnabled;
    ccmAsync = _.get(appCCM, keyPath);
  }
  if (ccmAsync) {
    if (ccmAsync === "true") {
      asyncOption.async = "async";
    }
  } else if (options.asyncEnabled) {
    asyncOption.async = "async";
  }
  if (options.deferEnabled) {
    deferOption.defer = "defer";
  }
  return _.defaults(options.bundleProps, asyncOption, deferOption);
}

module.exports = {
  loadStats,
  loadAssets,
  isRedirectNeeded,
  parseChunkAssets,
  parseAssets,
  isInternalArchetype,
  getPwaManifest,
  getDevBundle,
  getIconStats,
  getCriticalCSS,
  getBundleProps
};
