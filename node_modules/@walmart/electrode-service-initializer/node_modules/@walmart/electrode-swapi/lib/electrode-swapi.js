"use strict";
/* eslint max-params: [2, 5] */
/* eslint-disable camelcase, max-statements */

const yaml = require("js-yaml");
const Swagger = require("@walmart/swagger-client");
const Promise = require("bluebird");
const fs = require("fs");
const readFile = Promise.promisify(fs.readFile);
const Validator = require("swagger-model-validator");
const path = require("path");
const _ = require("lodash");
const isUndefined = require("lodash/isUndefined");
const assign = require("lodash/assign");
const isString = require("lodash/isString");
const defaults = require("lodash/defaults");
const defaultsDeep = require("lodash/defaultsDeep");
const each = require("lodash/each");
const isFunction = require("lodash/isFunction");
const isObject = require("lodash/isObject");
const pickBy = require("lodash/pickBy");
const merge = require("lodash/merge");
const pick = require("lodash/pick");
const cloneDeep = require("lodash/cloneDeep");
const find = require("lodash/find");
const get = require("lodash/get");
const omit = require("lodash/omit");
const WmlSoa = require("@walmart/electrode-wml-soa");
const tryCatch = require("@walmart/try-catch");
const metrics = require("@walmart/electrode-metrics");
const assert = require("assert");
const KeepAlive = require("./keep-alive");
const optionalRequire = require("optional-require")(require);
const logTransaction = optionalRequire("@walmart/electrode-log-transaction");
const fyi = require("@walmart/electrode-fyi");

const STATIC_HEADERS = Symbol("STATIC_HEADERS");

let transaction;
if (logTransaction) {
  fyi.info("electrode-swapi using @walmart/electrode-log-transaction");
} else {
  const logging = optionalRequire("@walmart/electrode-logging");
  transaction = logging && logging.transaction;
  if (!transaction) {
    fyi.warn("electrode-swapi: transaction logs disabled because no support module found");
  }
}

//
// WM headers defined here
// https://confluence.walmart.com/pages/viewpage.action?title=SOA+Header+Elements&spaceKey=PGPSOA
//
const _WM_HEADERS = WmlSoa.wmHeaders;
const _WM_SERVICE_TYPES = WmlSoa.wmServiceTypes;

const xWmSignHeaders = "x-wm-sign-headers";
const xWmOptionalParams = "x-wm-optional-params";

let SUPPORT_KEEP_ALIVE = true;

/*
 *
 * Electrode Swagger based client to mid tier platform service APIs
 *
 */

/*
 * Swagger 2.0 doesn't support optional path parameters, but we can do some
 * preprocessing to support {/param} syntax. This marks any path parameter
 * whose name starts with '/' as optional and sets its default to an empty
 * string. It will be passed through in the URL without any substitution; we
 * then replace it in `requestInterceptor` below.
 */
function parameterMacro(operation, parameter) {
  const isOptionalParam = () => {
    return parameter.in === "path" && parameter.name.match(/^[+\/]/);
  };

  if (operation.operation[xWmOptionalParams] && isOptionalParam()) {
    parameter.required = false;
    return parameter.default || "";
  } else {
    return parameter.default;
  }
}

function signServiceSpecificHeaders(data, req) {
  const config = data.client.config;
  const signHeaders = data.spec[xWmSignHeaders];
  const signHeadersList = data.client._signHeadersList;
  const pemKey = config.services.privateKey.pemKey;

  if (signHeaders && signHeadersList && pemKey) {
    WmlSoa.signWmHeaders(req.headers, signHeadersList, config.services.privateKey);
    return true;
  }

  return false;
}

function signEsbSpecificHeaders(data, req) {
  const type = data.client.providerInfo._type || data.client.providerInfo.type;
  if (type === _WM_SERVICE_TYPES.esb) {
    WmlSoa.signEsbHeaders(req.headers, data.client.config.services.privateKey);
    return true;
  }

  return false;
}

function constructUserAgent() {
  const oneOpsEnvKeys = [
    "ONEOPS_CLOUD_TENANT",
    "ONEOPS_ASSEMBLY",
    "ONEOPS_CLOUD",
    "ONEOPS_COMPUTE_CI_ID"
  ];
  const appPkg = JSON.parse(fs.readFileSync(path.resolve("./package.json")));
  const swapiPkg = JSON.parse(fs.readFileSync(path.join(__dirname, "../package.json")));
  const oneOpsAgent = !process.env.ONEOPS_CLOUD_TENANT
    ? ""
    : `-${oneOpsEnvKeys.map(x => process.env[x]).join("-")}`;

  const appInfo = swapiPkg.name !== appPkg.name ? `-${appPkg.name}-${appPkg.version}` : "";

  return `${swapiPkg.name}-${swapiPkg.version}${oneOpsAgent}${appInfo}`;
}

const USERAGENT_STRING = constructUserAgent();

function requestInterceptor(data, agentReq) {
  const wmHeaders = data.client.wmHeaders(data, agentReq);

  const optionalParams = data.spec[xWmOptionalParams];
  // Replace optional {/param} values in the URL with params of the same name
  // but without the leading '/'.
  if (optionalParams) {
    agentReq.url = agentReq.url.replace(/\{([+\/])([^}]+)}/g, (match, type, name) => {
      const value = data.params && data.params[name];
      if (type === "+") {
        return isUndefined(value) ? "" : `${value}`;
      } else {
        return isUndefined(value) ? "" : `/${encodeURIComponent(value)}`;
      }
    });
  }

  assign(agentReq.headers, wmHeaders);

  if (data.options && data.options._headers) {
    assign(agentReq.headers, data.options._headers);
  }

  if (!signEsbSpecificHeaders(data, agentReq)) {
    signServiceSpecificHeaders(data, agentReq);
  }

  agentReq.redirects = 0;

  //overwrite userAgent
  agentReq.headers["user-agent"] = USERAGENT_STRING;
  return agentReq;
}

function apiFuncInvoke(data) {
  const meta = data.meta;
  const client = data.client;
  const fn = data.fn;
  const params = data.params;
  const options = data.options;
  const operationId = data.operationId;

  const name = `${client.name}:${operationId}`;

  const promise =
    client._supportKeepAlive &&
    options.agent === undefined &&
    new Promise(resolve => {
      const keepAlive = KeepAlive.getKeepAlive(data.api.scheme);
      options.agent = () => keepAlive.agent;
      keepAlive.preLookup(data.api.host, () => resolve());
    });

  const start = Date.now();

  const report = status => {
    metrics.reportServiceCall({
      serviceName: client._serviceName || client.name,
      endpoint: operationId,
      status,
      duration: Date.now() - start
    });
  };

  const log = (a, b) => meta && meta.log && meta.log(a, b);

  const reportComplete = resp => {
    report(resp.status);
    if (client._verbose) {
      log(["swapi", "debug"], resp);
    }
  };

  const reportFail = (err, msg) => {
    report(err.status || 591); // eslint-disable-line
    if (client._verbose) {
      log(["swapi", "error"], {
        msg,
        err: { stack: _.get(err, "errObj.stack", err.stack) },
        obj: err.obj
      });
    }
  };

  const makeFailMsg = err => {
    const baseMsg = `failed operation ${name}`;
    let msg = err.message;
    if (!msg && err.errObj) {
      msg = err.errObj.message;
    }
    msg = msg ? `;${msg}` : "";
    let status = "";
    if (err.status !== undefined) {
      status = `;${err.status}`;
    }
    return `${baseMsg}${status}${msg}`;
  };

  let call;
  if (logTransaction) {
    call = () => {
      const context = client.beginCall(`begin operation ${name}`, meta);
      options.requestInterceptor = function() {
        data.context = context;
        return requestInterceptor(data, this);
      };
      return context
        .run(() => new Promise((resolve, reject) => fn(params, options, resolve, reject)))
        .then(resp => {
          context.end(`complete operation ${name}`);
          reportComplete(resp);
          return resp;
        })
        .catch(err => {
          const msg = makeFailMsg(err);
          context.fail(msg);
          reportFail(err, msg);
          throw err;
        });
    };
  } else {
    options.requestInterceptor = function() {
      return requestInterceptor(data, this);
    };
    call = () =>
      new Promise((resolve, reject) => {
        client.beginCall(`begin operation ${name}`, () => {
          const complete = resp => {
            client.end(`complete operation ${name}`);
            reportComplete(resp);
            resolve(resp);
          };

          const fail = err => {
            const msg = makeFailMsg(err);
            client.fail(msg);
            reportFail(err, msg);
            reject(err);
          };

          tryCatch(() => fn(params, options, complete, fail), fail);
        });
      });
  }

  return promise ? promise.then(call) : call();
}

function invokeWithMeta(data) {
  const meta = data.meta;
  const client = data.client;
  const tag = data.tag || "default";
  const operationId = data.operationId;
  const params = data.params;
  const options = data.options || {};

  const group = client.swagger.apis[tag];
  const fn = group[operationId];
  const api = group.apis[operationId];
  const spec = client.swagger.spec.paths[api.path][api.method];

  return apiFuncInvoke({ api, spec, meta, client, fn, params, options, operationId });
}

class ElectrodeSwapi {
  constructor(config, swagger, providerName) {
    // backward support
    // old: providerName, config, swagger
    if (isString(config)) {
      const tmpConfig = swagger;
      const tmpSwagger = providerName;
      providerName = config;
      config = tmpConfig;
      swagger = tmpSwagger;
    }

    this.swagger = swagger;
    this.name = providerName || this.constructor.providerName;
    this.config = config;

    this.setDefaults();

    this.validator = new Validator(this.swagger);
  }

  setDefaults() {
    this.providerInfo = cloneDeep(this.config.services.providers[this.name]);
    defaults(this.providerInfo, { wm_headers: true });
    defaultsDeep(this.config, { electrode: { hostIP: "127.0.0.1" } });

    const isVerbose = () => {
      const verbose = this.providerInfo.verbose;
      return isUndefined(verbose) ? this.config.services.verbose : verbose;
    };

    this._verbose = !!isVerbose();
    this._signHeadersList = this.constructor.signHeadersList;
    this._serviceName = this.constructor.serviceName;
    this._serviceVersion = this.constructor.serviceVersion;
    const txnLogs =
      this.providerInfo.transactionLogs !== undefined
        ? this.providerInfo.transactionLogs === true
        : true;
    this.setTransactionLogs(txnLogs && Boolean(logTransaction || transaction));

    this._supportKeepAlive = [
      this.providerInfo.supportKeepAlive,
      this.config.services.supportKeepAlive,
      SUPPORT_KEEP_ALIVE
    ].find(x => x !== undefined);
  }

  setTransactionLogs(flag) {
    if (!flag) {
      if (logTransaction) {
        this.beginCall = () => {
          return {
            run: func => func(),
            toHeader: () => "no-corr-id",
            end: _.noop,
            fail: _.noop
          };
        };
      } else {
        this.beginCall = (msg, func) => func();
      }
      this.end = _.noop;
      this.fail = _.noop;
    } else if (logTransaction) {
      this.beginCall = (msg, req) =>
        logTransaction.addCall(req, "@leaf electrode-swapi transaction", msg);
      this.end = _.noop;
      this.fail = _.noop;
    } else {
      this.beginCall = (msg, func) => transaction.beginCall(msg, func);
      this.end = msg => transaction.end(msg);
      this.fail = msg => transaction.fail(msg);
    }
    this.clearOperations();
  }

  //
  // In case any changes were made to instance, need to clear Operations
  // so it will be regenerated and get updated properties.
  //
  clearOperations() {
    this._Operations = undefined;
  }

  //
  // A bit of Javascript class/prototype/new hacking here.
  //
  // - For a client, Swapi dynamically generates a function for each API operation
  //   defined in the swagger spec.
  // - To support the withMeta method, which should "bind" the client to a request,
  //   we'd need to clone the instance, and then assign the request to it.  Clone
  //   would be very inefficient however.
  // - Calling new on a class is a lot more efficient.
  // - So what we are doing here is to create a new holder class, and then assign
  //   all the instance's properties into its prototype.  Then whenever we use new
  //   to create an instance of this holder class, we get a clone of the client
  //   instance efficiently, and we can assign request to it, which can be used
  //   to call all the dynamically generated API operations, but specific for that
  //   request only.
  //

  generateOperations() {
    if (this._Operations) {
      return;
    }

    this._signHeadersList = this._signHeadersList || this.signHeadersList; // backward support
    this._serviceName = this._serviceName || this.serviceName;
    this._serviceVersion = this._serviceVersion || this.serviceVersion;

    // the holder class
    const Operations = function(needMeta, meta) {
      this.needMeta = needMeta;
      this.meta = meta;
    };

    // assign instance properties into prototype
    assign(Operations.prototype, this);

    // update supported methods, but need to bind it back to the original instance
    Operations.prototype.wmHeaders = this.wmHeaders.bind(this);

    this._Operations = Operations;

    // wrapper for each operation

    //
    // Each operation could specify multiple tags.
    // Each tag goes in swagger.apis[<tag>] as a group of all operations belonging to it
    // Any operations that don't have tags go into the default group.
    // In each group, there's apis object that holds the details of the operations inside it
    //
    each(this.swagger.apis, group => {
      if (!isFunction(group) && isObject(group)) {
        each(group, (fn, operationId) => {
          if (operationId !== "help" && isFunction(fn) && !Operations.prototype[operationId]) {
            const api = group.apis[operationId];
            const spec = this.swagger.spec.paths[api.path][api.method];
            Operations.prototype[operationId] = function swapiOperationWrapper(params, options) {
              const meta = this.useMeta();
              return apiFuncInvoke({
                api,
                spec,
                meta,
                client: this,
                fn,
                params,
                options: options || {},
                operationId
              });
            };
            // add details from Swagger
            Operations.prototype[operationId].details = group.operations[operationId];
          }
        });
      }
    });

    Operations.prototype.useMeta = function useMeta() {
      if (this.needMeta && !this.meta) {
        throw new Error("swapi operation needs meta");
      }
      return this.meta;
    };

    Operations.prototype.invoke = function invoke(tag, operationId, params, options) {
      return invokeWithMeta({
        meta: this.useMeta(),
        client: this,
        tag,
        operationId,
        params,
        options
      });
    };
  }

  get operations() {
    this.generateOperations();

    if (!this._ops) {
      this._ops = new this._Operations();
    }

    return this._ops;
  }

  withMeta(meta) {
    this.generateOperations();

    return new this._Operations(true, meta);
  }

  invoke(tag, operationId, params, options) {
    return invokeWithMeta({
      client: this,
      tag,
      operationId,
      params,
      options
    });
  }

  invokeWithMeta(meta, tag, operationId, params, options) {
    return invokeWithMeta({
      meta,
      client: this,
      tag,
      operationId,
      params,
      options
    });
  }

  addApiKeyAuth(authName, key, value, type) {
    const auth = new Swagger.ApiKeyAuthorization(key, value, type);
    this.swagger.clientAuthorizations.add(authName, auth);
    return this;
  }

  addPasswordAuth(authName, username, password) {
    const auth = new Swagger.PasswordAuthorization(username, password);
    this.swagger.clientAuthorizations.add(authName, auth);
    return this;
  }

  validateModel(name, obj) {
    const valid = this.swagger.validateModel(name, obj);
    if (!valid.valid) {
      return Promise.reject(valid);
    } else {
      return Promise.resolve();
    }
  }

  /**
   *
   * Generates custom headers for passing to the API being called
   *
   * @param {Object} ref - an object with:
   *  - .meta
   *  - .params: parameters for invoking the API
   *  - .options: options for invoking the API
   *
   * @param {Object} req - the request object for the HTTP request being used to call the API
   *
   * @returns {Object} Custom headers
   */
  wmHeaders(ref /*, agentReq*/) {
    if (this.providerInfo.wm_headers === false) {
      return {};
    }

    if (!this[STATIC_HEADERS]) {
      const config = this.config;
      const services = config.services;
      const info = this.providerInfo;

      this[STATIC_HEADERS] = pickBy(
        {
          // required WM headers
          [_WM_HEADERS.consumerId]: services.consumerId,
          [_WM_HEADERS.svcEnv]: info.env || services.env || config.env,
          [_WM_HEADERS.svcVersion]: info.version || this._serviceVersion,
          [_WM_HEADERS.svcName]: info.name || this._serviceName,
          // optional WM headers
          [_WM_HEADERS.ifxClientType]: "INTERNAL",
          [_WM_HEADERS.consumerIp]: _.get(config, "electrode.hostIP"),
          [_WM_HEADERS.consumerTenantId]: services.tenantId
        },
        x => x !== undefined
      );
    }

    let corrId = "no-corr-id";

    if (ref.context) {
      corrId = ref.context.toHeader();
    } else {
      const context = transaction && transaction.getContext();
      if (context) {
        corrId = context.toHeader();
      } else if (ref.meta && ref.meta.correlationId) {
        corrId = ref.meta.correlationId;
      }
    }

    return assign(
      {
        [_WM_HEADERS.consumerInTimestamp]: Date.now(),
        [_WM_HEADERS.corrId]: corrId
      },
      this[STATIC_HEADERS]
    );
  }

  static getAgent(useAgent) {
    return SUPPORT_KEEP_ALIVE && useAgent !== false ? KeepAlive.getAgent : undefined;
  }

  static swaggerWithUrl(url, useAgent) {
    return new Promise((resolve, failure) => {
      const swagger = new Swagger({
        url,
        success: () => resolve(swagger),
        failure,
        parameterMacro,
        agent: ElectrodeSwapi.getAgent(useAgent)
      });
    });
  }

  static swaggerWithSpec(spec, override, useAgent) {
    spec = merge(spec, omit(override, ["timeout"]));

    return new Promise((resolve, failure) => {
      const swagger = new Swagger({
        spec,
        proxy: spec.proxy,
        timeout: override.timeout,
        success: () => resolve(swagger),
        failure,
        parameterMacro,
        agent: ElectrodeSwapi.getAgent(useAgent)
      });
    });
  }

  static swaggerWithFilename(specFile, override, useAgent) {
    const specParsers = {
      ".json": data => JSON.parse(data),
      ".yaml": data => yaml.safeLoad(data)
    };

    const ext = path.extname(specFile).toLowerCase();
    const parser = specParsers[ext];

    if (parser) {
      const create = spec => ElectrodeSwapi.swaggerWithSpec(spec, override, useAgent);
      return readFile(specFile)
        .then(parser)
        .then(create);
    } else {
      return Promise.reject(new Error(`Unknown spec file extension ${ext}`));
    }
  }

  static getOverride(config) {
    if (!config) {
      return {};
    }

    // backward compatible
    if (typeof config.timeout !== "object" || config.responseTimeout !== undefined) {
      assert(
        typeof config.timeout !== "object",
        "electrode-swapi: config can't have timeout object and responseTimeout at the same time"
      );
      config = merge({}, config, {
        timeout: {
          response: config.responseTimeout,
          deadline: config.timeout
        }
      });
    }

    const overrideKeys = ["schemes", "host", "basePath", "proxy", "timeout"];
    const override = pick(config, overrideKeys);

    return override;
  }

  static createSwagger(data) {
    // eslint-disable-line max-statements

    const config = data.config;
    const providerName = data.providerName;
    const specFilename = data.specFilename || data.fileName || data.Client.specFilename;
    const specOverride = ElectrodeSwapi.getOverride(data.specOverride);

    const provider = _.get(config, ["services", "providers", providerName]);

    assert(provider, `service provider config for "${providerName}" is missing`);

    //
    // _env & _type to be set by service initializer, but try for some defaults
    // in case service initializer was not used.
    //
    const env = (() => {
      return provider._env || provider.env || config.services.env || "qa";
    })();

    const types = (() => {
      const t = provider._type || provider.type;
      return t ? [t] : [_WM_SERVICE_TYPES.endpoint, _WM_SERVICE_TYPES.esb];
    })();

    // Take serviceRegistry from Client and override it with anything from
    // provider in config
    const clientReg = cloneDeep(data.Client.serviceRegistry);
    const registry = merge(clientReg || {}, provider.serviceRegistry);

    // apply defaults to the config for env (or missing)
    const regConfigs = defaultsDeep(registry[env] || registry.missing || {}, registry.default);

    const type = find(types, t => regConfigs[t]);
    if (type) {
      provider._type = type; // update _type
    }

    // backward compatible
    const override = merge(
      regConfigs[type],
      ElectrodeSwapi.getOverride(config.services),
      ElectrodeSwapi.getOverride(provider),
      specOverride // specOverride has highest priority
    );

    return ElectrodeSwapi.swaggerWithFilename(specFilename, override);
  }

  static create(data) {
    data.providerName = data.providerName || data.Client.providerName;
    return ElectrodeSwapi.createSwagger(data).then(
      swagger => new data.Client(data.config, swagger, data.providerName)
    );
  }

  static get WM_HEADERS() {
    return _WM_HEADERS;
  }

  static supportKeepAlive(flag) {
    SUPPORT_KEEP_ALIVE = flag;
  }

  static getClient(req) {
    const clientName = this.providerName;
    const client = get(req, `app.services.${clientName}`);

    if (!req) {
      throw new Error("Hapi request object is required");
    }

    if (!client) {
      throw new Error(`"${clientName}" swapi client not found`);
    }

    return client;
  }

  setTimeout(timeout) {
    this.swagger.options.timeout = timeout;
    this.clearOperations();
  }

  supportKeepAlive(flag) {
    this._supportKeepAlive = flag;
    this.clearOperations();
  }
}

ElectrodeSwapi.constructUserAgent = constructUserAgent;

module.exports = ElectrodeSwapi;
