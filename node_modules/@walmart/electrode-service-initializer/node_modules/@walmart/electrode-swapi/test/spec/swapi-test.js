"use strict";

/* eslint-disable camelcase */

const fs = require("fs");
const Path = require("path");
const Hapi = require("hapi");
const startMitm = require("mitm");
const _ = require("lodash");
const sinon = require("sinon");
const chai = require("chai");
const mockRequire = require("mock-require");
const OOSpec = require("../data/swagger.json");
const transaction = require("@walmart/electrode-logging").transaction;
const metrics = require("@walmart/electrode-metrics");
const swapiPkg = require("../../package.json");
const uaTestPkg = require("../ua-data/package.json");
const expect = chai.expect;
const keepAlive = require("../../lib/keep-alive");

describe("swapi", function() {
  let server;
  let socket;
  let mitm;
  let OOClient;
  let APIKeyClient;
  let ElectrodeSwapi;
  let logCalled; // eslint-disable-line

  this.timeout(10000);
  const prodHost = "oneops.prod.walmart.com";
  const verifyAlive = req => {
    chai.assert.equal(req.headers.connection, "keep-alive");
    if (!socket) {
      socket = Object.keys(req.connection._connections);
    } else {
      chai.assert.deepEqual(socket, Object.keys(req.connection._connections));
    }
  };

  before(done => {
    mockRequire("@walmart/electrode-log-transaction", undefined);
    delete require.cache[require.resolve("@walmart/electrode-log-transaction")];
    delete require.cache[require.resolve("../../lib/electrode-swapi.js")];
    delete require.cache[require.resolve("../lib/oo-swag-client.js")];
    delete require.cache[require.resolve("../lib/api-key-client.js")];
    ElectrodeSwapi = require("../../lib/electrode-swapi.js");
    ElectrodeSwapi.supportKeepAlive(false);
    OOClient = require("../lib/oo-swag-client.js");
    APIKeyClient = require("../lib/api-key-client.js");

    server = new Hapi.Server();
    server.connection({ port: 3000 });
    server.route([
      {
        method: "get",
        path: "/ok",
        handler: (req, reply) => {
          verifyAlive(req);
          reply(OOSpec);
        }
      },
      {
        method: "post",
        path: "/account/profile/authentication_token",
        handler: (req, reply) => {
          if (req.payload.user.password === "keepAlive") {
            verifyAlive(req);
          }
          if (req.payload.user.username === "vip") {
            reply({});
          } else {
            reply({ error: "Invalid login or password." })
              .header("Content-Type", "application/json; charset=utf-8")
              .header("Content-Length", 58)
              .code(401);
          }
        }
      }
    ]);

    server.start(done);
  });

  after(() => {
    mockRequire.stop("@walmart/electrode-log-transaction");
    server.stop(() => {});
  });

  const authInfo = {
    user: {
      username: "test",
      password: "testtest"
    }
  };

  const expectError = () => {
    chai.assert(false, "expect swagger to return error");
  };

  const emptyConfigLayout = {
    electrode: {
      hostIP: "127.0.0.1"
    },
    services: {
      privateKey: {},
      providers: {}
    }
  };

  const disableAgentOpts = {
    agent: false
  };

  function makeSafeConfig(config, providerName, verbose) {
    const safeConfig = _.merge(_.cloneDeep(emptyConfigLayout), config);
    const providerConfigPath = `services.providers.${providerName}`;
    if (!_.get(safeConfig, providerConfigPath)) {
      _.set(safeConfig, providerConfigPath, { verbose });
    }
    return safeConfig;
  }

  /* eslint-disable max-params */
  function cliCreate(Client, host, override, config, verbose) {
    return Client.create(
      makeSafeConfig(config, OOClient.providerName, verbose),
      override
    ).then(client => {
      chai.assert.ok(client);
      chai.assert.ok(client.swagger);
      chai.assert.equal(client.swagger.host, host);
      return client;
    });
  }

  function create(host, override, config, verbose) {
    return cliCreate(OOClient, host, override, config, verbose);
  }

  function verifyOperations(client) {
    const a = client.operations;
    chai.assert.ok(a, "client missing operations");
    chai.assert.equal(client.operations, a);
  }

  function hostConfig(host, providerName) {
    providerName = providerName || "oneOps";
    return {
      services: {
        providers: {
          [providerName]: {
            host
          }
        }
      }
    };
  }

  function hostRegistryConfig(host, env) {
    return {
      services: {
        env: "qa",
        providers: {
          oneOps: {
            env,
            type: "ENDPOINT",
            serviceRegistry: {
              qa: {
                ENDPOINT: {
                  host
                }
              },
              prod: {
                ENDPOINT: {
                  host: `prod-${host}`
                }
              }
            }
          }
        }
      }
    };
  }

  let sandbox;

  before(() => {
    sandbox = sinon.sandbox.create();
  });

  beforeEach(() => {
    logCalled = 0;
    sandbox.stub(transaction, "beginCall", (msg, functor) => {
      functor();
    });
    sandbox.stub(transaction, "end", () => {});
    sandbox.stub(transaction, "fail", () => {});
  });

  afterEach(() => {
    sandbox.restore();
    if (mitm) {
      mitm.disable();
      mitm = null;
    }
  });

  it("should use the same socket to retrieve spec from URL", function() {
    ElectrodeSwapi.supportKeepAlive(true);

    return new Promise((resolve, reject) => {
      keepAlive.getKeepAlive("http").preLookup("localhost", err => {
        if (err) return reject(err);
        return resolve();
      });
    })
      .then(() => ElectrodeSwapi.swaggerWithUrl("http://localhost:3000/ok"))
      .then(() => ElectrodeSwapi.swaggerWithUrl("localhost:3000/ok")) // test w/o protocol
      .then(swagger => {
        chai.assert.ok(swagger);
        chai.assert.equal(swagger.host, prodHost);
      })
      .finally(() => ElectrodeSwapi.supportKeepAlive(false));
  });

  it("should read swagger spec", function() {
    return create(prodHost);
  });

  it("should override swagger host", function() {
    const host = "localhost";
    return create(host, { host }, hostConfig("should.not.use.me"));
  });

  it("should override swagger host from provider in config", function() {
    const host = "test.localhost.com";
    return create(host, {}, hostConfig(host));
  });

  it("should take host and basePath from provider.serviceRegistry in config", () => {
    const host = "testx1234.localhost.com";
    return create(host, {}, hostRegistryConfig(host));
  });

  it("should take host from Client serviceRegistry", () => {
    const host = "api-key.client.host";
    return cliCreate(APIKeyClient, host, {}, hostConfig(undefined, "apiKey"));
  });

  it("should take env from provider", () => {
    const host = "testx1234.localhost.com";
    return create(`prod-${host}`, {}, hostRegistryConfig(host, "prod"));
  });

  it("operations should have API operations", function() {
    const verify = client => {
      verifyOperations(client);
      chai.assert.equal(client.operations.testSwag(), "testSwag", "testSwag missing in operations");
      chai.assert.isFunction(client.operations.getAccountProfile);
    };
    return create(prodHost).then(verify);
  });

  it("should expose a setTimeout method", function() {
    const verify = client => {
      expect(client.setTimeout).to.be.a("function");
      client.setTimeout(1000);
      expect(client.swagger.options.timeout).to.equal(1000);
    };

    return create(prodHost).then(verify);
  });

  it("withMeta should return operations with Meta", function() {
    const meta = {
      name: "test"
    };
    const verify = client => {
      const operations = client.withMeta(meta);
      chai.assert.ok(operations);
      chai.assert.ok(operations.meta);
      chai.assert(operations.needMeta);
      chai.assert.equal(operations.meta.name, meta.name);
      chai.assert.isFunction(operations.authenticationToken);
    };
    return create(prodHost).then(verify);
  });

  it("validateModel should pass valid model", function() {
    const verify = client => {
      return client.validateModel("AuthInfo", authInfo).catch(err => {
        throw err.errors;
      });
    };
    return create(prodHost).then(verify);
  });

  it("validateModel should fail invalid model", function() {
    const invalidModel = {
      xuser: {
        username: "name",
        password: "password"
      }
    };
    const verify = client => {
      return client
        .validateModel("AuthInfo", invalidModel)
        .then(expectError)
        .catch(err => {
          if (!err.errors) {
            throw err;
          }
          chai.assert.equal(err.errors, "Error: user is a required field");
        });
    };
    return create(prodHost).then(verify);
  });

  const testFail = verbose => {
    let debugLog = 0;

    const meta = {
      name: "test",
      log: tags => {
        if (_.includes(tags, "error") && !_.includes(tags, "end_txn")) {
          debugLog++;
        }
        logCalled++;
      }
    };
    const verify = client => {
      const operations = client.withMeta(meta);
      chai.assert.isFunction(operations.authenticationToken);

      return operations
        .authenticationToken({})
        .then(expectError)
        .catch(err => {
          if (err !== "missing required params: authInfo") {
            throw err;
          }
          if (verbose) {
            chai.assert(debugLog > 0, "debug log not received");
          }
        });
    };
    return create(prodHost, undefined, undefined, verbose).then(verify);
  };

  it("operation should fail without required param", function() {
    return testFail(true).then(() => testFail());
  });

  it("operations should handle error from invoke service", function() {
    mitm = startMitm();
    const meta = {
      name: "test",
      log: () => {
        logCalled++;
      }
    };

    mitm.on("request", (req, res) => {
      res.writeHead(401, {
        "Content-Type": "application/json; charset=utf-8",
        "Content-Length": 58
      });
      res.end(JSON.stringify({ error: "Invalid login or password." }));
    });

    const params = { authInfo };

    const verifyResponse = promise => {
      return promise.then(expectError).catch(err => {
        if (!err.obj || err.obj.error !== "Invalid login or password.") {
          throw err;
        }
      });
    };

    const verify = client => {
      // even enable, should not use keep alive agent due to disableAgentOpts being passed below
      client.supportKeepAlive(true);
      const operations = client.withMeta(meta);
      chai.assert.isFunction(operations.authenticationToken);

      const operationId = "authenticationToken";
      return verifyResponse(operations.authenticationToken(params, disableAgentOpts))
        .then(() =>
          verifyResponse(client.invokeWithMeta(meta, "", operationId, params, disableAgentOpts))
        )
        .then(() => verifyResponse(client.invoke("default", operationId, params, disableAgentOpts)))
        .then(() => verifyResponse(operations.invoke("", operationId, params, disableAgentOpts)));
    };

    return create(prodHost).then(verify);
  });

  it("operations should use extend params", function() {
    mitm = startMitm();
    const meta = {
      name: "test",
      log: () => {
        logCalled++;
      }
    };

    mitm.on("request", (req, res) => {
      res.writeHead(401, {
        "Content-Type": "application/json; charset=utf-8",
        "Content-Length": 58
      });
      res.end(JSON.stringify({ error: "Invalid login or password." }));
    });

    const params = { authInfo, $ext: { "%<Foo>": "foo/" } };

    const verifyResponse = promise => {
      return promise.then(expectError).catch(err => {
        if (!err.obj || err.obj.error !== "Invalid login or password.") {
          throw err;
        }
      });
    };

    const verify = client => {
      const operations = client.withMeta(meta);
      chai.assert.isFunction(operations.authenticationToken);

      const operationId = "authenticationToken";
      return verifyResponse(operations.authenticationToken(params, disableAgentOpts))
        .then(() =>
          verifyResponse(client.invokeWithMeta(meta, "", operationId, params, disableAgentOpts))
        )
        .then(() => verifyResponse(client.invoke("default", operationId, params, disableAgentOpts)))
        .then(() => verifyResponse(operations.invoke("", operationId, params, disableAgentOpts)));
    };

    return create(prodHost).then(verify);
  });

  it("operations should invoke service", function() {
    mitm = startMitm();

    const meta = {
      name: "test",
      log: function() {
        chai.assert.ok(this);
        logCalled++;
      },
      options: {
        agent: false
      }
    };

    const authToken = "test1234567890-abcde";
    mitm.on("request", (req, res) => {
      res.writeHead(200, {
        "Content-Type": "application/json; charset=utf-8",
        "Content-Length": 52
      });
      res.end(JSON.stringify({ token: authToken }));
    });

    const params = { authInfo };

    const verifyResponse = promise => {
      return promise.then(resp => {
        chai.assert.equal(resp.obj.token, authToken);
      });
    };

    const verify = client => {
      const operations = client.withMeta(meta);
      chai.assert.isFunction(operations.authenticationToken);

      const operationId = "authenticationToken";
      return verifyResponse(
        operations.authenticationToken(params, {
          testHeader: "blah",
          agent: false
        })
      )
        .then(() =>
          verifyResponse(
            client.invokeWithMeta(meta, "default", operationId, params, disableAgentOpts)
          )
        )
        .then(() => verifyResponse(client.invoke("default", operationId, params)))
        .then(() =>
          verifyResponse(operations.invoke("default", operationId, params, disableAgentOpts))
        );
    };

    return create(prodHost).then(verify);
  });

  it("operation should report service call metrics on completion", () => {
    sandbox.spy(metrics, "reportServiceCall");

    mitm = startMitm();
    mitm.on("request", (req, res) => {
      const data = JSON.stringify({ id: 1234, email: "test@test.com", authOK: true });
      res.writeHead(200, {
        "Content-Type": "application/json; charset=utf-8",
        "Content-Length": data.length
      });
      res.end(data);
    });

    return create(prodHost)
      .then(client => {
        expect(client._serviceName)
          .to.equal(OOClient.serviceName)
          .which.equals("one-ops-service");
        return client
          .withMeta({
            log: () => {}
          })
          .authenticationToken({ authInfo }, disableAgentOpts);
      })
      .then(res => {
        chai.expect(metrics.reportServiceCall).to.have.been.calledOnce;
        const info = metrics.reportServiceCall.firstCall.args[0];
        expect(info).to.have.property("serviceName", "one-ops-service");
        expect(info).to.have.property("endpoint", "authenticationToken");
        expect(info).to.have.property("status", res.status);
        expect(info)
          .to.have.property("duration")
          .that.is.a("number");
      });
  });

  it("should fail if spec file is not yaml/json", function() {
    return ElectrodeSwapi.swaggerWithFilename("test.blah")
      .then(expectError)
      .catch(err => {
        if (
          !(
            typeof err.message === "string" &&
            err.message.indexOf("Unknown spec file extension") >= 0
          )
        ) {
          throw err;
        }
      });
  });

  it("operations with meta should fail if meta missing", function() {
    const callApi = client => {
      return client.withMeta().authenticationToken(null, disableAgentOpts);
    };
    return create(prodHost)
      .then(callApi)
      .then(expectError)
      .catch(err => {
        if (err.message !== "swapi operation needs meta") {
          throw err;
        }
      });
  });

  it("should use keep alive to call API", function() {
    ElectrodeSwapi.supportKeepAlive(true);
    const okAuthInfo = {
      user: {
        username: "vip",
        password: "keepAlive"
      }
    };

    const callApi = client => {
      client.supportKeepAlive(true);
      return client.withMeta({}).authenticationToken({ authInfo: okAuthInfo }, {});
    };
    return create("localhost:3000", { host: "localhost:3000", schemes: ["http"] }).then(callApi);
  });

  it("operations should send authorization when set", function() {
    mitm = startMitm();
    mitm.on("request", (req, res) => {
      const authOK = req.headers.authorization === "Basic dG9rZW46cGFzcw==";
      const data = JSON.stringify({
        id: 1234,
        email: "test@test.com",
        authOK: authOK
      });
      res.writeHead(200, {
        "Content-Type": "application/json; charset=utf-8",
        "Content-Length": data.length
      });
      res.end(data);
    });

    const callApi = client => {
      const meta = {
        name: "test"
        // test missing log
      };
      return client
        .addPasswordAuth("authToken", "token", "pass")
        .withMeta(meta)
        .invoke("Account", "getAccountProfile", null, disableAgentOpts)
        .then(resp => {
          chai.assert(resp.obj.authOK, "authorization header not sent");
        });
    };
    return create(prodHost).then(callApi);
  });

  const testResponseTimeout = config => {
    mitm = startMitm();
    mitm.on("request", (req, res) => {
      res.statusCode = 200;
      setTimeout(() => {
        res.end("beep");
      }, 500);
    });

    let testErr;
    return OOClient.create(makeSafeConfig(config, OOClient.providerName))
      .then(client => client.withMeta({}).getAccountProfile())
      .catch(err => (testErr = err))
      .then(() => {
        expect(testErr).to.have.deep.property("errObj.code", "ECONNABORTED");
        expect(testErr).to.have.deep.property("errObj.errno", "ETIMEDOUT");
        expect(testErr).to.have.deep.property(
          "errObj.message",
          "Response timeout of 200ms exceeded"
        );
      });
  };

  it("should not mutate user passed in options", () => {
    const xconfig = makeSafeConfig({}, OOClient.providerName);
    const saved = _.cloneDeep(xconfig);
    return OOClient.create(xconfig).then(() => {
      expect(xconfig).to.deep.equal(saved);
    });
  });

  it("operation should time out when TTFB exceeds responseTimeout option", () => {
    return testResponseTimeout({ services: { responseTimeout: 200, timeout: 600 } });
  });

  it("operation should time out when TTFB exceeds timeout.response option", () => {
    return testResponseTimeout({ services: { timeout: { response: 200, deadline: 600 } } });
  });

  const testDeadlineTimeout = config => {
    mitm = startMitm();
    mitm.on("request", (req, res) => {
      res.statusCode = 200;
      res.write("First part");
      setTimeout(() => {
        res.end("Second part");
      }, 1000);
    });

    let testErr;
    return OOClient.create(makeSafeConfig(config, OOClient.providerName))
      .then(client => client.withMeta({}).getAccountProfile())
      .catch(err => (testErr = err))
      .then(() => {
        expect(testErr).to.have.deep.property("errObj.code", "ECONNABORTED");
        expect(testErr).to.have.deep.property("errObj.errno", "ETIME");
        expect(testErr).to.have.deep.property("errObj.message", "Timeout of 600ms exceeded");
      });
  };

  it("operation should time out when total time exceeds timeout option", () => {
    return testDeadlineTimeout({ services: { responseTimeout: 200, timeout: 600 } });
  });

  it("operation should time out when total time exceeds timeout.deadline option", () => {
    return testDeadlineTimeout({ services: { timeout: { response: 200, deadline: 600 } } });
  });

  it("should err with ENOTFOUND if host doesn't resolve", () => {
    return OOClient.create(makeSafeConfig({}, OOClient.providerName), {
      host: "oneops.prod.bad-url.walmart.com"
    })
      .then(client => client.withMeta({}).getAccountProfile())
      .then(() => {
        throw new Error("Expected err");
      })
      .catch(res => {
        expect(res).to.have.deep.property("errObj.code", "ENOTFOUND");
        expect(res).to.have.deep.property("errObj.errno", "ENOTFOUND");
      });
  });

  it("should return 302 for unauthorized API access", function() {
    const callApi = client => {
      const meta = {
        name: "test"
      };
      const options = { _headers: { Accept: "*/*" } };
      return client
        .addPasswordAuth("authToken", "token", "pass")
        .withMeta(meta)
        .invoke("Account", "getAccountProfile", {}, options);
    };
    let caught;
    return create(prodHost)
      .then(callApi)
      .catch(err => {
        caught = err;
        chai.assert.equal(err.status, 302);
      })
      .then(() => {
        if (!caught) {
          throw new Error("expected 302 from calling API with unauthorized access");
        }
      });
  });

  it("should send api key auth & optional headers", function() {
    mitm = startMitm();
    mitm.on("request", (req, res) => {
      const authOK = req.headers.testapikey === "TestApiAuth";
      const optionalHeader = req.headers["optional-header"];
      const data = JSON.stringify({
        id: 1234,
        email: "test@test.com",
        authOK: authOK,
        optionalHeader
      });
      res.writeHead(200, {
        "Content-Type": "application/json; charset=utf-8",
        "Content-Length": data.length
      });
      res.end(data);
    });

    const callApi = client => {
      let debugLog = 0;
      const meta = {
        name: "test",
        log: tags => {
          if (_.includes(tags, "debug")) {
            debugLog++;
          }
          logCalled++;
        }
      };

      const optionalValue = "Test-Optional-Header";

      verifyOperations(client);
      return client
        .addApiKeyAuth("api_key", "TestApiKey", "TestApiAuth", "header")
        .withMeta(meta)
        .get(
          {},
          {
            _headers: {
              "optional-header": optionalValue
            },
            agent: false
          }
        )
        .then(resp => {
          chai.assert(debugLog > 0, "debug log not received");
          chai.assert(resp.obj.authOK, "api key authorization header not sent");
          chai.assert.equal(resp.obj.optionalHeader, optionalValue);
        });
    };

    return APIKeyClient.create(makeSafeConfig({}, APIKeyClient.providerName, true)).then(callApi);
  });

  it("should send optional path parameters", function() {
    mitm = startMitm();
    mitm.on("request", (req, res) => {
      const urlOK = req.url === "/one/_foo_/_bar%2Fbaz_/five";
      const data = JSON.stringify({ urlOK });
      res.writeHead(200, {
        "Content-Type": "application/json; charset=utf-8",
        "Content-Length": data.length
      });
      res.end(data);
    });
    const callApi = client => {
      const meta = {};
      return client
        .withMeta(meta)
        .testOptionalPath(
          {
            two: "_foo_",
            three: "_bar/baz_"
            // intentionally exclude `four`, it's optional
          },
          disableAgentOpts
        )
        .then(resp => {
          chai.assert(resp.obj.urlOK, "url was not sent correctly");
        });
    };
    return APIKeyClient.create(makeSafeConfig({}, APIKeyClient.providerName)).then(callApi);
  });

  it("should send reserved expansion parameters", function() {
    mitm = startMitm();
    mitm.on("request", (req, res) => {
      const urlOK = req.url === "/ccm/_foo_/_bar_/baz/FOO/config";
      const data = JSON.stringify({ urlOK });
      res.writeHead(200, {
        "Content-Type": "application/json; charset=utf-8",
        "Content-Length": data.length
      });
      res.end(data);
    });
    const callApi = client => {
      const meta = {};
      return client
        .withMeta(meta)
        .testReservedExpansion(
          {
            scope: "/_foo_/_bar_/baz",
            testx: undefined,
            foo: "FOO",
            bar: undefined
          },
          disableAgentOpts
        )
        .then(resp => {
          chai.assert(resp.obj.urlOK, "url was not sent correctly");
        });
    };
    return APIKeyClient.create(makeSafeConfig({}, APIKeyClient.providerName)).then(callApi);
  });

  function testWMHeaders(options) {
    const wmHeaders = options.wmHeaders;
    const type = options.type;
    const verbose = options.verbose;
    const transactionLogs = options.transactionLogs;

    mitm = startMitm();
    mitm.on("request", (req, res) => {
      const headers = req.headers;
      const wmCorrId = headers["wm_qos.correlation_id"];
      const hasWmHeaders = headers["wm_consumer.id"] === "test-wm-headers" && !_.isEmpty(wmCorrId);
      const signedHeader = headers["wm_sec.auth_signature"] !== undefined;
      const data = JSON.stringify({
        id: 1234,
        email: "test@test.com",
        hasWmHeaders,
        wmCorrId,
        signedHeader,
        signedHeadersList: headers.signedheaders
      });
      res.writeHead(200, {
        "Content-Type": "application/json; charset=utf-8",
        "Content-Length": data.length
      });
      res.end(data);
    });
    const callApi = client => {
      let debugLog = 0;
      const meta = {
        name: "test",
        log: tags => {
          if (_.includes(tags, "debug")) {
            debugLog++;
          }
          logCalled++;
        }
      };
      const result = {};
      const ops = client
        .addApiKeyAuth("api_key", "TestApiKey", "TestApiAuth", "header")
        .withMeta(meta);
      return ops
        .get(null, disableAgentOpts)
        .then(resp => {
          result.getResp = resp;
          const expected = wmHeaders || wmHeaders === undefined;
          if (verbose) {
            chai.assert(debugLog > 0, "debug log not received");
          }
          chai.assert.equal(resp.obj.hasWmHeaders, expected, "Has WM headers not matched");
          if (type === "ESB_PROXY") {
            chai.assert(resp.obj.signedHeader, "headers not signed");
          } else {
            chai.assert(!resp.obj.signedHeader, "headers should not be signed");
          }
        })
        .then(() => {
          return ops.authAdmin(null, disableAgentOpts).then(resp => {
            result.authAdminResp = resp;
            chai.assert(resp.obj.signedHeader, "headers not signed");
            const expectedSigned =
              type !== "ESB_PROXY"
                ? "WM_CONSUMER.ID;WM_CONSUMER.IP;"
                : "WM_CONSUMER.ID;WM_CONSUMER.INTIMESTAMP;WM_SEC.KEY_VERSION;";
            chai.assert.equal(resp.obj.signedHeadersList, expectedSigned);
          });
        })
        .then(() => result);
    };
    const config = {
      services: {
        verbose,
        consumerId: "test-wm-headers",
        privateKey: {
          pemKey: fs.readFileSync("test/data/private-key.pem").toString("ascii"),
          version: 1
        },
        providers: {
          [APIKeyClient.providerName]: _.pickBy(
            {
              wm_headers: wmHeaders,
              type,
              transactionLogs
            },
            x => x !== undefined
          )
        }
      }
    };
    return APIKeyClient.create(makeSafeConfig(config, OOClient.providerName))
      .then(callApi)
      .tap(() => {
        if (transactionLogs === false) {
          chai.assert.equal(transaction.beginCall.called, false, "beginCall should not be called");
        }
      });
  }

  it("should send and sign WM headers if @type=ENDPOINT, wm_headers===true", function() {
    return testWMHeaders({ wmHeaders: true, type: "ENDPOINT", verbose: true });
  });

  it("should send and sign WM headers if @type=ESB_PROXY, wm_headers===true", function() {
    return testWMHeaders({ wmHeaders: true, type: "ESB_PROXY", verbose: undefined });
  });

  it("should send and sign WM headers if @type=ENDPOINT, wm_headers===undefined", function() {
    return testWMHeaders({ wmHeaders: undefined, type: "ENDPOINT", verbose: undefined });
  });

  it("should not send WM headers if @type=ENDPOINT, wm_headers===false", function() {
    return testWMHeaders({ wmHeaders: false, type: "ENDPOINT", verbose: undefined });
  });

  it("should not log transactions if transactionLogs is false", function() {
    return testWMHeaders({
      wmHeaders: false,
      type: "ENDPOINT",
      verbose: undefined,
      transactionLogs: false
    });
  });

  it("should use toHeader from transaction context for corr-id", function() {
    const corrId = "test-test-test-123";
    sandbox.stub(transaction, "getContext", () => {
      return { toHeader: () => corrId };
    });

    return testWMHeaders({
      wmHeaders: true,
      type: "ENDPOINT",
      verbose: undefined,
      transactionLogs: true
    }).then(res => {
      expect(res.getResp.obj.wmCorrId).to.equal(corrId);
    });
  });

  it("should read spec from json file when proxy is present as null in the override ", function() {
    const dummyOverride = {
      proxy: null
    };
    return ElectrodeSwapi.swaggerWithFilename(
      `${__dirname}/../data/swagger.json`,
      dummyOverride,
      false
    ).then(swagger => {
      chai.assert.ok(swagger);
      chai.assert.equal(swagger.host, prodHost);
    });
  });

  it("should read spec from json proxy is present is NOT null or undefined in the override file", function() {
    const dummyOverride = {
      proxy: "http://127.0.0.1:8442"
    };
    return ElectrodeSwapi.swaggerWithFilename(
      `${__dirname}/../data/swagger.json`,
      dummyOverride,
      false
    ).then(swagger => {
      chai.assert.ok(swagger);
      chai.assert.equal(swagger.host, prodHost);
    });
  });

  it("should read spec from json file when proxy is present as undefined in the override ", function() {
    const dummyOverride = {
      proxy: undefined
    };
    return ElectrodeSwapi.swaggerWithFilename(
      `${__dirname}/../data/swagger.json`,
      dummyOverride,
      false
    ).then(swagger => {
      chai.assert.ok(swagger);
      chai.assert.equal(swagger.host, prodHost);
    });
  });

  it("should handle old timeout config", () => {
    const x = ElectrodeSwapi.getOverride({
      timeout: 500
    });
    expect(x.timeout.deadline).to.equal(500);
  });

  it("should handle old responseTimeout config", () => {
    const x = ElectrodeSwapi.getOverride({
      responseTimeout: 500
    });
    expect(x.timeout.response).to.equal(500);
  });

  it("should fail if old and new timeout config exist", () => {
    expect(() =>
      ElectrodeSwapi.getOverride({
        responseTimeout: 500,
        timeout: {
          response: 100
        }
      })
    ).to.throw(Error);
  });

  it("should retrieve spec from URL", function() {
    mitm = startMitm();
    mitm.on("request", (req, res) => {
      res.statusCode = 200;
      res.end(JSON.stringify(OOSpec));
    });

    return ElectrodeSwapi.swaggerWithUrl("http://www.test.com", false).then(swagger => {
      chai.assert.ok(swagger);
      chai.assert.equal(swagger.host, prodHost);
    });
  });

  describe("getClient", function() {
    it("fetches class instance set in req object", () => {
      const providerName = OOClient.providerName;
      const client = {};
      const req = _.set({}, `app.services.${providerName}`, client);
      const fetchedClient = OOClient.getClient(req);
      expect(fetchedClient).to.equal(client);
    });

    it("throws if class instance not found", () => {
      const client = {};
      const shouldThrow = () => OOClient.getClient(client);
      expect(shouldThrow).to.throw(Error, `"oneOps" swapi client not found`);
    });

    it("throws if not passed a req object", () => {
      const shouldThrow = () => OOClient.getClient();
      expect(shouldThrow).to.throw(Error, "Hapi request object is required");
    });
  });

  describe("constructUserAgent", function() {
    const oneOpsKeys = [
      "ONEOPS_CLOUD_TENANT",
      "ONEOPS_ASSEMBLY",
      "ONEOPS_CLOUD",
      "ONEOPS_COMPUTE_CI_ID"
    ];
    const lowerCaseOOKeys = oneOpsKeys.map(x => x.toLowerCase());
    const setProcessEnv = function() {
      oneOpsKeys.forEach(x => {
        process.env[x] = x.toLowerCase();
      });
    };

    const clearOneOpsEnv = () => {
      oneOpsKeys.forEach(x => delete process.env[x]);
    };

    it("should create string with only swapi info", function() {
      const ua = ElectrodeSwapi.constructUserAgent();
      expect(ua).includes(`${swapiPkg.name}-${swapiPkg.version}`);
    });

    it("should create string with OneOpsEnv info", function() {
      setProcessEnv();
      const ua = ElectrodeSwapi.constructUserAgent();
      expect(ua).to.equal(`${swapiPkg.name}-${swapiPkg.version}-${lowerCaseOOKeys.join("-")}`);
      clearOneOpsEnv();
    });

    it("should create string with app info", function() {
      const saveCwd = process.cwd();
      process.chdir(Path.resolve("test/ua-data"));
      const ua = ElectrodeSwapi.constructUserAgent();
      expect(ua).to.equal(
        `${swapiPkg.name}-${swapiPkg.version}-${uaTestPkg.name}-${uaTestPkg.version}`
      );
      process.chdir(saveCwd);
    });

    it("should create string with app and OneOpsEnv info", function() {
      setProcessEnv();
      const saveCwd = process.cwd();
      process.chdir(Path.resolve("test/ua-data"));
      const ua = ElectrodeSwapi.constructUserAgent();
      expect(ua).to.equal(
        `${swapiPkg.name}-${swapiPkg.version}-${lowerCaseOOKeys.join(
          "-"
        )}-${uaTestPkg.name}-${uaTestPkg.version}`
      );
      clearOneOpsEnv();
      process.chdir(saveCwd);
    });

    it("verify headers during service requests", function() {
      mitm = startMitm();

      const meta = {
        name: "test",
        log: function() {
          chai.assert.ok(this);
          logCalled++;
        },
        options: {
          agent: false
        }
      };

      const authToken = "test1234567890-abcde";

      const verifyRequestHeaders = function(req) {
        chai.assert.match(
          req.headers["user-agent"],
          /@walmart\/electrode-swapi-[0-9.]*/,
          "correct User Agent"
        );
      };

      mitm.on("request", (req, res) => {
        verifyRequestHeaders(req);
        res.writeHead(200, {
          "Content-Type": "application/json; charset=utf-8",
          "Content-Length": 52
        });
        res.end(JSON.stringify({ token: authToken }));
      });

      const params = { authInfo };

      const verifyResponse = promise => {
        return promise.then(resp => {
          chai.assert.equal(resp.obj.token, authToken);
        });
      };

      const verify = client => {
        const operations = client.withMeta(meta);
        chai.assert.isFunction(operations.authenticationToken);
        return verifyResponse(
          operations.authenticationToken(params, {
            testHeader: "blah",
            agent: false
          })
        ).then(() => {
          setProcessEnv();
          verifyResponse(
            operations.authenticationToken(params, {
              testHeader: "blah",
              agent: false
            })
          );
        });
      };

      return create(prodHost).then(verify);
    });
  });
});
