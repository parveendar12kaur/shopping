"use strict";

/* eslint-disable camelcase */

const Hapi = require("hapi");
const _ = require("lodash");
const chai = require("chai");
const mockRequire = require("mock-require");
const OOSpec = require("../data/swagger.json");
const fyi = require("@walmart/electrode-fyi");
const expect = chai.expect;
const WmlSoa = require("@walmart/electrode-wml-soa");
const _WM_HEADERS = WmlSoa.wmHeaders;

describe("no transaction module", function() {
  this.timeout(10000);
  let server;
  let logs;
  let fyiLogs;
  let request;
  let OOClient;
  let ElectrodeSwapi;
  let metrics;
  this.timeout(10000);

  beforeEach(() => {
    fyiLogs = [];
    fyi._setLogger({
      warn: function() {
        fyiLogs.push(Array.prototype.slice.apply(arguments).join(" "));
      }
    });

    delete require.cache[require.resolve("../..")];
    delete require.cache[require.resolve("@walmart/electrode-logging")];
    delete require.cache[require.resolve("@walmart/electrode-log-transaction")];
    delete require.cache[require.resolve("../../lib/electrode-swapi.js")];
    delete require.cache[require.resolve("../lib/oo-swag-client.js")];
    delete require.cache[require.resolve("../lib/api-key-client.js")];

    mockRequire("@walmart/electrode-logging", {});
    mockRequire("@walmart/electrode-log-transaction", undefined);

    ElectrodeSwapi = require("../../lib/electrode-swapi.js");
    ElectrodeSwapi.supportKeepAlive(false);
    OOClient = require("../lib/oo-swag-client.js");

    mockRequire.stopAll();

    request = {
      log: function() {
        logs.push(Array.prototype.slice.apply(arguments));
      }
    };

    logs = [];
    metrics = [];

    process.send = function() {
      metrics.push(Array.prototype.slice.apply(arguments));
    };
  });

  afterEach(() => {
    fyi._setLogger();
  });

  before(done => {
    server = new Hapi.Server();
    server.connection({ port: 3000 });

    server.route([
      {
        method: "get",
        path: "/ok",
        handler: (req, reply) => {
          reply(OOSpec);
        }
      },
      {
        method: "post",
        path: "/account/profile/authentication_token",
        handler: (req, reply) => {
          if (req.payload.user.username === "vip") {
            reply({ corrId: req.headers[_WM_HEADERS.corrId.toLowerCase()], blah: "hello" });
          } else {
            reply({ error: "Invalid login or password." })
              .header("Content-Type", "application/json; charset=utf-8")
              .header("Content-Length", 58)
              .code(401);
          }
        }
      }
    ]);

    server.start(err => done(err));
  });

  after(() => {
    delete process.send;
    server.stop(() => {});
  });

  const emptyConfigLayout = {
    electrode: {
      hostIP: "127.0.0.1"
    },
    services: {
      privateKey: {},
      providers: {}
    }
  };

  function makeSafeConfig(config, providerName) {
    const safeConfig = _.merge(_.cloneDeep(emptyConfigLayout), {
      services: {
        providers: {
          [providerName]: config || {}
        }
      }
    });
    return safeConfig;
  }

  /* eslint-disable max-params */
  function cliCreate(Client, host, override, config) {
    return Client.create(makeSafeConfig(config, OOClient.providerName), override).then(client => {
      chai.assert.ok(client);
      chai.assert.ok(client.swagger);
      chai.assert.equal(client.swagger.host, host);
      return client;
    });
  }

  function create(host, override, config) {
    return cliCreate(OOClient, host, override, config);
  }
  const okAuthInfo = {
    user: {
      username: "vip",
      password: "keepAlive"
    }
  };

  const failAuthInfo = {
    user: {
      username: "test",
      password: "test"
    }
  };

  it("should warn transaction id disabled", () => {
    expect(fyiLogs[0]).includes(
      `electrode-swapi: transaction logs disabled because no support module found`
    );
  });

  it("should not log any transaction for service calls", () => {
    const callApi = (client, info) => {
      client.supportKeepAlive(false);
      return client.withMeta(request).authenticationToken({ authInfo: info }, {});
    };
    let error;
    return create(
      "localhost:3000",
      {
        host: "localhost:3000",
        schemes: ["http"]
      },
      { transactionLogs: true } // try to force transaction true
    )
      .tap(client => callApi(client, okAuthInfo))
      .tap(client => callApi(client, failAuthInfo))
      .catch(err => (error = err))
      .then(() => {
        expect(error).to.be.an.Error;
        expect(error.errObj.message).to.equal("Unauthorized");
        expect(metrics[0][0].data.status).to.equal(200);
        expect(metrics[1][0].data.status).to.equal(401);
        expect(logs).to.deep.equal([]);
      });
  });

  it("should use request.correlationId for _WM_HEADERS.corrId", () => {
    request.correlationId = "test-123";
    const callApi = (client, info) => {
      client.supportKeepAlive(false);
      return client.withMeta(request).authenticationToken({ authInfo: info }, {});
    };
    let error;
    let client;
    return create(
      "localhost:3000",
      {
        host: "localhost:3000",
        schemes: ["http"]
      },
      { transactionLogs: true } // try to force transaction true
    )
      .then(x => (client = x))
      .then(() => callApi(client, okAuthInfo))
      .then(resp => {
        expect(resp.obj.corrId).to.equal("test-123");
      })
      .then(() => callApi(client, failAuthInfo))
      .catch(err => (error = err))
      .then(() => {
        expect(error).to.be.an.Error;
        expect(error.errObj.message).to.equal("Unauthorized");
        expect(metrics[0][0].data.status).to.equal(200);
        expect(metrics[1][0].data.status).to.equal(401);
        expect(logs).to.deep.equal([]);
      });
  });
});
