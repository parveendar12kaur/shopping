"use strict";

const TestClient = require("./test-client");
const electrodeServer = require("electrode-server");
const fetch = require("node-fetch");
const keepAlive = require("../../lib/keep-alive");

const supportKeepAlive = process.argv[3] === "keepAlive";

const MOCK_SERVER_HOST = "10.2.3.4";

Promise.all([
  electrodeServer({
    connections: {
      default: {
        port: 3000
      }
    }
  }),
  TestClient.create(
    {
      services: {
        timeout: { response: 5000, deadline: 5000 },
        supportKeepAlive,
        privateKey: {},
        providers: {
          test: {
            transactionLogs: false
          }
        }
      }
    },
    {
      host: MOCK_SERVER_HOST
    }
  )
]).then(res => {
  const server = res[0];
  const client = res[1];
  /* eslint-disable max-params */
  const handle = (request, reply, useFetch, verbose) => {
    if (verbose) {
      console.log(
        "x1 request",
        Date.now(),
        "useFetch",
        useFetch,
        "supportKeepAlive",
        supportKeepAlive
      );
    }

    const callWithFetch = () => {
      const startTime = Date.now();
      return fetch("http://localhost:7999/test1", {
        method: "POST",
        body: JSON.stringify({ x1: "hello test" })
      })
        .then(resp => {
          return resp.json();
        })
        .then(obj => {
          const time = Date.now() - startTime;
          const extra = time - obj.delay;
          return { time, extra, obj };
        });
    };

    const callWithSwapi = () => {
      const binded = client.withMeta(request);
      const startTime = Date.now();
      return binded
        .test1({
          foo: { x1: "hello test" }
        })
        .then(resp => {
          const obj = resp.obj;
          const time = Date.now() - startTime;
          const extra = time - obj.delay;
          return { time, extra, obj };
        })
        .catch(err => {
          console.log(err);
        });
    };

    let promise;
    let lib;

    if (useFetch) {
      promise = Promise.all([callWithFetch(), callWithFetch(), callWithFetch()]);
      lib = "fetch";
    } else {
      promise = Promise.all([callWithSwapi(), callWithSwapi(), callWithSwapi()]);
      lib = "swapi";
    }

    const memoryUsage = process.memoryUsage();

    for (const k in memoryUsage) {
      const x = memoryUsage[k] / (1024 * 1024);
      memoryUsage[k] = `${x.toFixed(2)}mb`;
    }

    promise
      .then(result => {
        reply({
          lib,
          supportKeepAlive,
          memoryUsage,
          data: result
        });
      })
      .catch(err => {
        console.log("error", err);
        reply({ failed: err.message });
      });
  };

  let verbose = false;
  const useFetch = process.argv[2] === "fetch";
  console.log("using fetch", useFetch);

  server.route({
    method: "get",
    path: "/verbose",
    handler: (request, reply) => {
      verbose = !verbose;
      reply({ verbose });
    }
  });

  server.route({
    method: "get",
    path: "/agent",
    handler: (request, reply) => {
      const agent = keepAlive.getKeepAlive("http").agent;
      reply({ agent: agent.getCurrentStatus() });
    }
  });

  server.route({
    method: "get",
    path: "/x1",
    handler: (request, reply) => handle(request, reply, useFetch, verbose)
  });

  server.route({
    method: "get",
    path: "/x1_fetch",
    handler: (request, reply) => handle(request, reply, true, true)
  });
});
