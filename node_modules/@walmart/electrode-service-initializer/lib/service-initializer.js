"use strict";

const Promise = require("bluebird");
const _ = require("lodash");
const pkg = require("../package.json");
const fs = require("fs");
const logWithSuppression = require("./log-with-suppression");
const readFileAsync = Promise.promisify(fs.readFile, fs);
const Path = require("path");
const Registry = require("./service-registry");
const Chalk = require("chalk");
const util = require("util");

const registryModule = "@walmart/service-registry-client";
const RegistryClient = require(registryModule);

class ServiceInitializer {
  constructor(options) {
    this._config = options.config;
    this._Services = function Services() {};
    this._clientInfoList = null;
    this._registryClient = null;
    this._consoleLogger = options.consoleLogger || logWithSuppression(options.config.services);
  }

  createContainer() {
    return new this._Services();
  }

  requireMod(mod) {
    return Promise.resolve(mod)
      .then(require)
      .catch(err => {
        err.message = `${pkg.name} - load service provider ${mod} failed - ${err.message}`;
        throw err;
      });
  }

  loadProviderModule(mod) {
    return _.isString(mod) // if mod is string
      ? this.requireMod(mod) // then load it with require.
      : Promise.resolve(mod); // otherwise assume it is the module
  }

  loadClient(provider, name) {
    const modName = provider.module || name;
    const useName = modName === name;
    // if a module is specified then either load it or assume it's the module object
    // otherwise use the provider name as the module name and load it
    return this.loadProviderModule(modName).then(Client => {
      provider._env = provider.env || this._config.services.env || "qa";
      return (
        Client &&
        _.isFunction(Client.create) && {
          name,
          Client,
          provider,
          useName,
          discovery: { isNew: true }
        }
      );
    });
  }

  loadClientModules() {
    return _.map(this._config.services.providers, (provider, name) => {
      // skip if explicitly set autoInit to false.
      return provider.autoInit !== false && this.loadClient(provider, name);
    });
  }

  saveClient(info, client) {
    const Services = this._Services;
    const name = info.name;
    const providerName = info.Client.providerName;
    // If the client module is loaded with provider field name, then
    // save client instance with its providerName
    if (info.useName && providerName && !Services.prototype[providerName]) {
      Services.prototype[providerName] = client;
    }
    // Save client instance with the provider field name from config
    if (providerName !== name && !Services.prototype[name]) {
      Services.prototype[name] = client;
    }
    return client;
  }

  createClient(info) {
    const override = _.pick(info.discovery, ["schemes", "host", "basePath"]);

    //
    // if <name> is different from default providerName, then use <name> as providerName
    //
    const providerName = info.name !== info.Client.providerName && info.name;
    info.provider._type = info.type || info.provider.type;
    info.provider._env = info.discovery.environment;

    const save = client => {
      const swagger = client.swagger;
      const logData = {
        name: client.name,
        scheme: swagger.scheme,
        host: swagger.host,
        basePath: swagger.basePath,
        type: info.provider._type,
        env: info.discovery.environment
      };
      this._consoleLogger.log(Chalk.green("created service client"), JSON.stringify(logData));
      info.discovery.isNew = false;
      return this.saveClient(info, client);
    };

    return info.Client.create(this._config, override, providerName).then(save);
  }

  loadPrivateKey() {
    const privateKey = this._config.services.privateKey || {};
    const promise = privateKey.file
      ? readFileAsync(Path.resolve(privateKey.file)).then(data => data.toString("ascii"))
      : Promise.resolve(privateKey.key || "");

    return promise.then(key => (privateKey.pemKey = key));
  }

  initializeRegistryClient() {
    const config = this._config;
    if (config.services.useRegistry === false) {
      return null;
    }

    const provider = config.services.providers[registryModule] || {};

    config.services.providers[registryModule] = provider;
    config.services.providers[RegistryClient.providerName] = provider;

    provider.autoInit = false;
    provider.autoDiscovery = false;

    return this.loadClient(provider, registryModule)
      .then(info => this.createClient(info))
      .then(client => (this._registryClient = client));
  }

  registryRefreshStatus(info, refreshed) {
    const name = info.provider.name || info.Client.serviceName;
    return { name, refreshed };
  }

  registryNoChange(info) {
    return this.registryRefreshStatus(info, false);
  }

  registryRefreshed(info) {
    return this.registryRefreshStatus(info, true);
  }

  discoverCreate(request, force, info) {
    if (info.provider.autoDiscovery === false) {
      const warning = "  Warning: Service autoDiscovery is disabled for client: ";
      const module = info.provider.module || info.name;
      const reason = "\n   This can cause issues in production environments, proceed with caution.";
      const shouldWarn = module !== "@walmart/service-registry-client";

      if (shouldWarn) {
        this._consoleLogger.error(
          Chalk.bold.red(warning) + Chalk.cyan(module) + Chalk.bold.red(reason)
        );
        request.log(["warn"], warning + module + reason);
      }
    }

    const promise =
      info.provider.autoDiscovery !== false && this._registryClient
        ? Registry.discoverWithSearch(request, info).catch(err => {
            const msg = util.format("discover service failed:", err.message);
            this._consoleLogger.error(Chalk.bold.red(msg));
            request.log(["warn"], msg);
            return null;
          })
        : Promise.resolve(null);

    return promise.then(() => {
      if (info.discovery.isNew) {
        return this.createClient(info).then(() => this.registryRefreshed(info));
      } else {
        return this.registryNoChange(info);
      }
    });
  }

  checkRefreshRegistry(request, force, info) {
    if (!force && !info.discovery.isNew) {
      return Promise.resolve(this.registryNoChange(info));
    }

    return this.discoverCreate(request, force, info);
  }

  refreshServiceClients(request, force) {
    return Promise.resolve(this._clientInfoList)
      .map(info => this.checkRefreshRegistry(request, force, info))
      .then(refreshList => {
        const refreshed = _(refreshList)
          .filter(x => x.refreshed)
          .map(x => `${x.name}`);
        this._consoleLogger.log(
          Chalk.green("SERVICE REGISTRY DISCOVERY COMPLETED:"),
          refreshed.isEmpty() ? "NO" : "",
          "CHANGE",
          refreshed.value().join(";")
        );
      })
      .catch(err => {
        this._consoleLogger.log(
          Chalk.red("Service Initializer refresh clients failed"),
          err.message
        );
        throw err;
      });
  }

  init() {
    return Promise.try(() => this.loadPrivateKey())
      .then(() => this.initializeRegistryClient()) // initialize client for registry service
      .then(() => this.loadClientModules()) // load modules for clients
      .filter(x => x) // get rid of the ones that doesn't want autoInit
      .then(list => (this._clientInfoList = list)); // save list for later refresh
  }
}

module.exports = ServiceInitializer;
