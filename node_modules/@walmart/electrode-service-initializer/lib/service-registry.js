"use strict";

const _ = require("lodash");
const Url = require("url");
const Promise = require("bluebird");
const assert = require("assert");

const communicationTypeMap = {
  DIRECT: "ENDPOINT"
};

function mapCommType(type) {
  return communicationTypeMap[type] || type;
}

/* eslint-disable max-statements */
/* eslint-disable no-console */
function discoverWithSearch(request, info) {
  const config = request.app.config;
  const params = _.pickBy(
    {
      environment: info.provider._env,
      name: info.provider.name || info.Client.serviceName,
      serVersion: info.provider.version || info.Client.serviceVersion
    },
    _.identity
  );

  if (!params.name) {
    return Promise.resolve();
  }

  const paramsString = JSON.stringify(params);
  console.log("Electrode discoverWithSearch - discovering", paramsString);
  console.log("INFO", JSON.stringify(info));

  return request.app.services.registry
    .withMeta(request)
    .search(params)
    .then(resp => {
      console.log("Electrode discoverWithSearch - discovered", paramsString);

      const services = _.first(resp.obj.payload.services);
      if (_.isEmpty(services) || _.isEmpty(services.serviceVersions)) {
        throw new Error(`registry cannot find service ${paramsString}`);
      }

      const service = _.first(services.serviceVersions);
      const consumer =
        _.find(service.consumerSubscriptions, { consumerId: config.services.consumerId }) || {};
      console.log(
        `service versions of ${params.name} discovered - urls:`,
        JSON.stringify(service.urls),
        "consumer:",
        JSON.stringify(consumer)
      );
      let data;
      const type = _.find(
        [mapCommType(consumer.communicationType), info.provider.type, "ENDPOINT"],
        t => t && (data = _.find(service.urls, x => x.type === t))
      );
      assert(data && data.url, "Unable to find a valid URL from registry data");
      const urlObj = Url.parse(data.url);
      const current = info.discovery;

      if (current.host !== urlObj.host || current.basePath !== urlObj.pathname) {
        info._discovery = info.discovery;
        info.discovery = {
          schemes: [_.first(urlObj.protocol && urlObj.protocol.split(":"))],
          host: urlObj.host,
          basePath: urlObj.pathname,
          url: data.url,
          type,
          isNew: true
        };
      }

      return info.discovery;
    });
}

module.exports = {
  discoverWithSearch
};
