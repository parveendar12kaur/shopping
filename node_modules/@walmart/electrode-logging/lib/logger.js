"use strict";

/* eslint-disable no-magic-numbers */

const fs = require("fs");
const path = require("path");
const bunyan = require("../bunyan");
const _ = require("lodash");
const serializers = require("./serializers");
const utils = require("./log-utils");
const symbols = require("./symbols");
const fyi = require("@walmart/electrode-fyi");

const transportsDir = path.join(__dirname, "transports");

const TRANSPORTS = {};

_.each(fs.readdirSync(transportsDir), file => {
  const transportType = _.camelCase(file.replace(".js", ""));
  TRANSPORTS[transportType] = require(path.join(transportsDir, file)); // eslint-disable-line
});

const fyiError = fyi.limitError("electrode-logging", 100);

class Logger {
  constructor(config) {
    if (!config || _.isEmpty(config.transports)) {
      throw new Error("electrode-logging: Missing transports configuration.");
    }
    this.options = this.setOptions(config);
    this.serializers = this.createSerializers(config);

    // we provide them here for export as available options to prehandler
    this.defaultSerializers = serializers.defaultSerializers;

    // we also have to expose the user specified config serializers to the prehandler
    // because we want to be able to merge ontop of those with prehandler overrides
    // but not include the default serializers which are binded over with config include/exclude
    // and instead we bind over with prehandler include/exclude
    this.userSpecifiedConfigSerializers = config.serializers;
    // as well as the include and exclude
    this.userSpecifiedConfigInclude = config.include;
    this.userSpecifiedConfigExclude = config.exclude;

    if (config.logMode === "development") {
      // Ensure we only process stdout
      config.transports = _.filter(config.transports, t => {
        return t.type === "stdout";
      });
      if (_.isEmpty(config.transports)) {
        throw new Error("electrode-logging: Must configure stdout transport in development mode.");
      }
      // Force default for development mode
      config.transports[0].default = true;
    }

    // Create a logger per configured transport
    this.loggers = {};
    _.each(config.transports, transportConfig => {
      this.addTransportLogger(transportConfig);
    });
  }

  createSerializers(config = {}) {
    return serializers.create({
      verbose: this.options.verbose,
      overrides: config.serializers,
      include: config.include || [],
      exclude: config.exclude || []
    });
  }

  setOptions(config) {
    const configVerbose =
      config.serializers && config.serializers.verbose !== undefined
        ? config.serializers.verbose
        : config.verbose;
    config.serializers = _.omit(config.serializers, ["verbose"]);

    const options = {
      mapping: require("./tagmappings")(config.logMode), // eslint-disable-line global-require
      logMode: config.logMode,
      verbose: Boolean(configVerbose),
      defaultTransports: []
    };

    /*

      Sample OneOps setting from prod VM

      export ONEOPS_NSPATH=/GlobalProducts/products/prod-d/bom/electrode-nodejs/1
      export ONEOPS_PLATFORM=electrode-nodejs
      export ONEOPS_ASSEMBLY=products
      export ONEOPS_ENVIRONMENT=prod-d
      export ONEOPS_ENVPROFILE=EBF
      export ONEOPS_CI_NAME=os-11030446-1
      export ONEOPS_COMPUTE_CI_ID=283893997
      export ONEOPS_CLOUD=prod-dfw3
      export ONEOPS_CLOUD_AVAIL_ZONE=az1
      export ONEOPS_CLOUD_COMPUTE_SERVICE=dfw3
      export ONEOPS_CLOUD_REGION=RegionOne
      export ONEOPS_CLOUD_ADMINSTATUS=primary
      export ONEOPS_CLOUD_TENANT=globalproducts
      export rubygems=http://repos.walmart.com/gemrepo/
      export rubygemsbkp=http://repos.walmart.com/gemrepo/
      export ruby=
      export DATACENTER=dfw
      export misc=http://repos.walmart.com/mirrored-assets/apache.mirrors.pair.com/
    */

    this.oneOpsEnv = {
      env: process.env.ONEOPS_ENVIRONMENT,
      cloud: process.env.ONEOPS_CLOUD_COMPUTE_SERVICE,
      // only included in verbose mode
      assembly: process.env.ONEOPS_ASSEMBLY,
      profile: process.env.ONEOPS_ENVPROFILE
    };

    if (process.env.ONEOPS_CI_NAME) {
      options.hostname = process.env.ONEOPS_CI_NAME;
    }

    if (config.prehandler) {
      options.prehandler = config.prehandler;
    }

    return options;
  }

  addTransportLogger(transportConfig) {
    const transportType = this.options.mapping[transportConfig.type];

    if (!transportType) {
      throw new Error(
        `electrode-logging: Unknown transport type: ${transportConfig.type}` +
          `. Valid options: ${_.keys(this.options.mapping).join(", ")}`
      );
    }

    if (this.loggers[transportType]) {
      fyi.error(`electrode-logging: transport ${transportType} already specified`);
      return;
    }

    if (transportConfig.default === true) {
      this.addDefaultTransport(transportType);
    }

    if (transportConfig.level) {
      transportConfig.level = transportConfig.level.toLowerCase();
    }

    if (transportConfig.path && process.env.NODE_APP_INSTANCE) {
      transportConfig.path = utils.insertProcessInfo(transportConfig.path);
    }

    const logger = bunyan.createLogger({
      serializers: this.serializers,
      name: transportType,
      hostname: this.options.hostname,
      streams: [TRANSPORTS[transportType](transportConfig)]
    });

    logger.on("error", err => {
      if (process.env.NODE_ENV === "development" || process.env.NODE_ENV === "test") {
        fyi.error(`electrode-logging: Error in ${transportType} logger: ${err}`);
      }
    });

    this.loggers[transportType] = logger;
  }

  addDefaultTransport(transportType) {
    if (this.options.defaultTransports.indexOf(transportType) < 0) {
      this.options.defaultTransports.push(transportType);
    }
  }

  //
  // Try to find the minimum log level from tags
  // If no log level was specified, then default to info
  //
  getLevel(tags) {
    let level = bunyan.levelFromName.fatal + 1;

    _.each(tags, tag => {
      const n = bunyan.levelFromName[tag];
      if (n < level) {
        level = n;
      }
    });

    return level > bunyan.levelFromName.fatal ? "info" : bunyan.nameFromLevel[level];
  }

  //
  // Take the data from Hapi plugin electrode-logging-plugin generates for the call
  // req.log(tags, data) and format it into a bunyan logger data
  //
  /* eslint-disable max-statements */
  formatOutput(tags, data) {
    let verbose = this.options.verbose;

    // apps need env and cloud (previous referred to as dataCenter e..g. DFW3) to query logs
    const output = { oo_env: this.oneOpsEnv.env, cloud: this.oneOpsEnv.cloud, tags };

    if (data.$) {
      output[symbols.entryOpt] = data.$;
      if (data.$.verbose !== undefined) verbose = data.$.verbose;
    }

    if (verbose) {
      output.tenant = this.oneOpsEnv.assembly;
      output.profile = this.oneOpsEnv.profile;
    }

    let k;
    for (k in data) {
      if (k !== "$") output[k] = data[k];
    }
    // transfer the hidden symbol fields from electrode-logging-plugin
    // into the standard fields, which will be serialized by the bunyan serializers
    output.request = data[symbols.request];
    output.response = data[symbols.response];
    output.context = data[symbols.context];

    return output;
  }

  //
  // logs data from Hapi req.log(tags, data)
  // tags must be an array
  // data must be an object
  //
  /* eslint-disable max-statements */
  log(tags, data) {
    if (!_.isArray(tags)) {
      throw new `electrode-logging: Log method requires tags array. Found: ${typeof tags}`();
    }

    const level = this.getLevel(tags);
    const mapping = this.options.mapping;

    let count = 0;
    const sent = {};
    let msg = "";

    if (!data) {
      data = {};
    } else if (typeof data === "string") {
      msg = data;
      data = {};
    } else if (data.msg) {
      msg = data.msg;
    }

    const output = this.formatOutput(tags, data);

    const sendToTransport = transport => {
      if (transport && !sent[transport]) {
        const logger = this.loggers[transport];
        sent[transport] = true;
        if (logger) {
          count++;
          logger[level](output, msg);
        } else {
          fyiError(`electrode-logging: Failed to find logger for transport: ${transport}`);
        }
      }
    };

    _.each(tags, tag => sendToTransport(mapping[tag]));
    if (count === 0) {
      if (this.options.defaultTransports.length > 0) {
        _.each(this.options.defaultTransports, sendToTransport);
      } else {
        fyiError(`electrode-logging: log didn't specify any transports and no default transports`);
      }
    }
  }

  close() {
    if (this.loggers.logmon) {
      this.loggers.logmon.streams[0].stream.close();
    }
  }
}

module.exports = Logger;
