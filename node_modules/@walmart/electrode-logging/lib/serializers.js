"use strict";

/* eslint-disable max-statements */
/* eslint-disable max-params */
/* eslint-disable max-statements */
/* eslint-disable no-magic-numbers */

const _ = require("lodash");
const symbols = require("./symbols");
const defaultFields = require("./default-fields");
//
// Electrode logging provides default serializers for Hapi request and response
// And for WML Logmon transaction context defined by the module electrode-log-transaction
//
const defaultSerializers = {
  request: (request, data, bun, verbose, fields) => {
    if (!request) return request;

    const opt = data[symbols.entryOpt];
    if (opt && opt.verbose !== undefined) {
      verbose = opt.verbose;
    }
    const req = _.pick(request, verbose ? fields.request.verbose : fields.request.std);

    // consider removal of the always include path
    // always include path, regardless
    if (request.url && request.url.path) {
      req.path = request.url.path;
    }
    return req;
  },

  response: (response, data, bun, verbose, fields) => {
    if (!response) return response;

    const opt = data[symbols.entryOpt];
    if (opt && opt.verbose !== undefined) {
      verbose = opt.verbose;
    }

    return _.pick(response, verbose ? fields.response.verbose : fields.response.std);
  },

  context: (context, data, bun, verbose, fields) => {
    if (!context) return null;

    const opt = data[symbols.entryOpt];
    if (opt && opt.verbose !== undefined) {
      verbose = opt.verbose;
    }

    let ctxFields;

    if (verbose) {
      ctxFields = fields.context.verbose;
    } else if (context.subtype === "-") {
      return null;
    } else {
      ctxFields = fields.context.std;
    }

    const ctx = _.pick(context, ctxFields);
    if (ctx.subtype && ctx.subtype.endsWith("-END")) {
      ctx.duration = context.duration;
    }

    // cleanup transaction ids
    if (ctx.txId === ctx.topTxId) {
      delete ctx.topTxId;
    }
    if (ctx.txId === ctx.parentTxId) {
      delete ctx.parentTxId;
    }

    return ctx;
  },

  err: (obj, data, bun, verbose, fields) => {
    // verbose isn't currently used to determine output
    return _.pick(obj, fields.err.std);
  }
};

defaultSerializers.err.errFields = defaultFields.err.std;

const create = options => {
  const include = options.include || [];
  const exclude = options.exclude || [];
  const overrides = options.overrides || {};
  const verbose = Boolean(options.verbose);

  // deep clone since we will modify these fields in include-exclude
  const fields = JSON.parse(JSON.stringify(defaultFields));

  const bindVerbose = fn => (x, data, bun) => fn(x, data, bun, verbose, fields);

  const standardOverrides = _.pick(overrides, fields.standardFields);
  const otherOverrides = _.omit(overrides, fields.standardFields);
  const serializers = _.defaults(
    {},
    _.mapValues(standardOverrides, bindVerbose),
    _.mapValues(defaultSerializers, bindVerbose),
    _.mapValues(otherOverrides, bindVerbose)
  );

  const addItem = item => {
    const key = item.key; // this is top level key, e.g. request/response/context
    const value = item.value; // e.g. headers.Content-type
    if (!_.includes(fields[key].std, value)) {
      fields[key].std.push(value);
    }
    if (!_.includes(fields[key].verbose, value)) {
      fields[key].verbose.push(value);
    }
  };

  // suppose 'request.headers.Content-type' was specified in include, then we
  // want to ignore the top level request.headers
  const ignoreFirstParentKey = item => {
    const topLevelKey = item.key;
    const result = item.value.split(".");
    if (result.length > 1) {
      const firstParent = result[0];
      _.pull(fields[topLevelKey].std, firstParent);
      _.pull(fields[topLevelKey].verbose, firstParent);
    }
  };

  const removeItem = item => {
    const key = item.key;
    const value = item.value;
    _.pull(fields[key].std, value);
    _.pull(fields[key].verbose, value);
  };

  const re = new RegExp(/^(.+?)\.(.+)$/);
  const testValid = field => re.test(field);
  const splitField = field => {
    const result = field.match(re);
    const key = result[1];
    const value = result[2];
    return { key, value };
  };
  const filterKey = item => {
    return fields[item.key] !== undefined;
  };

  const includeList = include
    .filter(testValid)
    .map(splitField)
    .filter(filterKey);
  includeList.forEach(ignoreFirstParentKey);
  includeList.forEach(addItem);

  exclude
    .filter(testValid)
    .map(splitField)
    .filter(filterKey)
    .forEach(removeItem);

  return serializers;
};

module.exports = {
  create,
  defaultSerializers
};
