"use strict";

/*
 * DEPRECATED:
 *
 * This serializer creates payload for the deprecated Logmon.rawlog format.
 * It was being sent to the Logmon.rawlog/Hive Kafaka, which is not actively used
 * and scheduled to be deprecated.
 * It's being kept around for records.  It may be removed in the near future.
 */

/* eslint-disable max-statements */

const _ = require("lodash");
const Logmon = require("@walmart/electrode-logmon");
const EventEmitter = require("events").EventEmitter;
const safeStringify = require("json-stringify-safe");
const fyi = require("@walmart/electrode-fyi");

const LEVELS = {
  10: "DEBUG", // TRACE in bunyan
  20: "DEBUG",
  30: "INFO",
  40: "WARN",
  50: "ERROR",
  60: "ERROR" // FATAL in bunyan
};

const DEFAULT_MODE = 1; // file

class LogmonStream extends EventEmitter {
  constructor(options) {
    super();
    options = options || {};
    this.logmon = new Logmon({
      filePath: options.path,
      mode: options.mode || DEFAULT_MODE,
      zookeeper: options.zookeeper,
      emitErrors: true
    });
    const self = this;
    this.logmon.on("error", err => {
      if (err.code === "ENOENT") {
        fyi.error(`electrode-logging logmon output ${options.path} not found`);
        self._closed = true;
      } else {
        fyi.error(`electrode-logging logmon error:`, err);
      }
      self.emit("error", err);
    });
  }

  write(record) {
    if (this._closed) {
      this.emit("error", "Attempted to write to closed stream.");
      return;
    }
    const output = this.transformBunyanLog(record);
    this.logmon.write(output);
  }

  //
  // This is a transport for bunyan which would've reformat the record
  // and remove symbols fields from the record
  //
  transformBunyanLog(record) {
    const level = record.level ? LEVELS[record.level] : record.level;
    const ctx = record.context || {};
    const ud = x => (_.isNil(x) || x === "" ? "-" : x);

    const output = {
      category: "-",
      payload: {
        tags: record.tags
      },
      tenant: ud(record.tenant),
      type: ud(level),
      // context
      duration: ud(ctx.duration),
      level: ud(ctx.level),
      parentTxId: ud(ctx.parentTxId),
      sessionId: ud(ctx.sessionId),
      subType: ud(ctx.subtype),
      topTxId: ud(ctx.topTxId),
      txId: ud(ctx.txId)
    };

    if (ctx.state !== undefined && ctx.isRunning && !ctx.isRunning()) {
      output.payload["tx.status"] = ctx.state;
    }

    if (record.msg) {
      output.payload["applog.msg"] = record.msg;
    }

    const req = record.request;

    if (req) {
      output.payload["request.method"] = req.method;
      output.payload["request.path"] = req.path;
    }

    const resp = record.response;
    if (resp) {
      output.payload["response.statusCode"] = resp.statusCode;
    }

    _.each(record.data, (value, key) => {
      if (output.payload[key]) {
        key = `data${key}`;
      }
      if (_.isObject(value) || _.isArray(value)) {
        value = safeStringify(value);
      }
      output.payload[key] = value;
    });

    return output;
  }

  close() {
    this.logmon.closeKafka();
  }
}

module.exports = options => {
  return _.defaults(
    {
      type: "raw",
      stream: new LogmonStream(options),
      reemitErrorEvents: true
    },
    options
  );
};
