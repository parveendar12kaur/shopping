<h1><img width="250" alt="log_minpad" align="right" src="https://gecgithub01.walmart.com/github-enterprise-assets/0000/5467/0001/1305/394042d6-d0b0-11e5-8c25-8b4be8054e87.png">electrode-logging</h1>

Lead Maintainers: [Joel Chen](https://gecgithub01.walmart.com/xchen11)

electrode-logger makes it easy to keep track of your application calls!

Single point of entry:
```javascript
    request.log(["info", "Hello World!");
```
##### Table of Contents
* Introductory usage

  |Jump to| [examples](#examples) | [methods](#methods) | [tags](#tags) | [data](#data) |
  |-------| ----------------------| --------------------|---------------|---------------|

* Configuration

  | Jump to | [what data will I actually see](#what-you-see) | [verbose](#verbose) | [serializers](#serializers) | [logMode](#logmode) |
  | - | - | - | - | - |

* Advanced usage

  | Jump to | [OneOps](#oneops) | [include-exclude](#include-exclude) |[prehandler](#prehandler) |
  | - | - | - | - |

## Examples
These are fully self-contained examples you can try out.
### logger.log
```javascript
    const Logger = require('@walmart/electrode-logging');
    const logger = new Logger({ transports: [{type:'stdout', default:true}]})
    logger.log(["info"], "Hello World!");
```
We specify in our `transports` (which is required), `stdout` and set it to be our `default`.
Now take a look at this equivalent example where we don't specify a `default`, so we must specify the transport in our *tags*.
```javascript
    const Logger = require('@walmart/electrode-logging');
    const logger = new Logger({ transports: [{type:'stdout'}]})
    logger.log(["info", "stdout"], "Hello World!");
```
Here we specified `stdout` as our transport of choice.


### request.log - with Hapi Plugin
```javascript
    const logPlugin = require("@walmart/electrode-logging-plugin");
    const Hapi = require("hapi");
    const server = new Hapi.Server();
    server.connection({ port: 3000 });
    server.app.config = { logging: { transports: [{ type: "stdout" }]}};
    server.route({ method: "GET", path: "/",
      handler: (req, reply) => {
        req.log(["info", "stdout"], "Hello World!");
      }
    });
    server.register([logPlugin], () => {
      server.inject("/", () => {
      });
    });
```
### request.log - with Electrode-Wml-Server
[electrode-wml-server](https://gecgithub01.walmart.com/electrode/electrode-wml-server) runs with this plugin enabled!  This is all you need:
```javascript
require("@walmart/electrode-wml-server")().then( server => {
  server.route({
    method: 'GET',
    path: '/',
    handler: function(request, reply) {
      request.log(["info"], "my Info log")
      reply("Hello World!")
    }
  });
  server.inject("/", (res) => {
    console.log("response:", res.result);
  })
});
```
[:arrow_upper_left: back to top](#table-of-contents)

## Methods
The difference between `logger.log` and `request.log`
* `logger.log` is through [electrode-logging](https://gecgithub01.walmart.com/electrode/electrode-logging) directly
* `request.log` is through [electrode-logging-plugin](https://gecgithub01.walmart.com/electrode/electrode-logging-plugin) which in turn uses electrode-logging

### logger.log(tags, data)
You can call this directly
```javascript
    const Logger = require('@walmart/electrode-logging');
    const logger = new Logger({ transports: [{type:'stdout', default:true}]})
    logger.log(["info"], "Hello World!");
```

### request.log(tags, data)
You call `request.log` from within your handler
```javascript
require("@walmart/electrode-wml-server")().then( server => {
  server.route({
    method: 'GET',
    path: '/',
    handler: function(request, reply) {
      request.log(["info"], "Hello World!")
      reply("Hello World!")
    }
  });
  server.inject("/", (res) => {
    console.log("response:", res.result);
  })
});
```
[:arrow_upper_left: back to top](#table-of-contents)

## Tags

Tags are a *list* of strings comprised of
1. [Log Levels](#log-levels) and
2. [Transport Fields](#transport-fields)


### Log Levels
You can specify one or more log levels however, the lowest one will be used. If no levels are specified, then it will use `"info"`.

```javascript
req.log(["info"], "Hello World!")
```
 (from low to high)

| Levels | Description |
| --- | --- |
| `"trace"` | very detailed application logging |
| `"debug"` | Anything else, i.e. too verbose to be included in "info" level |
| `"info"` | Detail on regular operation |
| `"warn"` | A note on something that should probably be looked at |
| `"error"` |  Fatal for a particular request, but the service/app continues servicing other requests |
| `"fatal"` | The service/app is going to stop or become unusable now |

 See [bunyan docs](https://github.com/trentm/node-bunyan#levels) for additional information about these levels.

### Transport fields

```javascript
req.log(["info", "stdout", "file"], "Hello World!")
```

In this example, `"stdout"` and `"file"` were specified as transports. Every transport specified in the tags must be **enabled** in the configuration first.

The following example prints the log to `stdout` and to a `file` in the current directory.

```javascript
require("@walmart/electrode-wml-server")().then( server => {
  let count = 0;
  server.app.config = {
    logging: {
      transports: [{type: "file", path:"myLog.txt"}, { type: "stdout" }]
    }
  };
  server.route({
    method: 'GET',
    path: '/',
    handler: function(request, reply) {
      request.log(["info", "file"], { msg : "Hello", count: count})
      reply("Hello World!")
      count++;
    }
  });
  server.inject("/", (res) => {
    console.log("response:", res.result);
  })
});

```
You can optionally specify *one* transport as the default by setting `default: true` in its config. Logs that do not specify a transport in their tags will be sent to the default transport.

```javascript
transports: [{type: "file", path:"myLog.txt"}, { type: "stdout", default: true }]
```
```javascript
request.log(["info"], {msg: "Hello World!"})
```
The above log will be sent to `stdout` because it has been marked as `default`.
**If there is no transport specified in the tags AND there is no default set, they won't be logged.**

You can specify one or more transports, and your logs will be sent along those transports.

Available transports:

| Transports | Description |
| --- | --- |
| `"stdout"` | Logs to `process.stdout` |
| `"splunk"` | Logs to file, formatted so it can be sent to/read by Splunk. |
| `"file"` | Logs to file. |
| `"logmon"` | Writes to file and/or kafka using [logmon](https://gecgithub01.walmart.com/platform-node/logmon#new-logmonoptions) |
| `"apm"` | Logs to file, which can be sent to/read by APM. |

##### `"stdout"`

Logs to `process.stdout`.

```js
{
  type: "stdout"
}
```

##### `"apm"`

Logs to file, which can be sent to/read by APM.

```js
{
  type: "apm",
  path: "file/path/example.log"
}
```

##### `"file"`

Logs to file.

```js
{
  type: "file",
  path: "file/path/example.log"
}
```

##### `"logmon"`

Writes to file and/or kafka using
[platform-node/logmon](https://gecgithub01.walmart.com/platform-node/logmon#new-logmonoptions).

Mode: 1 = file only, 2 = kafka only, 3 = both. See link above for more details.

```js
{
  type: "logmon",
  mode: 1,                  // optional; defaults to 1
  path: "path/example.log"  // optional; see link for default
}
```

##### `"splunk"`

Logs to file, which can be sent to/read by Splunk.

```js
{
  type: "splunk",
  path: "file/path/example.log"
}
```
[:arrow_upper_left: back to top](#table-of-contents)

## Data
For the `data` field in `.log(tags, data)`

* You can use a string:
```javascript
      request.log(["info"], "Hello World!")
```
* or an object
```javascript
      request.log(["info"], {msg: "Hello World!", isBeep: true, num: 34})
```

If you are using `request.log` and you log an object, do not use the [reserved keys](#reserved-keys), and three keys that are considered [special keys](#special-keys).

### Special keys
| key | description |
| - | - |
| `msg` | `logger.log(["info"], { a: "b", msg: "Log message" })`|
| `err` | `logger.log(["error"], { err: err })`|
| `$` | `logger.log(["info"], { msg: "Log message", $: { verbose: true} }})`|

If you have an error, pass the error object in the `"err"` field.
```javascript
  req.log(["error"], {err: new Error("Not Found")});
```

If you want to selectively log *verbosely*, use the `"$"` field
```javascript
  req.log(["info"], {msg: "Hello World!", $: {verbose: true}});
```
Then this specific log entry will be logged *verbosely*. See [verbose](#verbose) for what this means.

### Reserved keys (Do not use these)

If you are using `request.log` these keys will show up automatically in your logs whenever you `.log`

| key | description |
| - | - |
| `tags` | Used internally for tag mapping |
| `context` | Overridden by logging plugin |
| `request` | Overridden by logging plugin |
| `response`| Overridden by logging plugin |

[:arrow_upper_left: back to top](#table-of-contents)

## What you see

When using the `request.log` interface, there are three important objects that will be logged along with your `data`. Those are

* the `request` object
* the `response` object
* the `context` object

If we do this
```javascript
    req.log(["info"], { msg: "Hello World!" });
```
from within our handler, then we will see
```json
{
  "name":"stdout",
  "hostname":"m-c02rh3nbg8wm",
  "pid":19653,
  "tags":[
    "info"
  ],
  "msg":"Hello World!",
  "request":{
    "method":"get",
    "path":"/",
    "id":"1513706515120:m-c02rh3nbg8wm:19653:jbdxry5d:10000"
  },
  "context":null,
  "level":30,
  "time":"2017-12-19T18:01:55.126Z",
  "v":0
}
```
Notice that your `request` was serialized with

* `"method"`
* `"path"`
* `"id"`

This is the default serializer for the `request` object. Continue on to the [verbose](#verbose) section to learn about all the fields that actually get logged.

[:arrow_upper_left: back to top](#table-of-contents)

## Verbose

By default, our `request` is serialized to show these 3 fields

* `"method"`
* `"path"`
* `"id"`

But we can log *verbosely* and in addition show these fields:

* `"info"`
* `"params"`
* `"headers"`

There are two ways to enable this verbose logging

1. On demand verbose
```javascript
req.log(["info"], {msg: "Hello World!", $: {verbose: true}});
```
2. in your configuration
```javascript
server.app.config = {
  logging: {
    verbose: true,
    transports: [{ type: "stdout", default: true }]
  }
};
```

The first option gives you the option to turn on verbose *selectively*, whereas the second turns on verbose *globally*. The following three tables list the fields that are logged by default, and **if `verbose` is enabled, those fields are logged in addition to the default fields.**

* Request

| type | fields |
| - | - |
| default | ["method", "path", "id"] |
| verbose | ["info", "params", "headers"] |


* Response


| type | fields |
| - | - |
| default | ["statusCode"] |
| verbose | ["settings", "headers"] |

* Context

| type | fields |
| - | - |
| default |  ["topTxId", "txId", "parentTxId", "level", "subtype"] |
| verbose | ["sessionId", "topTxId", "tx.status", "isTopLevel", "txId", "parentTxId", "state", "isRunning", "level", "duration", "start", "subtype", "cachedSubtype" ] |

[:arrow_upper_left: back to top](#table-of-contents)


## Serializers

When you `request.log(tags, data)`, the `data` object can be run through a serializer to shape its output emitted in the log. The `serializers` object accepts keys which are
mapped to the logged `data` object.

```javascript
req.log(["info"], { msg: "bummer", ssn: "123-45-6789"});
```

```javascript
serializers: {
  ssn: (data, verbose) => {
    // data is "123-45-6789"
    // we will mask it in our logs
    return "XXX-XX-XXXX";
  }
}
```

And we will get this output
```javascript
{
  "name":"stdout",
  "hostname":"m-c02rh3nbg8wm",
  "pid":20461,
  "tags":[
    "info"
  ],
  "msg":"bummer",
  "ssn":"XXX-XX-XXXX",
  "request":{
    "method":"get",
    "path":"/",
    "id":"1513709994382:m-c02rh3nbg8wm:20461:jbdzuiri:10000"
  },
  "context":null,
  "level":30,
  "time":"2017-12-19T18:59:54.388Z",
  "v":0
}
```

You can also override the default `request`, `response`, and `context` serializers by specifying them in your serializers configuration, however it is highly recommended that you use the default serializers.

[:arrow_upper_left: back to top](#table-of-contents)

## logMode

You can optionally enable `development` logMode, such that all transports will go to `stdout` except `file`. Otherwise
it will be considered as `production` meaning that all transports will not be modified.
```javascript
server.app.config = {
  logging: {
    logMode: "development",
    verbose: true,
    transports: [{ type: "splunk", path: "splunk.log"} ]
  }
};
```

Given the above configuration,
```javascript
request.log(["info", "splunk"], "Hello World!")
```
will redirect the `splunk` transport to use `stdout` instead.

[:arrow_upper_left: back to top](#table-of-contents)


## OneOps

If your app is running on OneOps, then these fields are automatically added to every log entry:

| field | from |
| - | - |
| `oo_env` | `process.env.ONEOPS_ENVIRONMENT` |
| `cloud`  | `process.env.ONEOPS_CLOUD_COMPUTE_SERVICE` |
| `hostname` | `process.env.ONEOPS_CI_NAME` |


In verbose mode, these OneOps fields are also added:

| field | from |
| - | - |
| `tenant` | `process.env.ONEOPS_ASSEMBLY` |
| `profile` | `process.env.ONEOPS_ENVPROFILE` |

[:arrow_upper_left: back to top](#table-of-contents)


## Include-Exclude

```
    include: ["request.path", "response.headers"],
    exclude: ["request.payload"]
```
If you are using any of the default serializers, you can pass along an include-exclude array of keys to specify which keys you want and exclude keys you don't. This include-exclude output will be guaranteed

  * regardless of which verbose option you have set, true or false
  * if a key specified in the include is not available, it will simply not include it
  * it can be thought of as having the final say on the output

For instance, `request.payload` is not included in either the standard or the verbose request fields in the default serializer for request. But by including `request.payload` in the `include` portion of your configuration, it will be used.

Specify in your configuration:
```js
{
  logging: {
    include: ["request.path", "response.headers"],
    exclude: ["request.payload"]
  }
}
```

So then `request.path`, `response.headers` will be included if they are available, and `request.payload` will be excluded.

#### Include can specify deep keys
Suppose our `request.headers` is
```
    { 'Content-Length': '123',
      'Content-Type': 'text/plain',
      'Expires': 'Wed, 06 Dec 2017 20:44:41 GMT',
      'connection': 'keep-alive',
      'host': 'mysite.com',
      'accept': '*/*' }
```
and our config is
```
    include: ["request.headers.Expires", "request.headers.Content-Type"],
    exclude: ["request.payload"]
```
Then we would get only `Content-Type` and `Expires` from headers:
```
    { 'Content-Type': 'text/plain',
      'Expires': 'Wed, 06 Dec 2017 20:44:41 GMT' }
```
*Please note about deep key includes*: When deep keys are specified in the `include` list, we first remove their top-level parent key from the default fields. In the example above, we removed the `request.headers` from the default fields, and then add back in the individual deep keys. We do not support deep key excludes i.e. `request.payload.abc`, only top level keys like `request.payload`.

[:arrow_upper_left: back to top](#table-of-contents)


## Prehandler

Suppose you want to have a greater degree of control over how you log **in situations where you want to choose the serializer on-the-fly.**

Consider the following example scenario:

1. You have an incoming `request`.
2. Suppose you want to check the `request.path` and see if it matches against
a list of special URL's.
   * If it matches, use a custom set of logging serializers
   * If it doesn't, use the default set of logging serializers

You would want a *prehandler* in this scenario, **so that before you go to log**, you have an opportunity to choose how you would like to serialize your data.

Your prehandler will be passed `(request, options, cb)`. The `request` object is passed to help you determine how you would like to log. The `options` object provides you with your configuration specified override serializers and logging defaults serializers that you can feel free to use as part of your callback response `cb`. if The callback `cb` is used to communicate back to the logger on how you would like to serializer.

The `options` argument:
```
    options.defaults = { default serializers }
    options.overrides = { custom serializers that the user supplied in their config }
```

The `cb` callback (responseObject, memoId):

* *send an `responseObject` as the first argument where the keys are serializers you wish to override and their values are the
actual serializers you'd like to use in this instance.* You can send an empty `{}` if you'd like to not override anything.
* *anything you don't specify in `responseObject` will simply use either your logging serializers specified in your configuration or default serializers*
* `memoId` You must provide a label that uniquely identifies your `responseObject`. For every different `responseObject` you provide, you must use an `memoId` that uniquely represents that object. Suppose in your prehandler, you have something like the following:
    ```javascript
        if (req.path === "/beep") {
            cb({ serializers: {
                request:options.defaults.request,
                user:(user) => "User name is " + user.name.toLowerCase()
            }}, "beep");
        } else {
            cb({ serializers: {
                context: options.defaults.context,
                request:options.overrides.request,
                user:(user) => "User name is " + user.name.toUpperCase()
            }}, "boop");
        }
    ```
    The `memoId` *beep* uniquely represents that combination of `{ request, user }` overrides, and likewise *boop* uniquely represents that combination of `{ context, request, user }` overrides. This `memoId` is used to cache your combination of serializer overrides i.e. your `responseObject` and subsequent calls with `memoId` *beep* will use that stored set of overrides. **Use a different memoId** for each different combination of serializers!

* the `memoId` will show up in your logs and they will show up as `memoId`, which can be useful if you query for them in Splunk.
  ```json
    {"name":"stdout","memoId":"beep","tags":["stdout"],"msg":"hi!"}
  ```

Another example of the callback
```javascript
    cb({ serializers: {
        "request": (req) => {
            return { url: req.path }
        },
        "response": options.defaults.response // use the default response serializer
        "context": options.overrides.context // use your predefined context serializer
      }}, "myMemoId");
```

##### Prehandler custom include-exclude

You can also specify a customized include-exclude within a prehandler. Remember, include-exclude list only applies to default serializers. An include list here will override your configuration specified include list, likewise with an exclude list here will override your configuration exclude list.

Example
```javascript
prehandler = (req, options, cb) => {
  // verbose false request only includes path, method and id
  // with this custom include, we can get the request headers and info
  cb(
    {
      request: options.defaults.request,
      include: ["response.headers"],
      exclude: ["request.method"]
    },
    "customForcedDefaults"
  );
};
```

##### Putting the Prehandler all together
Simply specify your `prehandler` in your configuration

```javascript
// configuration
{
  "logging": {
    "serializers": {
      mult: (num) => {
        return num*2;
      }
    },
    "prehandler": (req, options, cb) => {
      cb(
        { serializers: {
          // this mult will override the config mult
          mult: num => {
            return num*3
          },
          // this will override the default request serializer
          request: request => {
            return { myPath: request.path };
          },
          // this will override the default context serializer
          context: context => {
            return { myTxId: context.txId };
          }
        }},
        "requestAndContextCustom"
      );
    }
  }
}
```
Then, in your handler

```javascript
request.log(["info"], { mult: 10, msg: "sample message 3" });
```
Will produce
```json
{
  "name":"stdout",
  "hostname":"m-c02rh3nbg8wm",
  "pid":31166,
  "tags":[
    "info"
  ],
  "mult":30,
  "msg":"sample message 3",
}
```

#### Optimization in not needing to build out your response object

This is a recommended optimization.
Recall your prehandler will be called with `(request, options, cb)` where `options`
```
    options.defaults = { default serializers }
    options.overrides = { custom serializers that the user supplied in their config }
```
However we now mention that there is one more item passed in `options`
```
  options.availableMemoIds = { hash of memoIds }
```
So you can check
```
server.app.config.logging.prehandler = (req, options, cb) => {
  if (options.availableMemoIds.foo) {
      return cb("foo");
  } else {
      return cb({serializers: {mult: num => { return num * 3 }}}, "foo");
  }
};
```
As you can see, we didn't need to build out our response object by checking if `"foo"` already existed as a memoId. This is a small performance gain, but will be repeated millions of times, so it is recommended to check `availableMemoIds` in your options before you build out your response object
```
  {serializers: {mult: num => { return num * 3 }}}
```


[:arrow_upper_left: back to top](#table-of-contents)
