"use strict";

/* eslint-disable max-statements */
const Logger = require("@walmart/electrode-logging");
const transaction = require("@walmart/electrode-log-transaction");
const txConst = require("@walmart/electrode-log-transaction/lib/constants");
const logSymbols = require("@walmart/electrode-logging/lib/symbols");
const fyi = require("@walmart/electrode-fyi");
const WM_CORR_HEADER = require("@walmart/electrode-wml-soa").wmHeaders.corrId;
const LIMIT_MEMO_LOG = 100;

require("@walmart/electrode-npm-singleton")(`${__dirname}/..`);

const fyiError = fyi.limitError("electrode-logging-plugin", LIMIT_MEMO_LOG);

const injectContext = (request, data) => {
  if (data === undefined || data === null) {
    data = {};
  }

  if (typeof data !== "object") {
    data = { msg: data };
  }

  // if there's no transaction context set in the data, then try to set it
  // to the main thread in request
  if (!data[txConst.context] && request[txConst.mainThread]) {
    data[txConst.context] = request[txConst.mainThread];
  }

  data[logSymbols.request] = request;

  return data;
};

function logging(server, options, next) {
  const config = server.app.config.logging;
  const logger = new Logger(config);
  const txDisabledByConfig = config.disableTransactions;
  const wmCorrHeader = WM_CORR_HEADER.toLowerCase();

  // memoizing new Loggers that are created from logging prehandler
  const memoLoggers = {};
  // keep track of memoIds without their associated logger to send as
  // availableMemoIds
  const memoIds = {};
  let totalMemoLoggers = 0;
  const transactionsDisabled = req => req.app.disableTransactions || txDisabledByConfig || false;

  // wrap requests in top-level transaction
  server.ext("onRequest", (request, reply) => {
    const corrHeader = request.headers && request.headers[wmCorrHeader];

    const disableTx = transactionsDisabled(request);

    if (corrHeader) {
      transaction.setReferredContext(request, corrHeader);
    }

    const logData = {
      msg: "Request received",
      [logSymbols.request]: request
    };

    if (config.verboseRequest) {
      logData.$ = { verbose: true };
    }

    if (disableTx) {
      request[txConst.mainThread] = request[txConst.referredContext];
      request.app.disableTransactions = true;
      logger.log(["info"], logData);
      return reply.continue();
    }

    // start a top transaction.
    // expect the context to be set in request with symbol key mainThread
    const context = transaction.beginTop(request, logData);

    // Set the request specific context
    request.app.correlationId = context.toHeader();

    return reply.continue();
  });

  server.ext("onPreResponse", (request, reply) => {
    const headers = request.response && request.response.headers;
    const context = request[txConst.mainThread];

    if (headers && context) {
      if (!request.app.correlationId) {
        headers[WM_CORR_HEADER] = context.toHeader();
      } else {
        headers[WM_CORR_HEADER] = request.app.correlationId;
      }
    }

    reply.continue();
  });

  server.on("response", request => {
    const context = request[txConst.mainThread];
    const logData = {
      msg: "Response",
      [logSymbols.request]: request,
      [logSymbols.response]: request.response
    };

    if (config.verboseResponse) {
      logData.$ = { verbose: true };
    }

    if (context && !transactionsDisabled(request)) {
      context.end(logData);
      if (!context.isRunning()) return; // logged as transaction
      logData.txPending = true;
    } else {
      logData.noTx = true;
    }

    // didn't log as a transaction end, so log it as normal entry
    request.log(["info"], logData);
  });

  // server.log
  server.on("log", event => {
    logger.log(event.tags, event.data);
  });

  // sets request.app.loggerId
  const sendPrehandler = (request, tags, data) => {
    const prehandlerOptions = {
      defaults: logger.defaultSerializers,
      overrides: logger.serializers,
      availableMemoIds: memoIds
    };
    config.prehandler(request, prehandlerOptions, (cbobj = {}, memoId) => {
      // handle the cb("beep") case where they have checked availableMemoIds and
      // identified it as existing in memoLoggers
      if (typeof cbobj === "string" && memoId === undefined) {
        if (memoLoggers[cbobj]) {
          data.memoId = cbobj;
          return memoLoggers[cbobj].log(tags, data);
        } else {
          return logger.log(tags, data);
        }
      }
      if (memoId === undefined) {
        throw new Error("electrode-logging-plugin: memoId is required for prehandler");
      }
      // this has to check in here instead of at the plugin on "request" level
      // because within the same request, request.log(...) can be called multiple times
      // and each time the prehandler could specifiy different memoIds
      if (memoLoggers[memoId]) {
        data.memoId = memoId;
        return memoLoggers[memoId].log(tags, data);
      }

      if (totalMemoLoggers >= LIMIT_MEMO_LOG) {
        fyiError(
          `electrode-logging-plugin: too many memo loggers ${memoId} ` +
            `count exceeds LIMIT_MEMO_LOG: ${LIMIT_MEMO_LOG}`
        );
        return logger.log(tags, data);
      }
      const include = cbobj.include || logger.userSpecifiedConfigInclude || [];
      const exclude = cbobj.exclude || logger.userSpecifiedConfigExclude || [];
      // we merge just with user specified config serializers.
      const mergedSerializer = Object.assign(
        {},
        logger.userSpecifiedConfigSerializers,
        cbobj.serializers
      );
      const newConfig = Object.assign({}, config, {
        serializers: mergedSerializer,
        include,
        exclude
      });
      memoLoggers[memoId] = new Logger(newConfig);
      totalMemoLoggers = Object.keys(memoLoggers).length;
      // keep track of the memoIds so we can pass them as availableMemoIds
      memoIds[memoId] = true;
      return memoLoggers[memoId].log(tags, data);
    });
  };

  server.on("request", (request, event) => {
    const data = injectContext(request, event.data);

    if (config.prehandler) {
      return sendPrehandler(request, event.tags, data);
    } else {
      return logger.log(event.tags, data);
    }
  });

  // internal framework events - default to trace
  server.on("request-internal", (request, event) => {
    const tags = event.tags.concat("trace");
    const data = injectContext(request, event.data);
    logger.log(tags, data);
  });

  // emitted when 500 response is sent to client
  server.on("request-error", (request, err) => {
    const logData = {
      err: err,
      [txConst.context]: request[txConst.mainThread],
      [logSymbols.request]: request,
      [logSymbols.response]: request.response
    };

    logger.log(["error"], logData);
  });

  next();
}

logging.attributes = {
  pkg: {
    name: "logging"
  }
};

module.exports = logging;
