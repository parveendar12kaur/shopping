# electrode-log-transaction

Provides an interface to instrument with structured transaction log entries defined by WML Logmon. With transaction logs, you can have nested logging entries that are tied together with transaction IDs.  These can be used for adding extra information to application logs and generating correlation headers for downstream requests.

# Sample Usage

```javascript
const transaction = require("@walmart/electrode-log-transaction");

const myHandler = function(request, reply) {
  const context = transaction.beginCall(request, "starting call");
  context.run((context) => {
    doSomething();
  })
  .finally(() => {
    context.end("done with call")
  })
};
```

# Install

```bash
npm i --save @walmart/electrode-log-transaction
```

# Example diagram of transaction ids
```javascript
    Request :
    {
        txId: 'aa4ff50b-32e-1600f53e8cb0de'
    }

      // then within that request handler, suppose we do a fetch
      First Child Fetch : {
          topTxId: 'aa4ff50b-32e-1600f53e8cb0de',
          parentTxId: 'aa4ff50b-32e-1600f53e8ccde2',
          txId: 'aa4ff50b-32e-1600f53e8ccde2'
      }
```

So this means the request is the "top" context and that children inside will refer to that context by "topTxId".

# So how do I see all transactions for a given top context in Splunk?

So suppose you have a `topTransactionId` that is equal to "fe359f50-c49-1600f7f47f0213". Then this is the key part of the Splunk query that you can use to retrieve all transactions within a top context (from the top including its children)

    ("context.topTxId"="fe359f50-c49-1600f7f47f0213" OR "context.txId"="fe359f50-c49-1600f7f47f0213")

So, an actual Splunk query would look something like

    index="electrode" source="/log/splunk/*" tenant="products" AND
    ("context.topTxId"="fe359f50-c49-1600f7f47f0213" OR "context.txId"="fe359f50-c49-1600f7f47f0213")


# Threads

See [document here](./THREADS.md) for details on transaction threads.

# APIs

### `beginTop([context|request], msg)`

Starts a new top level transaction, `P-START` and return the transaction context.

Developers must provide a root context (either request or context object).

### `beginCall(msg)`

Starts a new call transaction, `C-START` and return the transaction context.

### `beginReference(msg, function)`

Starts a new reference transaction, `R-START` and return the transaction context.

# Context Methods

### `end(msg)`

Ends the transaction running within context. If any nested transactions have not completed this will throw.

### `fail(msg)`

Fails the current transaction - ends it and marks it as failed. If any nested transactions have not completed this will throw.
