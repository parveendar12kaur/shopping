"use strict";

/* eslint-disable max-statements */

const _ = require("lodash");
const types = require("./transaction-types");
const TransactionState = require("./transaction-types").TransactionState;
const Logmon = require("@walmart/electrode-logmon");
const injectContext = require("./inject-context");
const Promise = require("bluebird");
const config = require("./config");
const constants = require("./constants");
const fyi = require("@walmart/electrode-fyi");

const getClientId = _.once(() => {
  return _.random(1, 0xffffffff); // eslint-disable-line no-magic-numbers
});

const getNewId = function() {
  return Logmon.getTxIdSync({ clientId: getClientId() });
};

const ud = (v, d) => (v === undefined ? d : v);
const udf = (v, df) => (v === undefined ? df() : v);

class Context {
  constructor(options) {
    fyi.assert(options && options.req, "electrode-transaction: creating context without request");
    // Symbol fields (hidden)
    this[constants.contextData] = {
      request: options.req,
      // children are added with unique Symbols labeled with class ID
      children: {},
      parent: options.parent
    };

    // BEGIN nominal transaction related fields
    this.sessionId = udf(options.sessionId, getNewId);
    this.topTxId = udf(options.topTxId, getNewId);
    this.isTopLevel = Boolean(options.isTopLevel);

    if (this.isTopLevel) {
      this.txId = this.topTxId;
      this.parentTxId = this.topTxId;
    } else {
      this.txId = udf(options.txId, getNewId);
      this.parentTxId = options.parentTxId;
    }

    this.state = ud(options.state, TransactionState.RUNNING);
    this.level = ud(options.level, 0);
    this.duration = ud(options.duration, "-");
    this.start = ud(options.start, Date.now());
    this.subtype = options.subtype;
    // END nominal transaction related fields
  }

  get data() {
    return this[constants.contextData];
  }

  get req() {
    return this.data.request;
  }

  set req(v) {
    this.data.request = v;
  }

  get parent() {
    return this.data.parent;
  }

  set parent(parent) {
    this.data.parent = parent;
  }

  get children() {
    return this.data.children;
  }

  set children(children) {
    this.data.children = children;
  }

  get pendingComplete() {
    return this.data.pendingComplete;
  }

  set pendingComplete(state) {
    this.data.pendingComplete = state;
  }

  static fromHeader(cid, req) {
    const options = { req };

    if (cid && cid.length) {
      const tokens = cid.split(",");
      let i = 0;

      /* eslint-disable no-magic-numbers */
      if (tokens.length === 5) {
        // tenantId, ignore
        i++;
      }
      if (tokens.length >= 4) {
        // requestId, ignore
        i++;
      }
      if (tokens.length >= 3) {
        options.sessionId = tokens[i++];
      }
      if (tokens.length >= 2) {
        options.topTxId = tokens[i++];
      }
      /* eslint-enable no-magic-numbers */

      options.txId = tokens[i++];
    }

    return new Context(options);
  }

  static createTopLevelContext(req, type) {
    const referredContext = req && req[constants.referredContext];

    if (referredContext) {
      return referredContext.createChildContext(type);
    } else {
      return new Context({ isTopLevel: true, subtype: type, req });
    }
  }

  createChildContext(subtype, classId) {
    const child = new Context({
      sessionId: this.sessionId,
      topTxId: this.topTxId,
      parentTxId: this.txId,
      level: this.level + 1,
      subtype,
      parent: this,
      req: this.req
    });

    const sym = Symbol(classId || "no class id child transaction");

    this.children[sym] = child;

    return child;
  }

  // Returns the string representation of this context
  // in WM_QOS.CORRELATION_ID format
  toHeader() {
    let header = "";

    if (this.topTxId !== null) {
      if (this.sessionId !== null) {
        header = header.concat(this.sessionId, ",");
      }
      header = header.concat(this.topTxId, ",");
    }

    header = header.concat(this.txId);

    return header;
  }

  isRunning() {
    return this.state === TransactionState.RUNNING;
  }

  cacheSubtype() {
    // preserve the subtype after calling log to prevent
    // intermediate logging calls from propogating subtype
    this.cachedSubtype = this.subtype;
    this.subtype = "-";
  }

  _onComplete(state, msg) {
    if (!this.isRunning()) return;

    if (this.pendingComplete !== undefined) {
      if (this.pendingComplete === false) return;
      if (!this.childrenFinished(true)) return;

      state = this.pendingComplete.state;
      msg = this.pendingComplete.msg;

      this.pendingComplete = false;
    } else if (state === undefined) {
      return;
    }

    // map to the appropriate end type
    this.subtype = types.mapBeginToEnd[this.cachedSubtype];
    this.duration = Date.now() - this.start;
    this.state = state;

    // log tx end
    this.req.log(["info"], injectContext(this, msg));

    if (this.parent) this.parent._onComplete();
  }

  complete(state, msg) {
    if (this.pendingComplete !== undefined || !this.isRunning()) return;

    state = state || TransactionState.FINISHED;

    if (!this.childrenFinished(true)) {
      this.pendingComplete = { state, msg };
      return;
    }

    this._onComplete(state, msg);
  }

  childrenFinished(isTop) {
    if (!isTop && this.isRunning()) {
      return false;
    }

    const syms = Object.getOwnPropertySymbols(this.children);
    return _.every(syms, s => this.children[s].childrenFinished());
  }

  setError(err) {
    this.req.log(["error"], {
      context: this,
      msg: "electrode-transaction context run caught exception",
      err
    });
    this.data.runError = err;
  }

  run(functor, options) {
    options = options || {};

    return Promise.try(() => {
      const args = [this];
      return functor.apply(
        options.context,
        options.arguments !== undefined ? args.concat(options.arguments) : args
      );
    }).catch(err => {
      this.setError(err);
      throw err;
    });
  }

  end(msg) {
    this._end(msg, TransactionState.FINISHED);
  }

  fail(msg) {
    this._end(msg, TransactionState.ERROR);
  }

  _end(msg, state) {
    try {
      this.complete(state, msg);
    } catch (error) {
      if (config.throwOnError || !this.req) {
        throw error;
      } else {
        this.req.log(["warn"], {
          msg: `electrode-transaction: Error ending context: ${msg}`,
          err: error
        });
      }
    }
  }
}

module.exports = Context;
