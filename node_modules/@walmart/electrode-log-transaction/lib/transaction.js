"use strict";

/* eslint-disable max-params, no-magic-numbers */

const _ = require("lodash");
const Context = require("./context");
const TransactionSubtype = require("./transaction-types").TransactionSubtype;
const injectContext = require("./inject-context");
const config = require("./config");
const constants = require("./constants");
const fyi = require("@walmart/electrode-fyi");
const noopContext = require("./noop-context");

const fyiError = fyi.limitError("electrode-log-transaction", 50);

/* eslint-disable max-statements */

const _beginTransaction = options => {
  const msg = options.msg;
  const type = options.type;
  const parent = options.parent;
  let context;
  let req;

  if (parent.createChildContext && parent.data) {
    fyi.assert(parent.data.request, "electrode-transation: parent context doesn't have req");
    context = parent.createChildContext(type, options.classId);
    req = parent.data.request;
  } else {
    // assume request
    req = parent;
    fyi.assert(
      !req[constants.mainThread],
      "electrode-transaction: beginCall/beginTop invoked with request already contain main thread"
    );
    context = Context.createTopLevelContext(req, type);
    req[constants.mainThread] = context;
  }

  // log beginning of transaction
  req.log(["info"], injectContext(context, msg));

  context.cacheSubtype();

  return context;
};

const handleClassId = classId => {
  fyi.assert(classId, "electrode-transaction: no transaction classId given");

  const extractIdOnly = x => x.substring(7, x.length - 1);

  if (typeof classId === "symbol") {
    // in case the Symbol was passed
    classId = classId.toString();
  } else if (!classId.startsWith(`Symbol(`)) {
    return {
      id: classId,
      symId: `Symbol(${classId})`
    };
  }

  return {
    id: extractIdOnly(classId),
    symId: classId
  };
};

const searchClassParent = (req, classId, stopForSame) => {
  if (req[constants.contextData]) {
    // it's actually a context
    return req;
  }
  const search = context => {
    const childrenKeys = Object.getOwnPropertySymbols(context.children);
    let j;
    let nonLeafContext;

    // search backward to find a non-leaf class type
    for (j = childrenKeys.length - 1; j >= 0; j--) {
      const x = childrenKeys[j].toString();
      // any children already in the same class?
      if (x === classId) {
        if (stopForSame) {
          return context;
        }
      } else if (!nonLeafContext && x.indexOf(constants.leafMarker) < 0) {
        nonLeafContext = context.children[childrenKeys[j]];
      }
    }

    // no same class child found but a non-leaf context found
    if (nonLeafContext) {
      return search(nonLeafContext);
    }

    // finally use context
    return context;
  };

  return search(req[constants.mainThread]);
};

const Lib = {};

module.exports = Object.assign(Lib, {
  // Begin a new top level transaction with type P-START
  beginTop: (parent, msg) => _beginTransaction({ parent, type: TransactionSubtype.P_START, msg }),
  // Begin a new call transaction with type C-START
  beginCall: (parent, msg) => _beginTransaction({ parent, type: TransactionSubtype.C_START, msg }),
  // Begin a new reference transaction with type R-START
  beginReference: (parent, msg) =>
    _beginTransaction({ parent, type: TransactionSubtype.R_START, msg }),

  //
  // Sets the context stack with an inbound correlation header. If a
  // referredContext has already been set then this call is ignored.
  //
  setReferredContext: (req, corrHeader) => {
    fyi.assert(req, "electrode-transaction setReferredContext: Cannot set without req");
    fyi.assert(
      corrHeader,
      "electrode-transaction setReferredContext: Cannot set with falsy corrHeader"
    );

    if (req[constants.referredContext]) return;

    const referredContext = Context.fromHeader(corrHeader, req);

    req[constants.referredContext] = referredContext;
  },

  getMainThread: req => req[constants.mainThread],

  getReferredContext: req => {
    return req[constants.referredContext];
  },

  getContext: req => req[constants.context],

  clearReferredContext: req => {
    req[constants.referredContext] = undefined;
  },

  setConfig: options => {
    Object.assign(config, options);
  },

  //
  // auto insert a transaction into main thread
  // classId - string id for transaction classification
  // msg - message to log for the begin transaction entry
  // ignoreSame - if true, then don't add new transaction alongside others of the same class
  //
  addCall: (req, classId, msg, ignoreSame) => {
    if (_.get(req, ["app", "disableTransactions"])) {
      return noopContext();
    }
    if (!Lib.getMainThread(req) && !req[constants.contextData]) {
      fyiError("request doesn't have a main transaction thread, can't add call to it.");
      return noopContext();
    }
    classId = handleClassId(classId);
    return _beginTransaction({
      parent: searchClassParent(req, classId.symId, !ignoreSame),
      type: TransactionSubtype.C_START,
      msg,
      classId: classId.id
    });
  }
});
