# Transaction Log Threads

## Introduction

Since transactions can be nested, theorectically the following is possible:

```markdown
BEGIN top level tx
  BEGIN tx level 1 thread 1
    level 1 thread 1 messages
  BEGIN tx level 1 thread 2
    level 1 thread 2 messages
    BEGIN tx level 2 thread 1
      level 2 thread 1 messages
    END tx level 2 thread 1
  BEGIN tx level 1 thread 3
    tx level 1 thread 3 messages
  END tx level 1 thread 1
  END tx level 1 thread 2
  END tx level 1 thread 3
END toop level tx
```

As demonstrated, transactions can be nested with multiple levels.  Each level can spawn multiple concurrent threads.

Supporting this in a generic manner with a stack in a synchronous language is easy.  With JavaScript and its async nature, it's near impossible.  We attempted to do it with [continuation-local-storage] and it was extremely unstable with a lot of problems.  Ultimately we had to drop CLS and opt for a limited API that doesn't really support abitrary generic transaction nesting and threads.

Without CLS, we can still offer limited nesting support, but it requires some manual passing and managing of the transaction context.

## System Thread

Electrode Platform will always start a top level system thread for each incoming request.

## Your own top level thread

While a request object is required to make the context, the transaction implementation in this module is agnostic of a server request object.  You can start your own top level transaction that's not nested in another transaction.  However, given that the request holds all the relevant information, creating your own detached top level transaction doesn't make a lot of sense.  If you have a use case for doing this, please consult with Electrode team about it.

### Starting a thread without context

If you were called without a transaction context, then you can start one inside the system thread.

You can start one with the following parameters:

-   A child transaction nested at the first level, alongside other existing nested transaction at that level.
-   Nested inside the last child at the deepest level.
-   Roll you own filter to determine which child of a level to follow and at what level you want your transaction to go into.

## Referred Context

One of the features of the transaction logs allows referring a context to another remote service.  It's possible that another could invoke your web server with a HTTP header that contains the transaction IDs.  In this case, the top level transaction is created with these IDs as references so you can tie a thread of them across multiple services.

The Electrode platform handles this automatically and you don't really need to do anything extra to get the feature.

[continuation-local-storage]: https://github.com/othiym23/node-continuation-local-storage

## Transaction IDs

A transaction can have three IDs:

-   Transaction ID - This is the ID of a given transaction
-   Parent Transaction ID - This is the ID of the transaction one level up
-   Top Transaction ID - This is the ID of the transaction at the top (level 0)
-   Session ID - This is the ID of a session which would tie all transactions together.

## Adding To a thread

### Transaction Classification

Without a general stack, nesting transactions can only be achieved by passing the context manually.

Classification transactions is purely an internal mechanism to allow some way of automatically inserting transactions without requiring a manual tracking and passing the context everywhere.

A simple search algorithm will be used to determine where a new transaction would be inserted without a context.

The ID for a class of transactions must be unique.

### Inserting a new transaction

Without any context, the following algorithm will be used to search and insert a transaction into the main thread.

-   Each transaction context can hold children in an object
-   Each child is added to the children container object with a unique Symbol key
-   Each context remembers its own unique symbol key
-   User can start a new transaction using an existing key or unique classfication (ie. `"@leaf electrode-swapi transaction"`)
    -   Will search main thread for a child with similar class at each level
    -   If one is found, then a new unique key for that class is created
    -   Child is then added alongside existing one at the same level
    -   If last level is reached with no similar class child found, then a new nested level is created within the last existing child
    -   If no children exist in the last level, then it's created at that level
    -   The search only follow the last child if a level doesn't already contain one with smilar class id

### Marking a classification as leaf

Some transactions may generally be known not to be a candidate for having nested children.  To avoid the search adding child to it, the class id can have a token to mark it as a leaf transaction.

If a class id contains the token `@leaf`, then it will be skipped for inserting child transactions.

If a level only contains leaf transactions, then a new one is insert within the same level.

### Example

Example:

-   Electrode-swapi will create a transaction with classification as `"@leaf electrode-swapi tranaction"`.
-   When electrode-swapi is ready to make a service call, it calls `addCall` with `request` object and the class id.
-   We will look at the main thread within `request`.

Current main thread could look like this:

```markdown
BEGIN top
  BEGIN redux store retrieval
```

> Note there's no END tags yet because transactions are still in progress.

-   electrode-swapi's `addCall` will find no transaction with class id `"@leaf electrode-swapi transaction"`
-   The inner most level has only a single transaction `"redux store retrieval"`
-   A new child is appended to that transaction and the new thread looks like this:

```markdown
BEGIN top
  BEGIN redux store retrieval
    BEGIN @leaf electrode-swapi transaction
```

-   electrode-swapi makes another call while the first one is still in flight and calls `addCall`
-   The search finds the `"redux store retrieval"` transaction has a child with the same class
-   A new child is added at the level alongside others

```markdown
BEGIN top
  BEGIN redux store retrieval
    BEGIN @leaf electrode-swapi transaction
    BEGIN @leaf electrode-swapi transaction
```

### Usage

Obviously the applicability of this mechanism is extremely limited.  However, for the most general usage patterns, it's observed that applications only create a transaction thread that has a single linear nesting child objects.
For that scenario, this mechanism would work well for automatically inserting transactions without a parent context being passed.

For any more complex requirements, the application will need to manually manage and pass context from one level to another in order to maintain the proper nesting transactions it requires.
