# Redux Router Engine

An electrode routing and rendering engine for `react-router` + `redux`. Which follows the standard [Redux server rendering and bootstrapping pattern](http://redux.js.org/docs/recipes/ServerRendering.html).

### Install

`npm install --save @walmart/electrode-redux-router-engine`

### Config

In order to wire up an electrode/Redux app for server rendering you need to config the [`electrode-react-webapp`](https://gecgithub01.walmart.com/electrode/electrode-react-webapp) Hapi plugin.

```js
// config/default.json
...
"@walmart/electrode-react-webapp": {
  "paths": {
    "/{args*}": {
      "view": "index",
      "content": {
        "module": "./server/app"
      }
    }
  }
}
...
```

### Example Usage

We've configured electrode-react-webapp to use ./server/app to render all routes ("/{args\*}") server side. To wire up the routes to render with reduxRouterEngine we need to set req.server.app.routesEngine to reduxRouterEngine.

```js
// server/app.js
const reduxRouterEngine = require("@walmart/electrode-redux-router-engine");
const Promise = require("bluebird");

const routes = require("../client/routes");
const boostrapApp = require("../client/actions").bootstrapApp;
const configureStore = require("../client/store").configureStore;

module.exports = (req) => {
  if (!req.server.app.routesEngine) {
    // reduxRouterEngine takes routes and a callback to initialize a store asynchronously.
    req.server.app.routesEngine = reduxRouterEngine(routes, () => {
      const store = configureStore();

      return Promise.all([
        store.dispatch(boostrapApp())
        // dispatch any other asynchronous actions here
      ]).then(() => {
        return store;
      });
    });
  }

  return req.server.app.routesEngine(req);
};
```

### reduxRouterEngine(routes, fn, options)

ReduxRouterEngine takes React routes and requests and returns HTML to be rendered by electrode-react-webapp.

#### routes

React element containing application routes.

```jsx
<Route path="/test" component={Page}>
 <IndexRoute component={Home}/>
 <Redirect from="source" to="target" />
</Route>
```

#### fn

A callback which returns a promise which resolves to a store.

```js
{
  const store = configureStore();

  return Promise.all([
    store.dispatch(boostrapApp())
    // dispatch any other asynchronous actions here
  ]).then( () => {
    return store;
  });
}
```

This is the pattern for using [redux asynchronous actions](http://redux.js.org/docs/advanced/AsyncActions.html).

#### options

a value or an object to configure the route engine.
If options is a single value it means **renderWithIds**. If an object is passed then it should have one or more of the below properties:

-   `renderWithIds` (boolean) The value to be shown in the browser's title bar
-   `logSsrTime` (boolean) Will enable the logging of the SSR time
-   `filterState` (function) allow to filter what properties you want to have passed to the client side as Initial value for the store
-   `ssrCache` (object) An object that provided caching for the SSR result

## SSR Cache

You can provide an `options.ssrCache` to support caching SSR result.

It must contains at least two methods:

-   `get(options)` - get cache, should return a `Promise` that resolves to the result from the cache.  `undefined` if no cache entry.
-   `set(options)` - set cache, should cache the SSR result in `options.html`.

`options` will contain

-   `{ req, store, match }` for `get`
-   `{ req, store, match, html }` for `set`

Where:

-   `req` - Web Server request object
-   `store` - Redux store
-   `match` - React router route match object
-   `html` - React `renderToString` output
