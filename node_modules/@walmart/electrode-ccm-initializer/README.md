# electrode-ccm-initializer

This is the NodeJS manager and provider for the WalmartLabs CCM (Cloud Config Management) service.

A Hapi plugin is available to initialize and refresh CCM configs periodically. This is included in [electrode-wml-server] by default, but it's not enabled. You need to enable it in your app config.

You also need to install and setup [electrode-ccm-client] for calling the CCM service endpoints.

## Table of Contents

* [Installing](#installing)
* [Setup](#setup)
  * [CCM Client](#ccm-client)
  * [Quimby Client](#quimby-client)
  * [Setup CCM in your app config](#setup-ccm-in-your-app-config)
* [Accessing the Retrieved CCM Data](#accessing-the-retrieved-ccm-data)
  * [await ccmReady](#await-ccmready)
  * [The `request.app.ccm` API](#the-requestappccm-api)
  * [The config data store object](#the-config-data-store-object)
  * [Browser Side Access](#browser-side-access)
* [Configuration](#configuration)
* [Specifying the CCM `keys` Object](#specifying-the-ccm-keys-object)
  * [Simple and Typical](#simple-and-typical)
    * [Without Profiles](#without-profiles)
    * [With Profiles](#with-profiles)
    * [Avoid Profile and Data name conflicts](#avoid-profile-and-data-name-conflicts)
  * [All the glory details](#all-the-glory-details)
  * [More comprehensive sample](#more-comprehensive-sample)
* [White List Filtering For The Browser](#white-list-filtering-for-the-browser)
* [Configuration That You Should Not Mess With](#configuration-that-you-should-not-mess-with)
* [The Hapi Plugin](#the-hapi-plugin)

## Installing

```bash
npm i @walmart/electrode-ccm-initializer
```

## Setup

### CCM Client

The CCM Initializer requires [electrode-ccm-client] to communicate with the CCM server. Please see [CCM Client Setup] to set it up in your application.

### Quimby Client

To support experimentation, you also need to add [@walmart/electrode-quimby-client] to your `dependencies` and add the following to your `config/default.js[on]`:

```
{
  "services": {
    "providers": {
      "@walmart/electrode-quimby-client": {}
    }
  }
}
```

### Setup CCM in your app config

As is, the initializer will retrive nothing from CCM. You have to tell it what to retrieve.

In your app config, you specify what CCM keys you want CCM initializer to retrieve and refresh for you.

**_IMPORTANT_**: CCM Initializer is default to off in [electrode-wml-server]. To turn it on, you must set the option `config.ccm.autoLoad` to `true`.

**_IMPORTANT_**: Nothing from CCM is sent to the browser by default. To get CCM config to the browser, you need to [add white list filtering rules to your app config](#white-list-filtering-for-client)

See [configuration](#configuration) for more details.

## Accessing the Retrieved CCM Data

### await ccmReady

CCM retrieval should not block your app's request lifecycle. So that's done async and allow request to continue and you can kick off any async work your app needs.

When eventually your app knows it must have CCM, you should wait for the `req.app.ccmReady` promise.

ie:

```js
await req.app.ccmReady;

const ccmFlag = req.app.ccm("appControl.guestCheckoutEnabled");
```

Or as promise API:

```js
req.app.ccmReady.then(() => {
  const ccmFlag = req.app.ccm("appControl.guestCheckoutEnabled");
});
```

### The `request.app.ccm` API

On server side when using Hapi, the CCM configuration data retrieved can be accessed through a function `request.app.ccm`. This function will lookup CCM configs specific for the `request`. If the request contains A/B test assignments through Expo, this will return the configuration data as overriden for any application experiment variations.

The function `request.app.ccm` takes a single argument `path` that can be a string of dot separated JSON path or an array or strings.

For example:

```js
const guestEnabled = request.app.ccm("appControl.guestCheckoutEnabled");
const guestCheckbox = request.app.ccm(["appControl", "showGuestMarketingCheckbox"]);
```

### The config data store object

The CCM default config values are stored in an object as `server.app.ccm` or `request.server.app.ccm`

> It's not recommended, however, you can access these directly. **Note that Expo A/B testing overrides are not supported with these objects.**

### Browser Side Access

On browser side, a filtered copy of the config is available in an object as `window._wml.config.ccm`, you can access this isomorphically through the module [electrode-ui-config].

For example:

```js
import Config from "@walmart/electrode-ui-config";
// data is available in Config.ccm
const guestEnabled = Config.ccm.appControl.guestCheckoutEnabled;
```

## Configuration

The initializer takes these options from your app configs. Below is an example to retrieve `/atlas-checkout/app-control` configurations.

```js
{
  ccm: {
    autoLoad: true,
    supportExperiments: true,

    sources: [ "defaults", "snapshot", "service" ],

    "keys": {
      "root": {
        profiles: {
          default: {
            environment: "qa"
          }
        }
        data: {
          "appControl": {
            "serviceName": "atlas-checkout",
            "+configNames": [
              "app-control"
            ]
          }
        }
      }
    },

    defaults: {
      "appControl": {
        "enableRememberMe": "false",
        "enableUpsellDeliveryOption": "false",
        "expandablePromotions": "true",
        "expandedRCF": "false",
        "forgotPassword": "true",
        "guestCheckoutEnabled": "false"
      }
    },

    uiFilter: {
      "$.appControl": [ "guest.*", "forgot.*" ]
    }
  }
}
```

* `autoLoad` - Must specify to true to enable CCM Initializer

* `supportExperiments` - Set to `false` to turn off support for experiment specific CCM config. **_Default_**: `true`

* `sources` - An array to tell CCM initializer where to load CCM data.

  * `defaults` - the default you set in your app config.
  * `snapshot` - config retrieved from CCM servers saved to disk.
  * `service` - actually retrieving config from CCM servers.

* `keys` - Specify the CCM key objects you want the initializer to retrieve CCM config from CCM service

* `defaults` - Optional object to specify default values

* `uiFilter` - JSON path and regular expression rules to filter configs to be sent to the browser.

## Specifying the CCM `keys` Object

### Simple and Typical

For the typical CCM use and recommendation, you should only have a `root` section.

#### Without Profiles

If you don't have the `profiles` or just a `default` profile, then don't use the `profileName` in your config access path.

For the example above, you can access configs from that with the JSON path:

> `<dataName>.[CCM config key]`.

For example, in the config above, to access the `/atlas-checkout/app-control` configs, use the path `appControl.enableRememberMe`.

#### With Profiles

If you have profiles, then you have to access them with the JSON path:

> `<profileName>.<dataName>.[CCM config key]`

If you still want to have one profile that can be accessed without the `<profileName>` part, you can name the profile `root`.

#### Avoid Profile and Data name conflicts

Please note that since you can have a profile named `root` be accessed without the `<profileName>` part, you can't have any `<dataName>` that's the same as any of your other profile names.

### All the glory details

If for some reason your need goes beyond the typical usage pattern CCM team recommends, you can configure multiple groups with different `scopeTemplate` and profiles.

As you can see in the example below, the `keys` object is very flexible such that you can specify different groups, each with its own profiles and data you want to retrieve configs from CCM.

The data retrieved can be accessed with the following path:

`<groupName>.<profileName>.<dataName>.[CCM config key values]`

* You can have a special group with its name as `root` so `<groupName>` is not necessary to access that group.

  * ie. The group named `root` is accessed through `<profileName>.<dataName>.[...]`

* You can have a `default` profile that only serve to have its settings apply as defaults to all other profiles in the same group

* `profiles` is optional. If you don't have a profile section or if it contains no profile or only the `default`, then the `<profileName>` part is not needed.

* You can specify a `scopeTemplate` in the following objects:

  * `config.ccm.scopeTemplate`, each `config.ccm.<groupName>.scopeTemplate`, and each profile in the group, ie: `config.ccm.<group>.<profileName>.scopeTemplate`

  * Each inner one overrides the outer one, so `config.ccm.<group>.<profileName>.scopeTemplate` is used if it's defined.

* `serviceName` in each `data` object is required.

* The array of config names is specified with the key `+configNames`. The `+` indicates that this array in the same config path from different config sources will be unioned into a single one.

### More comprehensive sample

Here is a more comprehensive sample config to show the use cases described above. It specifies three config groups: `root`, `groupA`, and `groupB`.

* `root` can be accessed without the group name.
* `groupA` and `groupB` must be accessed with the JSON path `groupA.default.configurationSetting1`

```js
{
  ccm: {
    "keys": {

      "root": {
        profiles: {
          default: {
            environment: "qa"
          }
        },
        data: {
          "atlasProd": {
            "serviceName": "atlas-product",
            "+configNames": [
              "groupingsClient"
            ]
          }
        }
      },

      "groupA": {
        "scopeTemplate": "/{tenantid}/{environment}/{cloudEnvironment}/{deviceType}/{node}",
        "profiles": {
          "default": {
            "tenantid": "01",
            "environment": "stg"
          },
          "mobile": {
            "deviceType": "mobile"
          },
          "desktop": {
            "deviceType": ""
          }
        },
        "data": {
          "atlasP13n": {
            "serviceName": "atlas-p13n",
            "+configNames": [
              "irsConfig"
            ]
          }
        }
      },

      "groupB": {
        "data": {
          "atlasXO": {
            "serviceName": "atlas-checkout",
            "+configNames": [
              "guest-checkout",
              "responsive-config",
              "opinion-lab"
            ]
          },
          "atlasApi": {
            "serviceName": "atlas-api",
            "+configNames": [
              "checkout"
            ]
          }
        }
      }
    }
  }
}
```

From the config above, after CCM Initializer retrieve the configs, you can access them through:

* `atlas-product` configs with the path `atlasProd.<configName>` (no `<groupName>` since the name is `root`)
* `atlas-p13n` for mobile with the path `groupA.mobile.atlasP13n.<configName>` and for desktop in `groupA.desktop.atlasP13n.<configName>`
* `atlas-checkout` configs with the path `groupB.atlasXO.<configName>`
* `atlas-api` configs with the path `groupB.atlasApi.<configName>`

## White List Filtering For The Browser

Your CCM config will be sent to the browser by the [index template] but you must specify white list filtering rules `config.ccm.uiFilter`, otherwise nothing will be sent.

The filtering rule is base on [JSON path]. You specify a jsonpath that reaches the CCM config object you want to send, and you specify [regex] to match the keys in that object to be sent.

For example, to send the `atlasXO` config object in the [example above](#more-comprehensive-sample):

`atlasXO` would be accessible through the path `groupB.atlasXO`.

You can reach that object with the JSONPath `$.groupB.atlasXO` or `$..atlasXO` if `atlasXO` is unique.

If you want to send from `atlasXO` any config with keys start with `enable_guest` and `percent_users`, then the regex to match them are `enable_guest.*` and `percent_users.*`. So your filtering config would be:

```js
{
  "ccm": {
    "uiFilter": {
      "$.groupB.atlasXO": [ "enable_guest.*", "percent_users.*" ]
    }
  }
}
```

After CCM is retrieved, the filtered copy is stored in `server.app.uiCCM` or the request specific one `request.app.uiCCM`. It will be automatically sent to the browser by the [index template]

## Configuration That You Should Not Mess With

There are a few configuration options that you can change if you know what you are doing, but generally this is just FYI, please don't specify them so the defaults will be used.

```js
{
  ccm: {
    snapshot: {
      dir: "/path/to/dir/to/store/snapshot";
    }
  }
}
```

However, if you want and know what you are doing, you can turn off snapshot by setting it to `false`.

## The Hapi Plugin

This Hapi plugin registers a route `/electrode/services/ccm/refresh`, which [electrode-wml-server] invokes every minute.

This route does following things in sequence:

1.  Check if CCM has been initialized or if changes has been made on the servers

2.  If refresh is needed, then invoke [electrode-ccm-client], send a request with all config names your app needs to CCM, and get back all the values

3.  Save/Update the values in memory `server.app.ccm` (also accessible at `request.server.app.ccm`).

4.  As each CCM `serviceName` and `configName` config object is retrieved, they are saved to the disk as snapshots for used later in case the service is down.

    * On production, default location is `/app/.electrode/ccm_{APP_NAME}/`
    * On development, default location is `{process.cwd()}/.ccm/`

[electrode-ccm-client]: https://gecgithub01.walmart.com/electrode-client/electrode-ccm-client
[electrode-ui-config]: https://gecgithub01.walmart.com/electrode/electrode-ui-config
[electrode-wml-server]: https://gecgithub01.walmart.com/electrode/electrode-wml-server
[ccm client setup]: https://gecgithub01.walmart.com/electrode-client/electrode-ccm-client#usage
[json path]: http://goessner.net/articles/JsonPath/
[regex]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
[index template]: https://gecgithub01.walmart.com/electrode/electrode-react-webapp

