"use strict";

/* eslint-disable max-nested-callbacks */

const _ = require("lodash");
const Promise = require("bluebird");
const assert = require("assert");
const symbols = require("./symbols");
const lruCache = require("lru-cache");
const constants = require("./constants");

const ROOT_GROUP_NAME = "root";
const ROOT_PROFILE_NAME = "root";
const CONFIG_NAMES_KEY = "+configNames";
const DEFAULT_PROFILE_NAME = "default";
const DEFAULT_SCOPE_TEMPLATE = "/{environment}/{cloud}/{node}";

const TEN_HOURS = 10;

class ServiceSource {
  constructor(options) {
    this.ccmCache = options.ccmCache;
    //
    // Cache up to 10k providerContextProperties with ten hours TTL.
    // This is plenty since not expecting more than a few hundred active
    // experiment variation IDs any time.
    // Each one is about 130-140 bytes so 10K will use about 1.5MB memory.
    //
    this.providerContextPropertiesCache = lruCache({
      max: 10000,
      maxAge: TEN_HOURS * constants.ONE_HOUR_MS
    });
  }

  loadProfileConfig(ref, ccmData, options) {
    const getGroupStore = () => {
      if (options.groupName === ROOT_GROUP_NAME) {
        return ccmData;
      } else {
        const groupStore = ccmData[options.groupName] || {};
        ccmData[options.groupName] = groupStore;
        return groupStore;
      }
    };

    const groupStore = getGroupStore();

    const getProfileStore = () => {
      if (options.profileName === ROOT_PROFILE_NAME) {
        return groupStore;
      } else {
        const profileStore = groupStore[options.profileName] || {};
        groupStore[options.profileName] = profileStore;
        return profileStore;
      }
    };

    const profileStore = getProfileStore();
    const expVarId = options.expVarId;

    const promises = [];

    _.each(options.data, (data, dataName) => {
      assert(
        data.serviceName,
        `CCM group ${options.groupName} data ${dataName} doesn't contain serviceName`
      );

      const serviceName = data.serviceName;

      //
      // wait for serviceName's configNames mapping and then retrieve each one
      //
      const scopeName = options.scopeName;
      // only needed for sending resolution telemetry data
      const scopeTemplate = options.scopeTemplate;
      const getConfig = mapping => {
        const wantConfigNames =
          mapping === false
            ? data[CONFIG_NAMES_KEY]
            : _.filter(data[CONFIG_NAMES_KEY], configName => mapping.check(expVarId, configName));

        // nothing to retrieve for this serviceName
        if (wantConfigNames.length <= 0) return undefined;

        const configStore = profileStore[dataName] || {};
        profileStore[dataName] = configStore;

        // retrieve CCM properties for all configNames
        ccmData[symbols.serviceNames].push(serviceName);

        return Promise.map(
          wantConfigNames,
          configName => {
            const params = {
              serviceName,
              configName,
              scopeName,
              scopeTemplate,
              providerContextProperties: options.providerContextProperties
            };

            return Promise.try(() => this.ccmCache.getConfig(ref, params, options))
              .then(configuration => {
                const properties = configuration.properties;
                _.merge(configStore, properties);
              })
              .catch(err => {
                //
                // Was not able to get config from cache, which means both server
                // and snapshot failed.  Log an error and move on and allow user
                // defaults to be applied later.
                //
                ref.log(["error"], {
                  msg: "electrode-ccm: CCM Initializer getConfig failed",
                  err: err.errObj || err
                });
              });
          },
          { concurrency: 2 }
        );
      };

      //
      // if there's an exp variation ID, then we should only retrieve for
      // the configNames it affects under the given serviceName
      //
      if (expVarId) {
        promises.push(this.ccmCache.getExpCCMVariationsMap(ref, serviceName).then(getConfig));
      } else {
        promises.push(getConfig(false)); // no mapping, retrieve everything
      }
    });

    return Promise.all(promises);
  }

  getProviderContextProperties(exp) {
    let data = this.providerContextPropertiesCache.get(exp);

    if (!data) {
      data = new Buffer(
        JSON.stringify({
          "com.walmart.platform.exp.client.context.ExperimentationClientContextProvider": { exp }
        })
      ).toString("base64");
      this.providerContextPropertiesCache.set(exp, data);
    }

    return data;
  }

  load(ref, options) {
    const client = ref.client;
    const keys = options.keys;
    const loadedCCMData = { [symbols.serviceNames]: [] };

    const providerContextProperties = options.expVarId
      ? this.getProviderContextProperties(options.expVarId)
      : undefined;

    return Promise.map(Object.keys(keys), groupName => {
      const group = keys[groupName];
      const data = group.data;
      const groupScopeTemplate =
        group.scopeTemplate || options.scopeTemplate || DEFAULT_SCOPE_TEMPLATE;

      let profiles = group.profiles;
      const defaultProfile = profiles && profiles[DEFAULT_PROFILE_NAME];

      assert(data, `CCM group ${groupName} doesn't contain data`);

      if (!profiles || (defaultProfile && Object.keys(profiles).length === 1)) {
        profiles = { [ROOT_PROFILE_NAME]: {} };
      }

      return Promise.map(
        Object.keys(profiles),
        profileName => {
          const profile = profiles[profileName];

          if (profileName === DEFAULT_PROFILE_NAME || !profile) {
            return undefined;
          }

          const composeProfile = _.defaults({}, defaultProfile, profile);
          const scopeTemplate = composeProfile.scopeTemplate || groupScopeTemplate;

          const scopeName = client.scopeName(scopeTemplate, composeProfile);

          return this.loadProfileConfig(ref, loadedCCMData, {
            scopeName,
            scopeTemplate,
            groupName,
            profileName,
            data,
            expVarId: options.expVarId,
            providerContextProperties
          });
        },
        { concurrency: 2 }
      );
    })
      .then(() => {
        // remember service names for calling CCM getChanges API
        loadedCCMData[symbols.serviceNames] = _.uniq(loadedCCMData[symbols.serviceNames]);
        return loadedCCMData;
      })
      .catch(err => {
        ref.log(["error"], { msg: "electrode-ccm: loading CCM config from server failed", err });
        return {};
      });
  }
}

module.exports = ServiceSource;
