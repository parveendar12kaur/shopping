"use strict";

const Promise = require("bluebird");
const _ = require("lodash");
const lruCache = require("lru-cache");
const uiFilter = require("./ui-filter");
const symbols = require("./symbols");
const DefaultSource = require("./default-source");
const ServiceSource = require("./service-source");
const expCookie = require("./exp-cookie");
const CCMCache = require("./ccm-cache");
const snapshot = require("./snapshot");
const constants = require("./constants");

class CCMInitializer {
  constructor(config) {
    this.config = Object.assign(
      {
        snapshot: {},
        keys: {},
        sources: ["defaults", "snapshot", "service"]
      },
      config
    );

    _.defaults(this.config.snapshot, { dir: snapshot.defaultDir() });

    this.defaultsOn = this.config.sources.indexOf("defaults") >= 0;
    this.ccmCache = new CCMCache(
      this.config.sources.indexOf("snapshot") >= 0 && this.config.snapshot,
      this.config.sources.indexOf("service") >= 0
    );
    //
    // Store the final config output for each experiment variation in
    // an LRU cache.
    // A typical experiment variation only overrides a handful of
    // configs so each one is about 100 to 300 bytes.
    // There are gernally a few hundred active variations at any time.
    //
    this.variationsCache = lruCache({
      max: 2000,
      maxAge: constants.ONE_HOUR_MS
    });

    this.ccmDefaults = new DefaultSource(this.config);
    this.ccmService = new ServiceSource({
      ccmCache: this.ccmCache,
      config: this.config
    });
  }

  refreshCCm(ref) {
    const container = ref.container;
    if (!container.ccm) container.ccm = {};

    const loadOptions = {
      keys: this.config.keys,
      scopeTemplate: this.config.scopeTemplate
    };

    return Promise.join(
      this.defaultsOn && this.ccmDefaults.load(ref, loadOptions),
      this.ccmService.load(ref, loadOptions),
      (defaults, service) => {
        container.ccm[symbols.serviceNames] = service[symbols.serviceNames];
        _.merge(container.ccm, defaults, service);
        container[symbols.lastRefreshed] = Date.now();
        container.uiCCM = uiFilter.process(this.config.uiFilter, container.ccm);
      }
    );
  }

  //
  // CCM Server doesn't want us to load everything from them every refresh cycle
  // since that would overload their servers.
  //
  // There's a CCM change API that indicates if some config has changed and app's
  // cache should be invalidated.
  //

  checkChanges(ref) {
    const container = ref.container;
    const service = container.ccm[symbols.serviceNames];

    return ref.client
      .withMeta(ref.req)
      .getChanges({
        allowNoContent: true,
        includeAdminChanges: true,
        committed: false,
        service,
        changeGroup: "SCM_CLIENT"
      })
      .then(res => {
        let logChange = false;
        let changed = false;
        const changes = _.get(res, "obj.payload.changes", []);

        _.each(changes, change => {
          if (!change || change.changeType === "TYPED") return;
          switch (change.action) {
            case "LOG_CONFIG":
            case "LOG_CONFIG_CLIENT":
              logChange = true;
              break;

            case "INVALIDATE_CONFIG":
            case "INVALIDATE_CONFIG_CLIENT":
              changed = true;
              this.ccmCache.handleChange(change);
              break;

            case "CLEAR_CONFIG_CACHE":
            case "CLEAR_CONFIG_CACHE_CLIENT":
              changed = true;
              this.ccmCache.clear();
              break;

            default:
              ref.log(["warn"], `electrode-ccm: Unrecognized CCM change action: ${change.action}`);
              break;
          }
        });

        // Should log entire config object for LOG_CONFIG
        if (logChange) ref.log(["info"], `electrode-ccm: CCM change LOG_CONFIG received`);

        return changed;
      })
      .catch(err => {
        ref.log(["error"], { msg: "electrode-ccm: getChanges failed", err });
        return false;
      });
  }

  //
  // Load CCM per request.
  //
  // If exp is available, then will load CCM custom to it also
  // - ref.defaultContainer should have the default configs
  // - ref.container will receive the request specific configs
  //
  loadRequestCCM(ref) {
    const exp = expCookie(ref.xpm, ref.xpa);

    const container = ref.container;
    const defaultContainer = ref.defaultContainer;

    if (!exp) {
      container.uiCCM = defaultContainer.uiCCM;
      container.ccm = path => _.get(defaultContainer.ccm, path);
      return Promise.resolve(container.ccm);
    }

    return Promise.map(
      exp.varIds,
      expVarId => {
        if (this.variationsCache.has(expVarId) && !this.ccmCache.variantRefresh(expVarId)) {
          return this.variationsCache.get(expVarId);
        }

        //
        // load the CCM values for this single exp variation
        //
        return this.ccmService
          .load(ref, {
            keys: this.config.keys,
            // Pass in scopeTemplate from ccm config.  It's used if keys config
            // doesn't have it specified in group or profile
            scopeTemplate: this.config.scopeTemplate,
            expVarId
          })
          .then(data => {
            this.variationsCache.set(expVarId, data);
            // do ui filtering on the data and save it
            data[symbols.uiFiltered] = uiFilter.process(this.config.uiFilter, data);
            return data;
          });
      },
      { concurrency: 3 }
    )
      .then(results => {
        // got an array of configs for each experiment
        // save it to request for doing lookup

        //
        // Combine all ui filtered values into a single object.
        //
        // Define it as a get property so its process is deferred until it's used.
        //
        // While we are able run the regex filtering only once for each
        // variant config outcome, we have to clone the default and merge
        // each variant into it for every request.
        //
        // TODO: Do some benchmark on cloneDeep and merge, and access if
        //       it makes sense to cache these by the exp cookie, at a
        //       short TTL that's less than the 1 minute CCM change
        //       propagation requirement.  It's unlikely to be useful though
        //       since probably very rare that two users have the same
        //       experiments and outcome assigned.
        //
        let uiCCM;
        Object.defineProperty(container, "uiCCM", {
          get: () => {
            if (!uiCCM) {
              uiCCM = _.reduce(
                results,
                (acc, x) => _.merge(acc, x[symbols.uiFiltered]),
                _.cloneDeep(defaultContainer.uiCCM)
              );
            }
            return uiCCM;
          }
        });

        // create the lookup function specific for the given request
        container.ccm = path => {
          // first check if variant results contains config for path
          for (let i = 0; i < results.length; i++) {
            const f = _.get(results[i], path);
            if (f !== undefined) return f;
          }
          return _.get(defaultContainer.ccm, path);
        };

        return container.ccm;
      })
      .catch(err => {
        ref.log(["error"], {
          msg: "electrode-ccm: failed to generate experimented CCM for request",
          err
        });

        container.uiCCM = defaultContainer.uiCCM;
        container.ccm = path => _.get(defaultContainer.ccm, path);

        return container.ccm;
      });
  }

  //
  // only refresh default configs, since variants cache is to be
  // filled up incrementally as experiment variants come in
  //
  handleRefresh(ref) {
    if (!ref.client) {
      ref.log(["error"], "electrode-ccm: CCM client is unavailable.");
      return Promise.resolve();
    }

    return Promise.try(() => {
      return !ref.container[symbols.lastRefreshed] || this.checkChanges(ref);
    }).then(changed => {
      let refresh = "";

      if (!changed) {
        refresh = this.ccmCache.refresh();
      }

      if (!changed && !refresh) {
        ref.log(
          ["info"],
          `electrode-ccm: handleRefresh NOT refreshing - changed '${changed}' refresh '${refresh}'`
        );
        return false;
      }

      ref.log(
        ["info"],
        `electrode-ccm: handleRefresh refreshing - changed '${changed}' refresh '${refresh}'`
      );

      return this.refreshCCm(ref);
    });
  }
}

module.exports = CCMInitializer;
