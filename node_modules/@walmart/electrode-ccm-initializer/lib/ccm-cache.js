"use strict";

/* eslint-disable no-magic-numbers, max-statements */

const Fs = require("fs");
const Promise = require("bluebird");
const readFile = Promise.promisify(Fs.readFile);
const writeFile = Promise.promisify(Fs.writeFile);
const _ = require("lodash");
const Path = require("path");
const lruCache = require("lru-cache");
const constants = require("./constants");
const mkdirp = require("mkdirp");
const Crypto = require("crypto");
const ServiceToConfigMap = require("./service-to-config-map");
const fyi = require("@walmart/electrode-fyi");
const fyiError = fyi.limitError("electrode-ccm", 10);
const prune = require("./prune");

const CCM_VARIANT_MAP_REFRESH_MIN = 3;

const nowSeconds = () => {
  return Math.floor(Date.now() / constants.MS_PER_SEC);
};

const secondsToISOString = x => {
  return new Date(x * constants.MS_PER_SEC).toISOString();
};

class CCMCache {
  constructor(snapshot, service) {
    //
    // Main config cache with key from scopeName/serviceName/configName.
    // This is not using lru-cache because entries contain the default config
    // and the variant config.  TTL only affects the default config, but needs
    // to signal variant config to refresh.
    //
    this.cache = {};
    //
    // The metrics cache will keep all the telemetry data for a particular config
    // it uses the same key system as the actual cache.
    // Having a seperate cache will keep us track metrics from the begining and maintain counts.
    //
    this.metricsCache = {};

    //
    // Map variant IDs back to the config cache entry
    // This is needed because main cache is lookup by scopeName/serviceName/configName
    // but experiment variants are scopeName agnostic.
    //
    // In order to be able to do:
    //
    // - If default config in main cache changed, then it needs to signal all variant cache
    //   tie to the same serviceName/configName to refresh
    // - To lookup the config for a given variant ID not knowing all three params since
    //   only the ID is acquired by decoding the exp cookie.
    //
    this.varToEntryMap = {};
    //
    // expo variation serviceName to configName mapping cache, returned by quimby's
    // getCCMVariationsMap API.  This allows us to avoid calling CCM for any serviceName/configName
    // that the variation didn't override.
    //
    // Cache key is the serviceName so a max of 100 is plenty, since typically an app only has
    // a handful of serviceNames to retrieve CCM configs.
    //
    this.expVarMapCache = lruCache({
      max: 100,
      maxAge: CCM_VARIANT_MAP_REFRESH_MIN * constants.ONE_MINUTE_MS
    });
    this.serviceOn = service !== undefined ? service !== false : true;
    this.snapshotOK = false;
    this.firstRun = true;
    if (snapshot !== false) {
      this.snapshot = snapshot || { dir: Path.resolve(".ccm") };
      this.initSnapshot(this.snapshot.dir);
      if (this.snapshotOK) {
        this.pruneIntervalId = prune
          .setupInterval(this.snapshot.dir, constants.ONE_HOUR_MS)
          .unref();
      }
    }
    this.inflights = {
      getConfig: {},
      getExpCCMVariationsMap: {}
    };

    //
    // Keep a list of all the unique scopes seen through getConfig
    // because if change API indicate a top scope changed, then we
    // have to propagate that to all subscopes under it.
    // For example, if /DEV changed, then /DEV/dev and /DEV/dev/host-1
    // must both be refreshed.
    //
    this.seenScopes = {};
  }

  getCacheKey(params) {
    return Path.posix.join(params.scopeName, params.serviceName, params.configName);
  }

  initSnapshot(dir) {
    try {
      mkdirp.sync(dir);
      this.snapshotOK = Fs.existsSync(dir);
      if (!this.snapshotOK) {
        fyiError(`electrode-ccm: snapshot dir "${dir}" exists check returned false`);
      }
    } catch (e) {
      fyiError(`electrode-ccm: mkdir snapshot dir "${dir}" failed: ${e.message}`);
    }
  }

  makeSnapshotFilename(expVarId, params) {
    const varId = expVarId ? `~${expVarId}` : "";
    const fn = `${params.scopeName}~${params.serviceName}~${params.configName}${varId}`;
    // add a SHA on the original filename in case multiple sanitized copies end up the same
    const fnSha = Crypto.createHash("sha1")
      .update(fn)
      .digest("base64");
    const filename = `${fn}~${fnSha}.json`.replace(/[^a-zA-Z0-9_~\-\.!@#$%^,=+]/g, "_");
    return Path.join(this.snapshot.dir, filename);
  }

  readSnapshot(expVarId, params) {
    return readFile(this.makeSnapshotFilename(expVarId, params)).then(JSON.parse);
  }

  saveSnapshot(expVarId, params, payload) {
    const configuration = Object.assign({ $$snapshot: true }, payload.configuration);
    const filename = this.makeSnapshotFilename(expVarId, params);
    return writeFile(
      filename,
      JSON.stringify({
        snapshot: true,
        timestamp: Date.now(),
        params,
        expVarId,
        serverIP: payload.serverIP,
        cloudName: payload.cloudName,
        configuration
      })
    );
  }

  getConfig(ref, params, options) {
    const cacheKey = this.getCacheKey(params);
    const expVarId = options && options.expVarId;
    const id = expVarId || "default";
    let entry = this.cache[cacheKey];

    if (entry) {
      const now = Date.now();
      const config = entry.config[id];
      // if cache for config exist, then use it if it's not the default or TTL still valid
      if (config && (expVarId || now < entry.refreshTime)) {
        return Promise.resolve(config.configuration);
      }
    } else if (expVarId) {
      return Promise.reject(
        new Error(`electrode-ccm: cannot get exp variant config before defaults for ${cacheKey}`)
      );
    }

    const inflightKey = `${cacheKey}-${id}`;
    if (this.inflights.getConfig[inflightKey]) {
      return this.inflights.getConfig[inflightKey];
    }

    // Now must refresh
    // if refreshing default, then reinitialize the whole thing and drop variations
    if (!expVarId) {
      this.invalidateVariants(entry);

      this.cache[cacheKey] = entry = {
        varIds: {},
        config: {},
        params,
        refreshTime: Date.now() + constants.ONE_HOUR_MS
      };
    }

    if (!this.seenScopes[params.scopeName]) {
      this.seenScopes[params.scopeName] = true;
    }

    const promise = Promise.try(() => {
      return this.serviceOn
        ? ref.client.withMeta(ref.req).getConfig(params)
        : Promise.reject(new Error("CCM Service Disabled"));
    })
      .catch(err => {
        const px = "electrode-ccm getConfig failed:";
        if (this.snapshotOK) {
          return this.readSnapshot(expVarId, params).catch(err2 => {
            err.message = `${px} ${err.message}; and readSnapshot failed: ${err2.message}`;
            throw err;
          });
        } else {
          err.message = `${px} ${err.message}; and snapshot is disabled.`;
          throw err;
        }
      })
      .catch(err => {
        //
        // Since the ccm call failed and snapshot is disabled or readSnapshot failed
        // We will call ccm Post Resolution Telemetry with source "DEFAULTS".
        // But we don't know what the app's actual default settings are so
        // just posting an empty configuration.
        //
        if (this.serviceOn && id === "default") {
          this.postResolutionTelemetry(ref, {
            params,
            cacheKey,
            config: {
              source: "DEFAULTS",
              configuration: { properties: {} },
              serverIP: "unknown",
              cloudName: "unknown"
            }
          });
        }
        throw err;
      })
      .then(response => {
        let source;
        let payload;

        if (response.snapshot) {
          source = "SNAPSHOT";
          payload = response;
        } else {
          source = "SERVER";
          payload = response.obj.payload;
        }

        let configuration = payload.configuration;

        if (expVarId) {
          const properties = this.getOnlyOverride(
            configuration.properties,
            entry.config.default.configuration.properties
          );

          configuration = Object.assign({}, configuration, { properties });

          this.mapVarIdToEntry(expVarId, entry);
        }

        entry.config[id] = {
          source,
          configuration,
          serverIP: payload.serverIP,
          cloudName: payload.cloudName
        };
        //
        // Telemetry calls are fire and forget.
        // Post resolution telemetry should be called for each serviceName,configName.
        //
        if (this.serviceOn && this.firstRun) {
          this.firstRun = false;
          this.postBootstrapTelemetry(ref, this.snapshotOK);
        }

        if (this.serviceOn && id === "default") {
          this.postResolutionTelemetry(ref, {
            params,
            cacheKey,
            config: entry.config[id]
          });
        }

        if (!response.snapshot) {
          //
          // save original configuration to snapshot
          //
          if (this.snapshotOK) {
            return this.saveSnapshot(expVarId, params, payload)
              .catch(_.noop) // save snapshot failed, move on
              .then(() => configuration);
          }
        }

        return configuration;
      })
      .finally(() => {
        delete this.inflights.getConfig[inflightKey];
      });

    this.inflights.getConfig[inflightKey] = promise;

    return promise;
  }

  mapVarIdToEntry(varId, entry) {
    //
    // Allow variant ID to find its way back to the entry not knowing scopeName,
    // serviceName, or configName.
    //
    const sn = entry.params.serviceName;
    const cn = entry.params.configName;
    _.set(this.varToEntryMap, [varId, sn, cn], entry);
    // reverse map to the variant ID so they can be clear when default is refreshed
    entry.varIds[varId] = true;
  }

  refresh() {
    const now = Date.now();
    return _.isEmpty(this.cache) || !!_.find(this.cache, entry => now >= entry.refreshTime);
  }

  //
  // check if variant needs refreshing
  //
  // mapping is
  //
  // { [varId]: { [serviceName]: { [configName]: entry, [configName2]: true }}}
  //
  variantRefresh(expVarId) {
    //
    // if any reverse map back to the config cache entry is true then it's been
    // refreshed and all the variants need to be updated
    //
    if (_.isEmpty(this.varToEntryMap)) {
      // only indicate variant should refresh if default cache is not empty
      // because variants don't make sense without defaults
      return !_.isEmpty(this.cache);
    }
    const r = _.find(this.varToEntryMap[expVarId], configs => _.find(configs, x => x === true));
    return r !== undefined;
  }

  invalidate(params) {
    const cacheKey = this.getCacheKey(params);
    if (this.cache[cacheKey]) {
      this.cache[cacheKey].refreshTime = 0;
      this.metricsCache[cacheKey].reason = "CHANGE";
    }
  }

  invalidateVariants(entry) {
    if (entry) {
      const serviceName = entry.params.serviceName;
      const configName = entry.params.configName;
      // we must delete the entire service to config mapping for serviceName
      this.expVarMapCache.del(serviceName);
      // delete cache for each variaint ID
      _.each(entry.varIds, (_$, varId) => {
        _.set(this.varToEntryMap[varId], [serviceName, configName], true);
      });
    }
  }

  getOnlyOverride(varConfig, defaultConfig) {
    //
    // overrides cannot add or remove properties from default config
    //
    return _.pickBy(varConfig, (v, k) => v !== defaultConfig[k]);
  }

  clear() {
    this.cache = {};
    this.varToEntryMap = {};
    this.expVarMapCache.reset();
  }

  handleChange(change) {
    //
    // We have to detect all subscopes under changed scope and notify them
    //
    _.each(this.seenScopes, (seen, scope) => {
      if (scope.startsWith(change.scope)) {
        this.invalidate({
          scopeName: scope,
          serviceName: change.serviceName,
          configName: change.configName
        });
      }
    });

    // don't want to invalidate variant here because we don't want
    // get variant to happen before default is refreshed.
  }

  getExpCCMVariationsMap(ref, serviceName) {
    const inflight = this.inflights.getExpCCMVariationsMap[serviceName];
    if (inflight) return inflight;

    const cached = this.expVarMapCache.get(serviceName);
    if (cached) return Promise.resolve(cached);

    const promise = ref.quimbyClient
      .withMeta(ref.req)
      .getExpCCMVariations({ serviceName })
      .then(resp => {
        const mapping = new ServiceToConfigMap();
        const variations = _.get(resp, "obj.exp.data.expCCMVariations");
        //
        // generating mapping of each pair of variant id and config name
        //
        _.each(variations, (configs, varId) => {
          _.each(configs, configName => {
            mapping.set(varId, configName);
          });
        });
        this.expVarMapCache.set(serviceName, mapping);
        return mapping;
      })
      .finally(() => {
        delete this.inflights.getExpCCMVariationsMap[serviceName];
      });

    this.inflights.getExpCCMVariationsMap[serviceName] = promise;

    return promise;
  }

  postBootstrapTelemetry(ref, isInitialized) {
    const data = {
      payload: {
        clientContext: _.get(ref, "client.context", {}),
        storeTelemetry: {
          snapshot: {
            initialized: isInitialized
          }
        }
      }
    };
    const promise = Promise.try(() => {
      return ref.client.withMeta(ref.req).postBootstrapTelemetry({ payload: data });
    })
      .then(() => {
        ref.log(["info"], "electrode-ccm: posted bootstrap telemetry data");
      })
      .catch(err => {
        ref.log(["error"], { msg: "electrode-ccm: failed posting bootstrap data", err });
      });

    return promise;
  }

  getMetrics(cacheKey) {
    const now = nowSeconds();
    const metrics = this.metricsCache[cacheKey];

    if (!metrics) {
      return (this.metricsCache[cacheKey] = {
        createTimestamp: now,
        lastExpiredTimestamp: now,
        lastResolutionTimestamp: now,
        lastUpdatedTimestamp: now,
        resolutionCount: 0,
        expiredCount: 0,
        updatedCount: 0,
        reason: "REQUEST"
      });
    } else {
      metrics.lastResolutionTimestamp = now;
      metrics.resolutionCount++;
      metrics.lastUpdatedTimestamp = now;
      metrics.updatedCount++;
    }

    return metrics;
  }

  composeTelemetryData(ref, data) {
    const metrics = this.getMetrics(data.cacheKey);

    const ccmConfig = data.config;

    const clientContext = ref.client.context;
    const hostName = _.get(ref.client, "swagger.spec.host", "");

    const scopeTemplate = data.params.scopeTemplate;
    const scopeName = data.params.scopeName;
    const configName = data.params.configName;
    const serviceName = data.params.serviceName;

    const payload = {
      configName,
      clientContext,

      serverDetails: {
        timestamp: metrics.createTimestamp,
        cloudName: ccmConfig.cloudName,
        ipAddress: ccmConfig.serverIP,
        runOnEnv: clientContext.runOnEnv,
        hostName
      },

      createTime: secondsToISOString(metrics.createTimestamp),
      createTimestamp: metrics.createTimestamp,
      clientResolution: [ccmConfig.source],

      lastResolutionTime: secondsToISOString(metrics.lastResolutionTimestamp),
      lastResolutionTimestamp: metrics.lastResolutionTimestamp,

      lastExpiredTime: secondsToISOString(metrics.lastExpiredTimestamp),
      lastExpiredTimestamp: metrics.lastExpiredTimestamp,

      lastUpdatedTime: secondsToISOString(metrics.lastUpdatedTimestamp),
      lastUpdatedTimestamp: metrics.lastUpdatedTimestamp,

      resolutionCount: metrics.resolutionCount,
      expiredCount: metrics.expiredCount,
      updatedCount: metrics.updatedCount,
      //
      // CCM requires every property entry to be a string value.
      // Since we are currently just posting whatever we received
      // from CCM, we don't need to do that check.
      // We are not sending any properties in case of server and
      // snapshot failure because the way that's setup is not
      // mapped to CCM config nodes.
      //
      resolvedProperties: ccmConfig.configuration.properties,
      scope: scopeName,

      expired: false,
      scopeTemplateMap: {
        [serviceName]: `${scopeTemplate}`.replace(/{|}/g, "")
      },

      resolutions: [
        {
          consumer: serviceName,
          scope: scopeName,
          store: ccmConfig.source
        }
      ],
      configNamespace: `${serviceName} ${configName}`,
      configurationChanged: true,
      reason: metrics.reason
    };

    return { payload };
  }

  postResolutionTelemetry(ref, data) {
    const payload = this.composeTelemetryData(ref, data);

    return Promise.try(() => {
      return ref.client.withMeta(ref.req).postResolutionTelemetry({ payload });
    })
      .then(() => {
        ref.log(["info"], `electrode-ccm: posted resolution telemetry data for ${data.cacheKey}`);
      })
      .catch(err => {
        ref.log(["error"], {
          msg: `electrode-ccm: failed posting config resolution telemetry for ${data.cacheKey}`,
          err
        });
      });
  }
}

module.exports = CCMCache;
