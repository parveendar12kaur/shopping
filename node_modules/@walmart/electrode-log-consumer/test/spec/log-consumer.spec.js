"use strict";

const sinon = require("sinon");
const Hapi = require("hapi");
const expect = require("chai").expect;
const logConsumer = require("../../lib");

describe("log-consumer plugin", () => {

  let server;
  let sandbox;

  const createServer = (config, next) => {
    server = new Hapi.Server();
    server.app.config = config || {};
    server.connection({ port: 3001 });
    server.register([logConsumer], next);
  };

  before(() => {
    sandbox = sinon.sandbox.create();
  });

  beforeEach((done) => {
    createServer(null, done);
  });

  afterEach((done) => {
    sandbox.restore();
    server.stop(() => {
      done();
    });
  });

  it("should expose a logger endpoint", (done) => {
    server.inject({url: "/api/logger", method: "POST"}, (reply) => {
      expect(reply).to.have.property("statusCode", 400);
      done();
    });
  });

  it("should respond with 200 for payload with tags and data", (done) => {

    const payload = { tags: ["debug"], data: "Bummer!" };

    server.inject({ url: "/api/logger", method: "POST", payload: payload },
      (reply) => {
        expect(reply).to.have.property("statusCode", 200);
        expect(reply.payload).to.deep.equal(JSON.stringify({status: "ok"}));
        done();
      });
  });

  it("should accept payload as array", (done) => {

    const payload = [{tags: ["error"], data: "Bummer!"}, {tags: ["info"], data: "Cool!"}];

    server.inject({
      url: "/api/logger",
      method: "POST",
      payload: JSON.stringify(payload)
    },
      (reply) => {
        expect(reply).to.have.property("statusCode", 200);
        done();
      });
  });

  it("should return 400 if payload is missing", (done) => {

    server.inject({ url: "/api/logger", method: "POST" },
      (reply) => {
        try {
          expect(reply).to.have.property("statusCode", 400);
          const payload = JSON.parse(reply.payload);
          expect(payload).to.have.property("message", "Payload missing");
          done();
        } catch (err) {
          done(err);
        }
      });
  });

  it("should skip invalid items in payload array", (done) => {
    const payload = [{ data: "Bummer!"}, { tags: ["info"], data: "Cool!"}];
    const logSpy = sandbox.stub();
    server.on("request", logSpy);

    server.inject({
      url: "/api/logger",
      method: "POST",
      payload: JSON.stringify(payload)
    },
      (reply) => {
        try {
          expect(reply).to.have.property("statusCode", 200);
          expect(logSpy).to.have.been.calledTwice;
          const firstLog = logSpy.firstCall.args[1];
          expect(firstLog).to.have.property("tags").with.members(["WARN"]);
          expect(firstLog).to.have.property("data", "Logging payload malformed, skipping.");
          const secondLog = logSpy.secondCall.args[1];
          expect(secondLog).to.have.property("tags").with.members(["info"]);
          expect(secondLog).to.have.property("data", "Cool!");
          done();
        } catch (err) {
          done(err);
        }
      });
  });

  it("should use basepath if available", (done) => {
    const config = { ui: { basePath: "/foo" } };
    createServer(config, () => {
      server.inject({url: "foo/api/logger", method: "POST"}, (reply) => {
        expect(reply.statusCode).to.equal(400);
        done();
      });
    });
  });

  it("should set request.app.disableTransactions to true with invalid payload", () => {
    server.inject({ url: "/api/logger", method: "POST" }, (reply) => {
      expect(reply).to.have.property("statusCode", 400);
      expect(reply).to.have.deep.property("request.app.disableTransactions", true);
    });
  });

  it("should set request.app.disableTransactions to true with valid payload", () => {
    server.inject({
      url: "/api/logger",
      method: "POST",
      payload: { data: "Hi", tags: ["info"] }
    }, (reply) => {
      expect(reply).to.have.property("statusCode", 200);
      expect(reply).to.have.deep.property("request.app.disableTransactions", true);
    });
  });

});
