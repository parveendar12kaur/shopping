"use strict";

/* eslint-disable no-magic-numbers, prefer-template */

function responseError(message, response) {
  var e = new Error(message);
  e.response = response;
  e.status = response.status;
  return e;
}

function translateResponse(request, response) {
  function fail(exception) {
    throw responseError("electrode-fetch: payload from URL " + request.url + " " + ("caused translate exception: " + exception.message), response);
  }

  try {
    var data = request.translate(response);
    if (data.catch) {
      data = data.catch(fail);
    }
    return data;
  } catch (exception) {
    return fail(exception);
  }
}

function noOp() {}

/*
 * To be attached to request, expected called with request as this.
 */

/* eslint-disable no-invalid-this */

function logFetchEnd(level, data) {
  var request = data.request;
  var timingFirst = request.timings[0];
  var timing = request.lastTiming();
  request.endTime = timing.end = request.getTime();

  this.logger(level, {
    state: data.state || "end",
    msg: data.msg,
    index: this.index,
    url: this.url,
    receiveTime: timing.received - timing.start,
    translateTime: timing.translated - timing.received,
    time: timing.end - timing.start,
    totalTime: timing.end - timingFirst.start,
    retry: this.retry,
    maxRetries: this.options.maxRetries,
    status: data.status
  }, {
    request: request,
    response: data.response
  });
}

/*
 *  options:
 *
 *   options.manageJwt - boolean
 *
 *     If true, will look for x-csrf-jwt header from response and take
 *     it on as the new JWT token to be used in all subsequent fetches
 *
 *   options.keepAlive - boolean
 *
 *     If true, will try to keep HTTP connection alive (only works for server side)
 */
function ElectrodeFetch(options) {
  this.options = options;

  // JWT token to be used in all fetches
  // could be set if manageJwt is true and a fetch returned the token in
  // the header x-csrf-jwt
  this.JWT = false;

  this._requestIndex = 0;

  this.setListener();
  this.setFetch();
  this.setGenerateCorrelationID();
  this.setGetJWT();

  function jsonTranslate(resp) {
    return resp.json();
  }

  this._translate = options.translate || jsonTranslate;
}

ElectrodeFetch.prototype.fetchWrapper = function (request) {
  var self = this;
  var timeout = request.options.timeout;
  var fetch = void 0;
  var fetchTimeout = void 0;

  if (this.options.isClientFetch && timeout) {
    fetch = new Promise(function (resolve, reject) {
      request._fetch(request.url, request.options).then(resolve).catch(reject);

      fetchTimeout = setTimeout(function () {
        resolve({
          status: 408,
          message: "request timed out"
        });
      }, timeout);
    });
  } else {
    fetch = request._fetch(request.url, request.options);
  }

  return fetch.then(function (response) {
    // eslint-disable-line max-statements
    clearTimeout(fetchTimeout);
    var timing = request.lastTiming();
    timing.received = request.getTime();

    function translated(x) {
      timing.translated = request.getTime();
      return x;
    }

    if (self.options.manageJwt && response.headers) {
      var newJwt = response.headers.get("x-csrf-jwt");
      if (newJwt !== undefined && newJwt !== null) {
        self.JWT = newJwt;
      }
    }

    if (response.status >= 200 && response.status < 300) {
      // eslint-disable-line
      var data = translateResponse(request, response);

      return data.then ? data.then(translated) : translated(data);
    } else if (!request.options.noRetry && (response.status === 401 && request.retry < 1 || // eslint-disable-line
    request.options.maxRetries > 0 && request.retry < request.options.maxRetries)) {
      if (response.status === 401) {
        // eslint-disable-line
        request.options.headers["x-csrf-jwt"] = response.headers.get("x-csrf-jwt");
      }

      request.logFetchEnd("warn", {
        state: "retry", status: response.status,
        request: request, response: response
      });

      request.retry++;
      request.timings.push({ start: request.getTime() });
      return self.fetchWrapper(request);
    } else {
      throw responseError("electrode-fetch: URL \"" + request.url + "\" returned bad status " + response.status, response);
    }
  });
};

function fetchGetTime() {
  return new Date().getTime();
}

ElectrodeFetch.prototype.makeRequest = function (url, options, translate) {
  var getTime = options.getTime || fetchGetTime;
  var index = this._requestIndex++;
  var now = getTime();

  return {
    url: url,
    options: options,
    retry: 0,
    index: index,
    translate: translate || this._translate,
    logFetchEnd: logFetchEnd,
    logger: options.disableAnalytics ? noOp : this._listener,
    getTime: getTime,
    startTime: now,
    timings: [{ start: now }],
    lastTiming: function lastTiming() {
      return this.timings[this.timings.length - 1];
    }
  };
};

ElectrodeFetch.prototype.fetch = function (url, options, translate) {
  // eslint-disable-line max-statements, max-len

  options = options || {};

  if (options.credentials === undefined) {
    options.credentials = "same-origin";
  }

  if (options.headers === undefined) {
    options.headers = {};
  }

  if (!options.omitCorrelationId && !options.headers["WM_QOS.CORRELATION_ID"] && this._generateCorrelationID) {
    options.headers["WM_QOS.CORRELATION_ID"] = this._generateCorrelationID(url, options);
  }

  if (!options.omitCsrfJwt && !options.headers["x-csrf-jwt"]) {
    var jwt = this.JWT || this._getGlobalJWT();
    if (jwt) {
      options.headers["x-csrf-jwt"] = jwt;
    }
  }

  if (options.agent) {
    options.headers["Connection"] = "keep-alive"; // eslint-disable-line
  }

  var request = this.makeRequest(url, options, translate);

  request.logger("info", { state: "start", msg: "start", index: request.index, url: request.url }, { request: request });

  request._fetch = options._fetch || this._fetch;

  return this.fetchWrapper(request).then(function (response) {
    request.logFetchEnd("info", {
      status: response.status,
      request: request,
      response: response
    });
    return response;
  }).catch(function (exception) {
    request.logFetchEnd("error", {
      state: "failed",
      msg: "fetch_fail - " + exception.message,
      status: exception.status,
      request: request,
      response: exception.response
    });
    throw exception;
  });
};

ElectrodeFetch.prototype.fetchJSON = function (url, options) {
  options = options || {};

  if (options.headers === undefined) {
    options.headers = {};
  }

  if (!options.omitContentType && options.headers["Content-Type"] === undefined) {
    options.headers["Content-Type"] = "application/json";
  }

  return this.fetch(url, options);
};

ElectrodeFetch.prototype.setListener = function (listener) {
  this._listener = listener || this.options.listener || noOp;
};

ElectrodeFetch.prototype.setFetch = function (newFetch) {
  this._fetch = newFetch || this.options.fetch;
};

ElectrodeFetch.prototype.setGenerateCorrelationID = function (generator) {
  this._generateCorrelationID = generator || this.options.generateCorrelationID;
};

ElectrodeFetch.prototype.setGetJWT = function (getter) {
  this._getGlobalJWT = getter || this.options.getGlobalJWT || noOp;
};

module.exports = ElectrodeFetch;
//# sourceMappingURL=electrode-fetch.js.map