# electrode-fetch

An instrumented wrapper around `fetch`. Usage:

To send a POST request:

```js
import {fetchJSON} from "@walmart/electrode-fetch";

fetchJSON("http://myendpoint.com/", {
  method: "POST",
  headers: {  // Accept and Content-Type are optional
    Accept: "application/json",
    "Content-Type": "application/json"
  },
  body: JSON.stringify(dataToPost)
}).then((data) => {
  // Do yo thang
})
.catch((err) => {
    //Handle Errors here
    console.log(err.response.status);
});
```

To send a GET request (`method` defaults to `GET`):

```js
import {fetchJSON} from "@walmart/electrode-fetch";

fetchJSON("http://myendpoint.com/").then((data) => {
  // Do yo thang
})
.catch((err) => {
    //Handle Errors here
    console.log(err.response.status);
});
```

And then anywhere else in your application you can do:

```js
import {setListener} from "@walmart/electrode-fetch";

setListener((stage, data) => {
  console.log(stage, data);
});
```

And get a really cool stream of analytics data about what's being called, what the
performance numbers look like, and so on.

### Options Specific to electrode-fetch

Beyond the options that `fetch` expects, `electrode-fetch` accepts the following `options`
attributes:

-   `maxRetries` - allows to set maximum number of retries for the request;
-   `disableAnalytics` - when `true` the instrumentation for the `fetchJSON` method is disabled;
-   `omitCorrelationId` - when `true`, `fetchJSON` doesn't set `WM_QOS.CORRELATION_ID` header on request;  
    **WARNING:** this option is required for very specific cases and in general case should be omitted.
-   `keepAlive` - only usable on server-fetch, when not `false` a [keep-alive agent](https://github.com/node-modules/agentkeepalive) is used to keep this http connection alive.
-   `timeout` - a number, times out the request in {number} ms.
-   `noInject` - If `true`, then don't use Hapi's `inject` API that skips a real network call when fetching from the server itself
-   `serviceName` - specify a serviceName to use when reporting metrics to Medusa

## Installation

```bash
$ npm install @walmart/electrode-fetch
```

## Polyfills

Just like in `isomorphic-fetch`, you must bring your own ES6 Promise compatible polyfill, `core-js/fn/promise` is a good choice if you are already using `core-js` for other polyfills.

## Scripts

If you want to use `builder` as a CLI tool (recommended), follow the instructions at [formidablelabs/builder to modify your `PATH`](https://github.com/formidablelabs/builder#local-install)

To run tests: `builder run test` or `npm test`
For more commands: `builder help`

## Issues

Before submitting an issue, please see the [Issue Submission Guidelines](https://gecgithub01.walmart.com/react/react-dev-guide#submitting-issues)

## Contributing

If you're interested in contributing, see the [React Developer Guide's Contribution Guide](https://gecgithub01.walmart.com/react/react-dev-guide#contributing)

## Examples with Options

Using the `maxRetries` option:
If this options is not specified, `electrode-fetch` will `retry 1 time`, in case of a `401` response, for others it will return with the response.

```js
import {fetchJSON} from "@walmart/electrode-fetch";

fetchJSON("http://myendpoint.com/", {maxRetries: 2}).then((data) => {
  // Your code here
})
.catch((err) => {
    //Handle Errors here
    console.log(err.response.status);
});
```

Using the `timeout` option:
Timeout should be passed in `ms` and will be applicable unless your request fails before the timeout.
A timeout returns a `http 408` status code.

```js
import {fetchJSON} from "@walmart/electrode-fetch";

fetchJSON("http://myendpoint.com/", {timeout: 5000}).then((data) => {
  // Your code here
})
.catch((err) => {
    //Handle Errors here
    console.log(err.response.status);
});
```

Using the `noInject` option:
For server Fetch, a `noInject: true` option can be passed to stop `electrode-fetch` from using HapiJs server connection.

```js
electrodeFetch.fetch("http://localhost:3000/ok", {noInject: true})
.then((data) => {
  // Your code here
})
.catch((err) => {
    //Handle Errors here
    console.log(err.response.status);
});
```

