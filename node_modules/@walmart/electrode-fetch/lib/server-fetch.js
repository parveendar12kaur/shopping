"use strict";

const assert = require("assert");
const ElectrodeFetch = require("../dist/electrode-fetch");
const agent = require("./keepalive-agent");
const realFetch = require("node-fetch");
const metrics = require("@walmart/electrode-metrics");
const { isHapi17 } = require("./util");

function isoFetch(url, options) {
  if (url.startsWith("//")) {
    url = `https:${url}`;
  }

  const start = Date.now();
  return realFetch
    .call(this, url, options) // eslint-disable-line
    .then(res => {
      metrics.reportFetch(res, Date.now() - start, {
        serviceName: options.serviceName || "user_called_fetch_without_service_name"
      });
      return res;
    });
}

const isLocal = url => {
  return (
    url.indexOf("http://localhost") >= 0 ||
    url.indexOf("http://127.0.0.1") >= 0 ||
    url.indexOf("/") === 0
  );
};

let supportKeepAlive = false;

const getAgent = url => {
  if (url.toLowerCase().indexOf("https") === 0) {
    return agent.httpsAgent;
  }
  return agent.httpAgent;
};

ElectrodeFetch.prototype.inject = function(url, options) {
  options = options || {};
  const injectOptions = {
    url,
    method: options.method || "GET",
    headers: options.headers || {}
  };
  if (options.body) {
    injectOptions.payload = options.body;
  }
  try {
    assert(this._server.app.namespace, "namespace is not set on server");
    const request = this._server.app.namespace.get("request");
    assert(request, "could not get request from namespace");
    assert(request.app.jwt && request.app.jwtCookie, "jwt or jwtCookie missing from request.app");
    injectOptions.headers["x-csrf-jwt"] = request.app.jwt;
    injectOptions.headers.Cookie = `x-csrf-jwt=${request.app.jwtCookie}`;
  } catch (err) {
    this._server.log(["warn"], {
      msg: "Unable to set JWT on inject request",
      url,
      method: injectOptions.method,
      reason: err.message
    });
  }

  // istanbul ignore next
  const conn = isHapi17 ? this._server : this._server.select("default");
  return conn.inject(injectOptions).then(resp => {
    resp.status = resp.statusCode;
    return resp;
  });
};

const instance = new ElectrodeFetch({
  manageJwt: false,
  keepAlive: true,
  fetch: isoFetch
});

instance._serverOnly = true;

instance.realFetch = ElectrodeFetch.prototype.fetch;

instance.fetch = function(url, options, translate) {
  options = options || {};

  if (!options.noInject && isLocal(url) && this._server) {
    options._fetch = this.inject.bind(this);
    translate = resp => {
      return resp.result;
    };
  }

  if (
    supportKeepAlive &&
    (options.keepAlive || (options.keepAlive !== false && this.options.keepAlive))
  ) {
    options.agent = getAgent(url);
  }

  return this.realFetch(url, options, translate);
};

instance.setServer = function(server) {
  this._server = server;
};

module.exports = {
  instance: instance,
  fetch: instance.fetch.bind(instance),
  fetchJSON: instance.fetchJSON.bind(instance),
  setListener: instance.setListener.bind(instance),
  setFetch: instance.setFetch.bind(instance),
  setGenerateCorrelationID: instance.setGenerateCorrelationID.bind(instance),
  setGetJWT: instance.setGetJWT.bind(instance),
  setServer: instance.setServer.bind(instance),
  supportKeepAlive: flag => {
    supportKeepAlive = flag;
  }
};
