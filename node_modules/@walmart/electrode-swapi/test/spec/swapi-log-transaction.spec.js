"use strict";

/* eslint-disable camelcase */

const Hapi = require("hapi");
const _ = require("lodash");
const chai = require("chai");
const OOSpec = require("../data/swagger.json");
const expect = chai.expect;
const txConst = require("@walmart/electrode-log-transaction/lib/constants");

describe("swapi log transaction", function() {
  this.timeout(10000);
  let server;
  let logs;
  let metrics;
  let request;
  let logTransaction;
  let OOClient;
  let ElectrodeSwapi;
  this.timeout(10000);

  beforeEach(() => {
    delete require.cache[require.resolve("@walmart/electrode-log-transaction")];
    delete require.cache[require.resolve("../../lib/electrode-swapi.js")];
    delete require.cache[require.resolve("../lib/oo-swag-client.js")];
    delete require.cache[require.resolve("../lib/api-key-client.js")];
    logTransaction = require("@walmart/electrode-log-transaction");
    ElectrodeSwapi = require("../../lib/electrode-swapi.js");
    ElectrodeSwapi.supportKeepAlive(false);
    OOClient = require("../lib/oo-swag-client.js");

    request = {
      log: function() {
        logs.push(Array.prototype.slice.apply(arguments));
      }
    };
    logs = [];
    metrics = [];
    process.send = function() {
      metrics.push(Array.prototype.slice.apply(arguments));
    };
  });

  before(done => {
    server = new Hapi.Server();
    server.connection({ port: 3000 });

    server.route([
      {
        method: "get",
        path: "/ok",
        handler: (req, reply) => {
          reply(OOSpec);
        }
      },
      {
        method: "post",
        path: "/account/profile/authentication_token",
        handler: (req, reply) => {
          if (req.payload.user.username === "vip") {
            reply({});
          } else {
            reply({ error: "Invalid login or password." })
              .header("Content-Type", "application/json; charset=utf-8")
              .header("Content-Length", 58)
              .code(401);
          }
        }
      }
    ]);

    server.start(err => done(err));
  });

  after(() => {
    delete process.send;
    server.stop(() => {});
  });

  const emptyConfigLayout = {
    electrode: {
      hostIP: "127.0.0.1"
    },
    services: {
      privateKey: {},
      providers: {}
    }
  };

  function makeSafeConfig(config, providerName) {
    const safeConfig = _.merge(_.cloneDeep(emptyConfigLayout), {
      services: {
        providers: {
          [providerName]: config || {}
        }
      }
    });
    return safeConfig;
  }

  /* eslint-disable max-params */
  function cliCreate(Client, host, override, config) {
    return Client.create(makeSafeConfig(config, OOClient.providerName), override).then(client => {
      chai.assert.ok(client);
      chai.assert.ok(client.swagger);
      chai.assert.equal(client.swagger.host, host);
      return client;
    });
  }

  function create(host, override, config) {
    return cliCreate(OOClient, host, override, config);
  }
  const okAuthInfo = {
    user: {
      username: "vip",
      password: "keepAlive"
    }
  };

  const failAuthInfo = {
    user: {
      username: "test",
      password: "test"
    }
  };

  it("should work when transaction is disabled", function() {
    const callApi = (client, info) => {
      client.supportKeepAlive(false);
      return client.withMeta(request).authenticationToken({ authInfo: info }, {});
    };
    let error;
    return create(
      "localhost:3000",
      {
        host: "localhost:3000",
        schemes: ["http"]
      },
      { transactionLogs: false }
    )
      .tap(client => callApi(client, okAuthInfo))
      .tap(client => callApi(client, failAuthInfo))
      .catch(err => (error = err))
      .then(() => {
        expect(error).to.be.an.Error;
        expect(error.errObj.message).to.equal("Unauthorized");
        expect(metrics[0][0].data.status).to.equal(200);
        expect(metrics[1][0].data.status).to.equal(401);
        expect(logs).to.deep.equal([]);
      });
  });

  it("should add transaction to main thread without context", function() {
    logTransaction.beginTop(request, { msg: "Request received" });
    logTransaction.addCall(request, "test 1", "test 1");

    const callApi = (client, info) => {
      client.supportKeepAlive(false);
      return client.withMeta(request).authenticationToken({ authInfo: info }, {});
    };
    let error;
    return create("localhost:3000", { host: "localhost:3000", schemes: ["http"] })
      .tap(client => callApi(client, okAuthInfo))
      .tap(client => callApi(client, failAuthInfo))
      .catch(err => (error = err))
      .then(() => {
        expect(error).to.be.an.Error;
        expect(error.errObj.message).to.equal("Unauthorized");
        expect(metrics[0][0].data.status).to.equal(200);
        expect(metrics[1][0].data.status).to.equal(401);
        const topContext = logs[0][1][txConst.context];
        expect(topContext.isTopLevel).to.equal(true);
        //
        const test1Context = logs[1][1][txConst.context];
        expect(test1Context.parentTxId).to.equal(topContext.txId);
        //
        const tx1BeginContext = logs[2][1][txConst.context];
        expect(tx1BeginContext.parentTxId).to.equal(test1Context.txId);
        expect(logs[2][1].msg).includes("begin operation");
        //
        const tx1EndContext = logs[3][1][txConst.context];
        expect(tx1EndContext.parentTxId).to.equal(test1Context.txId);
        expect(logs[3][1].msg).includes("complete operation");
        //
        const tx2BeginContext = logs[4][1][txConst.context];
        expect(tx2BeginContext.parentTxId).to.equal(test1Context.txId);
        expect(logs[4][1].msg).includes("begin operation");
        //
        expect(logs[5][1].msg).includes("electrode-transaction context run caught exception");
        //
        const tx2EndContext = logs[6][1][txConst.context];
        expect(tx2EndContext.parentTxId).to.equal(test1Context.txId);
        expect(logs[6][1].msg).includes("failed operation");
      });
  });
});
