"use strict";

const async = require("async");
const request = require("request");
const rewire = require("rewire");
const sinon = require("sinon");
const expect = require("chai").expect;

const getClientId = rewire("../../../lib/utils/get-client-id");

describe("utils - getClientId", () => {

  const ID = 0x75BCD15;
  const RANDOM_ID = 0x3ADE68B1;
  const options = {};
  const sandbox = sinon.sandbox.create();
  let randomStub = null;

  beforeEach((done) => {
    randomStub = sandbox.stub(getClientId.__get__("_"), "random").returns(RANDOM_ID);
    getClientId.__set__("clientId", null);
    done();
  });

  afterEach((done) => {
    sandbox.restore();
    done();
  });


  it("should retrieve a hash for the client ID", (done) => {
    sandbox.stub(request, "get").yieldsAsync(null, {statusCode: 200}, {payload: ID.toString(16)});
    getClientId(options, (error, clientId) => {
      expect(error).to.be.null;
      expect(clientId).to.equal(ID);
      done();
    });
  });

  it("should return the cashed client ID", (done) => {
    getClientId.__set__("clientId", ID);
    getClientId(options, (error, clientId) => {
      expect(error).to.be.null;
      expect(clientId).to.equal(ID);
      done();
    });
  });

  it("should handle request error", (done) => {
    sandbox.stub(request, "get").yieldsAsync(null, {statusCode: 404});
    getClientId(options, (error, clientId) => {
      expect(error).to.be.null;
      expect(clientId).to.equal(RANDOM_ID);
      done();
    });
  });

  it("should handle bad response", (done) => {
    sandbox.stub(request, "get").yieldsAsync(null, {statusCode: 200}, "<html></html>");
    getClientId(options, (error, clientId) => {
      expect(error).to.be.null;
      expect(clientId).to.equal(RANDOM_ID);
      done();
    });
  });

  it("should handle invalid payload", (done) => {
    sandbox.stub(request, "get").yieldsAsync(null, {statusCode: 200}, {payload: "foo"});
    getClientId(options, (error, clientId) => {
      expect(error).to.be.null;
      expect(clientId).to.equal(RANDOM_ID);
      done();
    });
  });

  it("should implement a queue for multiple async calls", (done) => {
    const COUNT = 500;
    const getClientIdSpy = sandbox.spy(getClientId);
    const requestGetStub = sandbox.stub(request, "get").yieldsAsync(new Error());

    async.times(COUNT, (n, next) => {
      getClientIdSpy({}, next);
    }, (error) => {
      expect(error).to.not.exist;
      expect(getClientIdSpy.callCount).to.equal(COUNT);
      expect(requestGetStub.calledOnce).to.be.true;
      expect(randomStub.calledOnce).to.be.true;
      done();
    });
  });

});
