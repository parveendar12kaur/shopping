"use strict";

const EventEmitter = require("events").EventEmitter;

const async = require("async");
const expect = require("chai").expect;
const rewire = require("rewire");
const sinon = require("sinon");

const utils = require("../utils");
const KafkaWriter = rewire("../../lib/kafka-writer");

const ERROR = new Error("Phasellus sagittis pellentesque nulla");
const SUCCESS_MESSAGE = "Lorem ipsum dolor sit amet";
const FAIL_MESSAGE = "Vivamus condimentum dictum dapibus";

class MockProducer extends EventEmitter {

  constructor(client, options) {
    super();
    this.client = client;
    const self = this;
    setTimeout(() => {
      if (options && options.fail) {
        self.emit("error", new Error("Problem creating producer"));
      } else {
        self.emit("ready");
        self.ready = true;
      }
    }, 20);
  }

  send(payloads, cb) {
    if (payloads[0].messages === FAIL_MESSAGE) {
      return cb(ERROR);
    }
    cb();
  }
}

class MockClient {
  close() {}
}

describe("kafkaWriter", () => {

  const sandbox = sinon.sandbox.create();
  const internals = KafkaWriter.__get__("internals");
  const kafka = KafkaWriter.__get__("kafka");

  let kafkaWriter;

  beforeEach(() => {
    sandbox.stub(kafka, "Producer", (client) => {
      return new MockProducer(client);
    });
    sandbox.stub(kafka, "Client", () => {
      return new MockClient();
    });

    sandbox.spy(KafkaWriter.prototype, "_send");

    kafkaWriter = new KafkaWriter();
    kafkaWriter.on("error", () => {}); // avoid throwing due to no listeners
  });

  afterEach(() => {
    sandbox.restore();
  });

  describe("internals.getZookeeper", () => {

    let origCloudEnv;

    before(() => {
      origCloudEnv = process.env.ONEOPS_CLOUD;
    });

    after(() => {
      process.env.ONEOPS_CLOUD = origCloudEnv;
    });

    it("should return the QA Zookeeper cluste if ONEOPS_CLOUD is not known datacenter", () => {
      process.env.ONEOPS_CLOUD = "";
      expect(internals.getZookeeper()).to.equal(internals.ZOOKEEPER_QA);
      process.env.ONEOPS_CLOUD = "unknown";
      expect(internals.getZookeeper()).to.equal(internals.ZOOKEEPER_QA);
    });

    it("should return the DAL Zookeeper cluster", () => {
      process.env.ONEOPS_CLOUD = "prod-dal3";
      const result = internals.getZookeeper();
      const zookeepers = result.split(",");
      zookeepers.forEach((val, i) => {
        expect(val).to.equal(`dal-kafka-zk0${i}.bfd.walmart.com:9091`);
      });
    });
  });

  describe("constructor", () => {

    it("should use default zookeeper setting if none is given", () => {
      const writer = new KafkaWriter();
      expect(writer).to.have.deep.property("_options.zookeeper", internals.getZookeeper());
    });

    it("should use specified zookeeper option", () => {
      const writer = new KafkaWriter({ zookeeper: "thisone" });
      expect(writer).to.have.deep.property("_options.zookeeper", "thisone");
    });

    it("should start with null producer, 0 error streak  and paused queue", () => {
      const writer = new KafkaWriter();
      expect(writer).to.have.property("_producer", null);
      expect(writer).to.have.property("_queue");
      const queue = writer._queue;
      expect(queue).to.have.property("tasks").that.is.an.empty("array");
      expect(queue).to.have.property("started", false);
      expect(queue).to.have.property("paused", true);
    });
  });

  describe("_createProducer", () => {

    it("should skip instantiation if producer exists", (done) => {
      kafkaWriter._producer = "fake";

      kafkaWriter._createProducer((err) => {
        utils.wrapTryCatch(done, () => {
          expect(err).to.not.exist;
          expect(kafkaWriter).to.have.property("_producer", "fake");
          expect(kafka.Producer).to.have.not.been.called;
        });
      });
    });

    it("should create kafka Client and Producer", (done) => {
      expect(kafkaWriter).to.have.property("_producer", null);

      kafkaWriter._createProducer((err) => {
        utils.wrapTryCatch(done, () => {
          expect(err).to.not.exist;
          expect(kafka.Client).to.have.been.calledOnce;
          expect(kafka.Client).to.have.been.calledWith(internals.getZookeeper());
          expect(kafka.Producer).to.have.been.calledOnce;
          expect(kafkaWriter).to.have.property("_producer").that.is.an("object");
        });
      });
    });

    it("should set _producer and resume the queue", (done) => {
      expect(kafkaWriter).to.have.property("_producer", null);
      expect(kafkaWriter).to.have.deep.property("_queue.paused", true);

      kafkaWriter._createProducer((err) => {
        utils.wrapTryCatch(done, () => {
          expect(err).to.not.exist;
          expect(kafkaWriter).to.have.property("_producer").that.is.an("object");
          expect(kafkaWriter).to.have.deep.property("_queue.paused", false);
        });
      });
    });

    it("should succeed even if callback is omitted", (done) => {
      const errListener = sandbox.stub();
      kafkaWriter.on("error", errListener);
      kafkaWriter._createProducer();
      setTimeout(() => {
        utils.wrapTryCatch(done, () => {
          expect(errListener).to.have.not.been.called;
          expect(kafkaWriter).to.have.property("_producer").that.is.an("object");
          expect(kafkaWriter).to.have.deep.property("_queue.paused", false);
        });
      }, 50);
    });

    it("should set up error listeners on producer", (done) => {
      kafkaWriter._createProducer((err) => {
        utils.wrapTryCatch(done, () => {
          expect(err).to.not.exist;
          const listeners = kafkaWriter._producer.listeners("error");
          expect(listeners).to.be.an("array").with.length(2);
          expect(listeners[0]).to.be.a("function");
          expect(listeners[1]).to.be.a("function");
          // .once (one-time) listeners have a listener property
          expect(listeners[0]).to.have.property("listener");
          expect(listeners[1]).to.not.have.property("listener");
        });
      });
    });

    it("should yield error after internals.RETRIES failed restarts", (done) => {
      kafka.Producer.restore();
      sandbox.stub(kafka, "Producer", (client) => {
        return new MockProducer(client, { fail: true });
      });

      kafkaWriter._createProducer((err) => {
        utils.wrapTryCatch(done, () => {
          expect(err).to.have.property("message", "Unable to create kafka producer");
          expect(err).to.have.property("kafkaError").that.is.an("Error");
          expect(err).to.have.deep.property("kafkaError.message", "Problem creating producer");
          expect(kafka.Producer).to.have.callCount(internals.RETRIES + 1);
          expect(kafkaWriter).to.have.property("_producer", null);
          expect(kafkaWriter).to.have.deep.property("_queue.paused", true);
        });
      });
    });

    it("should succeed if producer startup fails 4 times and then succeeds", (done) => {
      kafka.Producer.restore();
      let call = 0;
      sandbox.stub(kafka, "Producer", (client) => {
        call++;
        if (call < internals.RETRIES) {
          return new MockProducer(client, { fail: true });
        }
        return new MockProducer(client);
      });

      kafkaWriter._createProducer((err) => {
        utils.wrapTryCatch(done, () => {
          expect(err).to.not.exist;
          expect(kafka.Producer).to.have.callCount(internals.RETRIES);
          expect(kafkaWriter).to.have.property("_producer").that.is.an("object");
          expect(kafkaWriter).to.deep.have.property("_queue.paused", false);
        });
      });
    });
  });

  describe("_restartProducer", () => {

    it("should return early if _restarting is true", (done) => {
      sandbox.spy(kafkaWriter, "closeClient");
      sandbox.spy(async, "retry");

      kafkaWriter._restarting = true;
      kafkaWriter._restartProducer(internals.RETRIES, () => {
        utils.wrapTryCatch(done, () => {
          expect(kafkaWriter.closeClient).to.have.not.been.called;
          expect(async.retry).to.have.not.been.called;
        });
      });
    });

    it("should close and remove listeners from existing producer", () => {
      sandbox.stub(kafkaWriter, "closeClient");
      sandbox.stub(kafkaWriter, "_createProducer");
      const origProducer = { removeAllListeners: sandbox.stub() };
      kafkaWriter._producer = origProducer;

      kafkaWriter._restartProducer(internals.RETRIES);
      expect(kafkaWriter.closeClient).to.have.been.calledOnce;
      expect(origProducer.removeAllListeners).to.have.been.calledOnce;
      expect(kafkaWriter).to.have.property("_producer").that.is.null;
    });

    it("should call async.retry for _createProducer", () => {
      sandbox.spy(async, "retry");
      sandbox.spy(kafkaWriter, "_createProducer");

      kafkaWriter._restartProducer(3);
      const args = async.retry.firstCall.args;
      expect(args[0]).to.equal(3);
      expect(args[1]).to.be.a("function");
      expect(args[2]).to.be.a("function");
      expect(kafkaWriter._createProducer).to.have.been.calledOnce;
    });

    it("should clear queue and yield error after specified number of retries", (done) => {
      kafka.Producer.restore();
      sandbox.stub(kafka, "Producer", (client) => {
        return new MockProducer(client, { fail: true });
      });
      sandbox.spy(kafkaWriter, "_clearQueue");

      kafkaWriter._queue.push("one");
      kafkaWriter._queue.push("two");

      kafkaWriter._restartProducer(4, (err) => {
        utils.wrapTryCatch(done, () => {
          expect(err).to.have.property("message", "Unable to create kafka producer");
          expect(err).to.have.property("kafkaError").that.is.an("Error");
          expect(err).to.have.deep.property("kafkaError.message", "Problem creating producer");

          expect(kafka.Producer).to.have.callCount(4);
          expect(kafkaWriter).to.have.property("_producer", null);

          expect(kafkaWriter._send).to.have.not.been.called;

          expect(kafkaWriter._clearQueue).to.have.been.calledOnce;
          expect(kafkaWriter._queue.length()).to.equal(0);
          expect(kafkaWriter).to.deep.have.property("_queue.paused", true);
        });
      });
    });
  });

  describe("_send", () => {

    it("should wrap message and call _producer.send", (done) => {
      kafkaWriter._producer = { send: sandbox.stub().yields() };
      kafkaWriter._send("beep", () => {
        utils.wrapTryCatch(done, () => {
          expect(kafkaWriter._producer.send).to.have.been.calledOnce;
          const payload = kafkaWriter._producer.send.firstCall.args[0];
          expect(payload).to.be.an("array").with.length(1);
          expect(payload[0]).to.have.property("attributes", internals.PAYLOAD_ATTRIBUTES);
          expect(payload[0]).to.have.property("messages", "beep");
          expect(payload[0]).to.have.property("topic", internals.PAYLOAD_TOPIC);
        });
      });
    });
  });

  describe("_clearQueue", () => {

    it("should result in an empty queue", () => {
      kafkaWriter._queue.push("message");
      kafkaWriter._queue.push("msg");
      kafkaWriter._queue.push("logstatement");
      expect(kafkaWriter._queue.length()).to.equal(3);
      kafkaWriter._clearQueue();
      expect(kafkaWriter._queue.length()).to.equal(0);
    });

    it("should call callback for each task", () => {
      const callback = sandbox.stub();
      kafkaWriter._queue.push("message", callback);
      kafkaWriter._queue.push("msg", callback);
      kafkaWriter._queue.push("logstatement", callback);
      expect(kafkaWriter._queue.length()).to.equal(3);
      kafkaWriter._clearQueue();
      expect(callback).to.have.callCount(3);
      expect(callback).to.have.always.been.calledWithExactly(undefined);
      expect(kafkaWriter._queue.length()).to.equal(0);
    });

    it("should call callbacks with error if provided", () => {
      const callback = sandbox.stub();
      const err = new Error("Unable to create kafka producer");
      kafkaWriter._queue.push("message", callback);
      kafkaWriter._queue.push("msg", callback);
      kafkaWriter._queue.push("logstatement", callback);
      expect(kafkaWriter._queue.length()).to.equal(3);
      kafkaWriter._clearQueue(err);
      expect(callback).to.have.callCount(3);
      expect(callback).to.have.always.been.calledWithExactly(err);
      expect(kafkaWriter._queue.length()).to.equal(0);
    });
  });

  describe("write", () => {

    let errorListener;

    beforeEach(() => {
      sandbox.spy(kafkaWriter._queue, "push");
      errorListener = sandbox.stub();
      kafkaWriter.on("error", errorListener);
    });

    describe("with pre-existing producer", () => {

      beforeEach((done) => {
        kafkaWriter._createProducer(done);
      });

      it("should add message to queue; queue should call _.send", (done) => {
        expect(kafkaWriter).to.have.deep.property("_queue.paused", false);

        kafkaWriter.write(SUCCESS_MESSAGE);
        const queue = kafkaWriter._queue;
        expect(queue.push).to.have.been.calledOnce;
        expect(queue.push).to.have.been.calledWith(SUCCESS_MESSAGE);

        setTimeout(() => {
          utils.wrapTryCatch(done, () => {
            expect(queue).to.have.property("paused", false);
            expect(queue.length()).to.equal(0);
            expect(kafkaWriter._send).to.have.been.calledOnce;
            expect(kafkaWriter._send.firstCall.args[0]).to.equal(SUCCESS_MESSAGE);
            expect(errorListener).to.have.not.been.called;
          });
        }, 20);
      });

      it("should retry if producer send fails", (done) => {
        sandbox.spy(kafkaWriter, "_restartProducer");
        sandbox.spy(kafkaWriter._queue, "unshift");
        sandbox.stub(kafkaWriter._producer, "send")
          .onFirstCall().callsArgWith(1, ERROR)
          .onSecondCall().callsArg(1);

        kafkaWriter.write("hi");
        expect(kafkaWriter._queue.push).to.have.been.calledOnce;
        setTimeout(() => {
          utils.wrapTryCatch(done, () => {
            expect(errorListener).to.have.not.been.called;
            expect(kafkaWriter._restartProducer).to.have.been.calledOnce;
            expect(kafkaWriter._restartProducer).to.have.been.calledWithExactly(1);
            expect(kafkaWriter._queue.unshift).to.have.been.calledOnce;
            expect(kafkaWriter._queue.unshift).to.have.been.calledWith("hi");
            expect(kafkaWriter._send).to.have.been.calledTwice;
            expect(kafkaWriter._send).to.have.always.been.calledWith("hi");
          });
        }, 40);
      });

      it("should emit error if producer send fails twice", (done) => {
        sandbox.spy(kafkaWriter, "_restartProducer");
        sandbox.spy(kafkaWriter._queue, "unshift");

        kafkaWriter.write(FAIL_MESSAGE);
        expect(kafkaWriter._queue.push).to.have.been.calledOnce;
        setTimeout(() => {
          utils.wrapTryCatch(done, () => {
            expect(errorListener).to.have.been.calledOnce;
            expect(errorListener).to.have.been.calledWithExactly(ERROR);
            expect(kafkaWriter._restartProducer).to.have.been.calledOnce;
            expect(kafkaWriter._restartProducer).to.have.been.calledWithExactly(1);
            expect(kafkaWriter._queue.unshift).to.have.been.calledOnce;
            expect(kafkaWriter._queue.unshift).to.have.been.calledWith(FAIL_MESSAGE);
            expect(kafkaWriter._send).to.have.been.calledTwice;
            expect(kafkaWriter._send).to.have.always.been.calledWith(FAIL_MESSAGE);
          });
        }, 30);
      });

      it("should add to queue without calling back if queue is paused", () => {
        kafkaWriter._queue.pause();
        expect(kafkaWriter._queue.length()).to.equal(0);
        kafkaWriter.write(SUCCESS_MESSAGE, () => {
          throw new Error("write should not complete when queue is paused");
        });
        expect(kafkaWriter._queue.length()).to.equal(1);
      });

      it("should not crash if zookeeper client throws error", (done) => {
        kafkaWriter.write(SUCCESS_MESSAGE, utils.wrapTryCatch(done, (error) => {
          expect(error).to.not.exist;

          const errListener = sandbox.stub();
          kafkaWriter.on("error", errListener);

          kafkaWriter._producer.emit("error", new Error("zookeeper client err"));
          expect(errListener).to.have.been.calledOnce;
          expect(kafkaWriter._producer).to.exist;
        }));
      });
    });

    describe("without pre-existing producer", () => {

      it("should not create more than one Producer if write is called multiple times", (done) => {
        expect(kafkaWriter).to.have.property("_producer", null);
        kafkaWriter.write(SUCCESS_MESSAGE);
        kafkaWriter.write(SUCCESS_MESSAGE);
        kafkaWriter.write(SUCCESS_MESSAGE);
        kafkaWriter.write(SUCCESS_MESSAGE);
        kafkaWriter.write(SUCCESS_MESSAGE);
        setTimeout(() => {
          utils.wrapTryCatch(done, () => {
            expect(errorListener).to.have.not.been.called;
            expect(kafkaWriter._queue.push).to.have.callCount(5);
            expect(kafka.Producer).to.have.been.calledOnce;
            expect(kafkaWriter).to.have.property("_producer");
          });
        }, 30);
      });

      it("should not retry if it triggered retries already", function (done) {
        this.timeout(4000);
        kafka.Producer.restore();
        sandbox.stub(kafka, "Producer", (client) => {
          return new MockProducer(client, { fail: true });
        });
        sandbox.spy(kafkaWriter, "_restartProducer");
        sandbox.spy(kafkaWriter._queue, "unshift");

        expect(kafkaWriter).to.have.property("_producer", null);

        kafkaWriter.write("anything");
        setTimeout(() => {
          utils.wrapTryCatch(done, () => {
            expect(errorListener).to.have.been.calledOnce;
            expect(errorListener).to.have.been.calledWithExactly(ERROR);
            expect(kafkaWriter._queue.push).to.have.been.calledOnce;
            expect(kafkaWriter._restartProducer).to.have.been.calledOnce;
            expect(kafkaWriter._restartProducer).to.have.been.calledWith(internals.RETRIES);
            expect(kafkaWriter._queue.unshift).to.have.not.been.called;
            expect(kafkaWriter._send).to.have.not.been.called;
          });
        }, 40);
      });
    });
  });

  describe("closeClient", () => {

    it("should pause the queue and call _producer.client.close", (done) => {
      sandbox.spy(MockClient.prototype, "close");
      kafkaWriter._createProducer((err) => {
        utils.wrapTryCatch(done, () => {
          expect(err).to.not.exist;
          expect(kafkaWriter).to.have.property("_producer");
          expect(kafkaWriter).to.have.deep.property("_queue.paused", false);
          kafkaWriter.closeClient();
          expect(kafkaWriter._producer.client.close).to.have.been.calledOnce;
          expect(kafkaWriter).to.have.deep.property("_queue.paused", true);
        });
      });
    });

    it("should just pause the queue if producer does not exist", () => {
      expect(kafkaWriter).to.have.property("_producer", null);
      expect(kafkaWriter).to.not.have.property("_producerPending");
      sandbox.spy(kafkaWriter._queue, "pause");
      kafkaWriter.closeClient();
      expect(kafkaWriter._queue.pause).to.have.been.calledOnce;
    });

    it("should pause queue and set _closePending if _producerPending is true", () => {
      class SlowProducer extends EventEmitter {
        constructor(client) {
          super();
          this.client = client;
        }

        triggerReady() {
          this.emit("ready");
        }
      }
      const producer = new SlowProducer(new MockClient());
      sandbox.spy(producer.client, "close");
      kafka.Producer.restore();
      sandbox.stub(kafka, "Producer").returns(producer);

      kafkaWriter._createProducer();

      expect(kafkaWriter).to.have.property("_producer", null);
      expect(kafkaWriter).to.have.property("_producerPending", true);
      expect(kafkaWriter).to.not.have.property("_closePending");

      kafkaWriter.closeClient();

      expect(kafkaWriter).to.have.property("_closePending", true);
      expect(producer.client.close).to.not.have.been.called;
      sandbox.spy(kafkaWriter, "closeClient");

      producer.triggerReady();

      expect(kafkaWriter.closeClient).to.have.been.calledOnce;
      expect(kafkaWriter).to.have.property("_closePending", false);
      expect(producer.client.close).to.have.been.calledOnce;
    });
  });
});
