"use strict";

const expect = require("chai").expect;
const os = require("os");
const sinon = require("sinon");

const LogMon = require("../../lib");
const DualWriter = require("../../lib/dual-writer");
const tutils = require("../utils");

describe("logmon index", () => {

  const sandbox = sinon.sandbox.create();
  let logmon;

  beforeEach(() => {
    logmon = new LogMon();
  });

  afterEach(() => {
    sandbox.restore();
  });

  describe("constructor", () => {

    it("should fallback to default options", () => {

      const assembly = process.env.ONEOPS_ASSEMBLY;
      const platform = process.env.ONEOPS_PLATFORM;

      expect(logmon._options).to.deep.equal({
        appId: `${assembly || ""}-${platform || ""}`,
        buildId: "-",
        groupId: assembly || "-",
        baseUrl: "http://lms.qa2.lms.platform.ctf3a.qa.walmart.com/",
        dataCenter: process.env.ONEOPS_CLOUD || "-",
        environment: process.env.ONEOPS_ENVIRONMENT || "-",
        filePath: "/log/logmon/logmon_new.log",
        host: process.env.ONEOPS_CI_NAME || os.hostname(),
        marker: "WMPLATFORMLOGMSG",
        maxSize: 104857600,
        emitErrors: false
      });
    });
  });

  describe("LogMon.getTxIdSync", () => {

    it("should succeed with only clientId provided", () => {
      const txId = LogMon.getTxIdSync({ clientId: 22 });
      expect(txId).to.be.a("string").with.length(27);
    });

    it("should return a TxId from given options", () => {
      const options = {
        clientId: 0x778899AA,
        threadId: 2919,
        timestamp: 1412963899405,
        sequence: 1902
      };

      expect(LogMon.getTxIdSync(options)).to.equal("778899aa-b67-148fb36180d76e");
    });
  });

  describe("getClientId", () => {

    it("should return a clientId from defaults", (done) => {
      logmon.getClientId((error, clientId) => {
        expect(error).to.not.exist;
        expect(clientId).to.be.within(0, 0xFFFFFFFF);
        done();
      });
    });

    it("should throw an error when calling getClientId without a callback function", (done) => {
      expect(() => {
        logmon.getClientId();
      }).to.throw(/callback function must be provided/);
      done();
    });
  });

  describe("getTxId", () => {

    it("should return a TxId from defaults", (done) => {
      logmon.getTxId((error, txId) => {
        expect(error).to.not.exist;
        expect(txId).to.match(/[0-9a-f]{8}-[0-9a-f]{3}-[0-9a-f]{14}/);
        done();
      });
    });

    it("should return a TxId from given options", (done) => {
      const options = {
        threadId: 2919,
        timestamp: 1412963899405,
        sequence: 1902
      };

      logmon.getTxId(options, (error, txId) => {
        expect(error).to.be.null;
        expect(txId).to.match(/[0-9a-f]{8}-b67-148fb36180d76e/);
        done();
      });
    });

    it("should throw an error when calling getTxId without a callback function", (done) => {
      expect(() => {
        logmon.getTxId();
      }).to.throw(/callback function must be provided/);
      done();
    });
  });

  describe("write", () => {

    let writerWriteStub;
    let errorListener;

    beforeEach(() => {
      writerWriteStub = sandbox.stub(DualWriter.prototype, "write");
      errorListener = sandbox.stub();
      logmon.on("error", errorListener);
    });

    it("should write a log message with defaults", (done) => {
      sandbox.stub(logmon, "getTxId").yieldsAsync(null, "msgId");
      logmon.write({});
      expect(logmon.getTxId).to.have.been.calledOnce;
      setTimeout(() => {
        tutils.wrapTryCatch(done, () => {
          expect(writerWriteStub).to.have.been.calledOnce;
          expect(errorListener).to.have.not.been.called;
        });
      }, 20);
    });

    it("should write a log message", (done) => {
      const messageId = "7044e341-a26-14943043a49658";
      sandbox.stub(logmon, "getTxId").yieldsAsync(null, messageId);

      const data = {
        appId: "tempo-app",
        buildId: "1.0",
        duration: 123,
        environment: "dev",
        epoch: 1412963899405,
        groupId: "tempo",
        host: "ELDORADO",
        dataCenter: "test3",
        payload: "foo=bar;baz=wow",
        sessionId: "1412963899405-68455-1902",
        topTxId: "5dacadd7-b67-148fb3617fdeb1",
        txId: "5dacadd7-b67-148fb3617fdeb1",
        type: "DEBUG"
      };
      logmon.write(data);
      expect(logmon.getTxId).to.have.been.calledOnce;
      setTimeout(() => {
        tutils.wrapTryCatch(done, () => {
          expect(writerWriteStub).to.have.been.calledOnce;
          expect(writerWriteStub).to.have.been.calledWithExactly([
            "WMPLATFORMLOGMSG",
            data.epoch,
            "2014-10-10 17:58:19.405",
            data.host,
            data.txId,
            "-",
            data.topTxId,
            data.sessionId,
            "-",
            data.appId,
            data.dataCenter,
            data.environment,
            data.buildId,
            messageId,
            data.type,
            "-",
            "-",
            "-",
            data.groupId,
            data.duration,
            data.payload.replace(/=/g, "//=")
          ].join("\t"));
        });
      }, 20);
    });

    it("should skip getTxId if data has messageId", () => {
      sandbox.stub(logmon, "getTxId").yieldsAsync("NOT EXPECTED");

      logmon.write({ messageId: "abd356" });
      expect(logmon.getTxId).to.have.not.been.called;
      expect(writerWriteStub).to.have.been.calledOnce;
    });

    it("should emit error but still write if getTxId errors", (done) => {
      logmon._options.emitErrors = true;
      sandbox.stub(logmon, "getTxId").yieldsAsync("boom");

      logmon.write();
      expect(logmon.getTxId).to.have.been.calledOnce;
      setTimeout(() => {
        tutils.wrapTryCatch(done, () => {
          expect(errorListener).to.have.been.calledOnce;
          expect(errorListener).to.have.been.calledWithExactly("boom");
          expect(writerWriteStub).to.have.been.calledOnce;
        });
      }, 10);
    });
  });

  describe("closeKafka", () => {

    it("should call DualWriter.closeKafka()", () => {
      sandbox.stub(logmon._writer, "closeKafka");
      logmon.closeKafka();
      expect(logmon._writer.closeKafka).to.have.been.calledOnce;
    });
  });

  describe("error handling", () => {

    it("should not emit errors from dualWriter by default", (done) => {
      expect(logmon).to.have.deep.property("_options.emitErrors", false);
      logmon.on("error", (err) => {
        throw new Error(`Logmon emitted error ${err}`);
      });

      logmon._writer.emit("error", "testerror");
      setTimeout(done, 20);
    });

    it("should emit an error when dualWriter does if emitErrors is true", (done) => {
      logmon._options.emitErrors = true;
      logmon.on("error", (err) => {
        expect(err).to.equal("testerror");
        done();
      });

      logmon._writer.emit("error", "testerror");
    });
  });
});
