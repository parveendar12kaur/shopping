"use strict";

const async = require("async");
const sinon = require("sinon");
const expect = require("chai").expect;

const FileWriter = require("../../lib/file-writer");

describe("fileWriter", () => {

  const MESSAGE_24 = "Lorem ipsum dolor sit am";

  let sandbox;

  before(() => {
    sandbox = sinon.sandbox.create();
  });

  afterEach(() => {
    sandbox.restore();
  });

  it("should emit error and end stream for invalid path", (done) => {
    const invalidWriter = new FileWriter({ filePath: "boop/bop/bip" });
    sandbox.spy(invalidWriter._fileStream, "end");
    invalidWriter.on("error", (err) => {
      expect(err).to.have.property("code", "ENOENT");
      setTimeout(() => {
        expect(invalidWriter._fileStream.end).to.have.been.calledOnce;
        done();
      }, 100);
    });
  });

  it("should emit error trying to write after ENOENT", (done) => {
    let errNo = 0;
    const verifyInitialError = sandbox.spy((err) => {
      if (errNo === 0) {
        expect(err).to.have.property("code", "ENOENT");
      } else {
        expect(err).to.have.property("message", "write after end");
      }
      errNo++;
    });
    const invalidWriter = new FileWriter({ filePath: "boop/bop/bip" });
    invalidWriter.on("error", verifyInitialError);

    setTimeout(() => {
      invalidWriter.write("trying to write");
      setTimeout(() => {
        expect(verifyInitialError).to.have.been.calledTwice;
        done();
      }, 10);
    }, 100);
  });

  describe("valid path", () => {

    let writer;
    let drainListener;

    beforeEach(() => {
      writer = new FileWriter({ filePath: "/dev/null" });
      sandbox.spy(writer._fileStream, "write");
      drainListener = sandbox.stub();
      writer._fileStream.on("drain", drainListener);
    });

    it("should write a message", () => {
      writer.write(MESSAGE_24);
      expect(writer._fileStream.write).to.have.been.calledOnce;
      expect(writer._fileStream.write).to.have.returned(true);
    });

    it("should handle 1000 writes", (done) => {
      const COUNT = 1000;

      async.times(COUNT, () => {
        writer.write(MESSAGE_24);
      });
      expect(writer._fileStream.write).to.have.callCount(COUNT);
      expect(writer._fileStream.write).to.have.returned(true);
      expect(writer._fileStream.write).to.have.returned(false);
      setTimeout(() => {
        expect(drainListener).to.have.been.calledOnce;
        done();
      }, 30);
    });
  });
});
