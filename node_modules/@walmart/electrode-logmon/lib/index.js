"use strict";

const EventEmitter = require("events").EventEmitter;
const os = require("os");

const _ = require("lodash");
const assert = require("assert");

const DualWriter = require("./dual-writer");
const getClientId = require("./utils/get-client-id");
const getTxId = require("./utils/get-tx-id");
const serializeData = require("./utils/serialize-data");

const EMPTY = "-";

const DEFAULT_DATA = {
  category: "-",
  duration: "-",
  level: "-",
  messageId: "-",
  parentTxId: "-",
  payload: "-",
  sessionId: "-",
  subType: "-",
  tenant: "-",
  topTxId: "-",
  txId: "-",
  type: "-"
};

const DEFAULT_OPTIONS = (function () {
  const assembly = process.env.ONEOPS_ASSEMBLY;
  const platform = process.env.ONEOPS_PLATFORM;

  return {
    appId: `${assembly || ""}-${platform || ""}`,
    baseUrl: "http://lms.qa2.lms.platform.ctf3a.qa.walmart.com/",
    buildId: EMPTY,
    dataCenter: process.env.ONEOPS_CLOUD || EMPTY,
    environment: process.env.ONEOPS_ENVIRONMENT || EMPTY,
    filePath: "/log/logmon/logmon_new.log",
    groupId: assembly || EMPTY,
    host: process.env.ONEOPS_CI_NAME || os.hostname(),
    marker: "WMPLATFORMLOGMSG",
    maxSize: 100 * 1024 * 1024,
    emitErrors: false
  };
}());

class LogMon extends EventEmitter {

  constructor(options) {
    super();
    this._options = _.defaults({}, options, DEFAULT_OPTIONS);
    this._writer = new DualWriter(
      _.pick(this._options, "filePath", "maxSize", "mode", "zookeeper")
    );
    this._writer.on("error", this._handleError.bind(this));
  }

  static getTxIdSync(options) {
    return getTxId.sync(options);
  }

  _handleError(err) {
    if (this._options.emitErrors) {
      this.emit("error", err);
    }
  }

  _write(data, messageId) {
    const _data = {};
    if (data) {
      _.each(data, (value, key) => {
        _data[key] = value;
      });
    }
    _data.messageId = _data.messageId || messageId;
    _.each(DEFAULT_DATA, (defaultValue, key) => {
      _data[key] = _data[key] || defaultValue;
    });
    _.each(this._options, (optionsValue, key) => {
      _data[key] = _data[key] || optionsValue;
    });

    const serialized = serializeData(_data);

    this._writer.write(serialized);
  }

  getClientId(callback) {
    assert(_.isFunction(callback), "A callback function must be provided.");
    return getClientId(this._options, callback);
  }

  getTxId(options, callback) {
    // options is optional, so check for cb as first arg
    if (_.isFunction(options)) {
      callback = options;
      options = {};
    }
    return getTxId.async(_.defaults(options, this._options), callback);
  }

  closeKafka() {
    this._writer.closeKafka();
  }

  /* Public interface - wrapper around _write that gets tx id first if necessary */
  write(data) {
    if (data && data.messageId) {
      this._write(data);
    } else {
      const self = this;
      this.getTxId((err, messageId) => {
        if (err) {
          self._handleError(err);
        }
        self._write(data, messageId);
      });
    }
  }
}

module.exports = LogMon;
