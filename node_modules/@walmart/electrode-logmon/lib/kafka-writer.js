"use strict";

const EventEmitter = require("events").EventEmitter;
const _ = require("lodash");
const async = require("async");
const kafka = require("kafka-node");

const internals = {};

internals.RETRIES = 5;
internals.PAYLOAD_ATTRIBUTES = 2;
internals.DATACENTERS = [ "cdc", "dal", "dfw", "edc", "ndc", "sdc" ];
internals.PAYLOAD_TOPIC = "logmon.rawlog";

internals.ZOOKEEPER_QA = [
  "dare-msgq00.sv.walmartlabs.com:9091",
  "dare-msgq01.sv.walmartlabs.com:9091",
  "dare-msgq02.sv.walmartlabs.com:9091"
].join(",");

internals.findDC = (dc) => {
  return typeof process.env.ONEOPS_CLOUD === "string" &&
         process.env.ONEOPS_CLOUD.indexOf(dc) !== -1;
};

internals.getZookeeper = () => {
  const dc = _.find(internals.DATACENTERS, internals.findDC);
  return dc ? internals.zookeeperTemplate({dc: dc}) : internals.ZOOKEEPER_QA;
};

internals.zookeeperTemplate = _.template([
  "<%= dc %>-kafka-zk00.bfd.walmart.com:9091",
  "<%= dc %>-kafka-zk01.bfd.walmart.com:9091",
  "<%= dc %>-kafka-zk02.bfd.walmart.com:9091",
  "<%= dc %>-kafka-zk03.bfd.walmart.com:9091"
].join(","));


class KafkaWriter extends EventEmitter {

  constructor(options) {
    super();
    this._options = _.merge({ zookeeper: internals.getZookeeper() }, options);
    this._producer = null;
    this._queue = async.queue(this._send.bind(this), 1);
    this._queue.pause();
  }

  _createProducer(cb) {
    cb = cb || (() => {});

    if (this._producer || this._producerPending) {
      return cb();
    }

    this._producerPending = true;
    const producer = new kafka.Producer(new kafka.Client(this._options.zookeeper));

    let ready = false;
    const self = this;

    producer.once("ready", () => {
      ready = true;
      self._producer = producer;
      self._producerPending = false;
      self._restarting = false;
      if (self._closePending) {
        self.closeClient();
      } else {
        self._queue.resume();
      }
      cb();
    });

    producer.once("error", (err) => {
      // if error fires before "ready", guess that it's from instantiation
      if (!ready) {
        this._producerPending = false;
        if (this._restarting) {
          return cb(err);
        }
        self._restartProducer(internals.RETRIES, cb);
      }
    });

    // re-emit every error
    producer.on("error", this.emit.bind(this, "error"));
  }

  _restartProducer(retries, cb) {
    cb = cb || (() => {});
    if (this._restarting) {
      return cb();
    }
    this._restarting = true;
    if (this._producer) {
      this.closeClient();
      this._producer.removeAllListeners();
      this._producer = null;
    }

    const self = this;

    async.retry(retries, this._createProducer.bind(this),
      (finalError) => {
        self._restarting = false;
        if (finalError) {
          const error = new Error("Unable to create kafka producer");
          error.kafkaError = finalError;
          this._clearQueue(error);
          return cb(error);
        }
        cb();
      });
  }

  _clearQueue(err) {
    while (this._queue.length()) {
      const task = this._queue.tasks.pop();
      if (task.callback) {
        task.callback(err);
      }
    }
  }

  _send(message, cb) {
    const payloads = [{
      attributes: internals.PAYLOAD_ATTRIBUTES,
      messages: message,
      topic: internals.PAYLOAD_TOPIC
    }];
    this._producer.send(payloads, cb);
  }

  write(message) {
    this._createProducer();
    let retried = false;
    const self = this;
    this._queue.push(message, (err) => {
      if (err && !retried && self._producer) {
        retried = true;
        self._restartProducer(1);
        self._queue.unshift(message, self._handleWriteResult.bind(self));
      } else {
        self._handleWriteResult(err);
      }
    });
  }

  _handleWriteResult(err) {
    if (err) {
      this.emit("error", err);
    }
  }

  closeClient() {
    this._closePending = false;
    this._queue.pause();
    if (this._producer) {
      this._producer.client.close();
    } else if (this._producerPending) {
      this._closePending = true;
    }
  }
}

module.exports = KafkaWriter;
