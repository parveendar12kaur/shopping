canary coding style guide
=========================

## spacing and punctuation

### 4-space indents

It's preference. Some like 2, some like 4, we're settling on 4.

### 80 character limit

Wrap your lines in a way that you avoid exceeding the 80th column on any given
line of code. This insures code can be read in split windows nicely, and also
has the benefit of insuring the code is readable on Github without horizontal
scrolling.

### semi-colons

Please no? Fine. We can keep them.

### empty lines

No empty lines to start a function or block.


## variables

### camelCase

Use `camelCase`. For variables, for `require`'d modules, for everything except
classes and constructor functions. These should be `UpperCamelCase`. 

### var, let, const

If your project will run in a browser, or any version of node below 4, use `var`
exclusively. 

If your project is node 4+ only, use `const` unless you need `let`.


## functions

### name all functions

Name all functions. Even tiny ones. This will greatly ease the pain of debugging
applications with tools like dtrace, mdb, and others when things start failing.
Done properly, function names also act as additional in-line documentation.

### implementation follows intent

Let function implementations follow their usage. Javascript hoisting allows
this, and readability of code is greatly improved as the reader can quickly
consume the meaning of a block of code without having to scan over additional 
function bodies.

### keep functions small

Keeping functions small makes them easier to reason about. Also, it increases 
the liklihood that they are inlined by the V8 JIT. Easier to understand and
faster - it's a win-win. Keep functions less than 100 lines. For the JIT
performance boost, keep them under 600 charatcers (including comments).

### avoid closures

Somestimes closures make sense. Many times however, they're used for convenience
when it would be just as easy to move the function out. This can help eliminate
memory leaks and increase performance. 


## examples

### do not capitalize requires

*bad*

```javascript
var Hapi = require('hapi');
```

*good*

```javascript
var hapi = require('hapi');
```

The exception to this rule, is if you're requiring a constructor or class.

### eliminate empty line

*bad*

```javascript
function hello () {
    
    console.log('hello');
}
```

*good*

```javascript
function hello () {
    console.log('hello');
}
```

### naming a function

*bad*

In this example we use an anonymous arrow function to concat numbers:

```javascript
let numbers = [1, 2, 3, 4, 5];
numbers.reduce((str, num) => str + num, '');
```

*good*

In this example, we use a named function that follows our intent; it does the
same thing as the above example:

```javascript
let numbers = [1, 2, 3, 4, 5];
numbers.reduce(concatenate);

function concatenate (str, num) {
    return '' + str + num;
}
```

### defining a constructor and prototype

*bad*

```javascript
function Square (sideLength) {
    this.sideLength = sideLength;
}
Square.prototype.getPerimeter = function () {
    return this.sideLength * 4;
};
Square.prototype.getArea = function () {
    return this.sideLength * this.sideLength;
};
```

*good*
In this example, we take the above `Square`, eliminate anonymous functions, and
have implementation follow intent, which makes the API of the square much more
digestible at a glance. See for yourself:

```javascript
function Square (sideLength) {
    this.sideLength = sideLength;
}
// Square api
Object.assign(Square.prototype, {
    getPerimeter,
    getArea
});

// implementations
function getPerimeter () {
    return this.sideLength * 4;
}

function getArea () {
    return this.sideLength * this.sideLength;
}
```

### eliminate a closure

*bad*
We start with an anonymous reducer which creates a closure.

```javascript
function add (numberArray) {
    return numberArray.reduce((x, y) => x + y);
}
```

*better*
We pull it out and name the function...

```javascript
function add (numberArray) {
    return numberArray.reduce(sum);

    function sum (x, y) {
        return x + y;
    }
}
```

*best*
Which makes it simple to eliminate the closure:

```javascript
function add (numberArray) {
    return numberArray.reduce(sum);
}

function sum (x, y) {
    return x + y;
}
```
