var eventuate = require('eventuate');
var assign = require('object-assign');

/* terminology
 * -----------
 * event   - something that occurs on device (touch, navigation, etc)
 * rule    - these process 1+ events and possibly produce 1+ message(s)
 * message - a payload produced by canary as result of rule, bound for analytics system
 */

module.exports = function createCanary (canaryOpts) {
    // processBufferMax - Control how many events will be buffered while
    //                    canary is suspended. Old events will be dropped
    //                    for new ones. Set to 0 for no buffering.
    // suspend          - Start Canary in a suspended state (buffer incoming
    //                    events) until rules have been applied. Defaults to
    //                    true.
    var opts = assign({
        processBufferMax: 1000,
        historySize: 100,
        suspend: true,
        timestamp: 'timestamp'
    }, canaryOpts);

    var suspended = opts.suspend;
    var processBuffer = [];

    var canary = Object.defineProperties({}, {
        applyRules: { value: applyRules, configurable: true },
        // eventual device events and history manager
        event: { value: require('./lib/event')(), configurable: true },
        // rudimentary state support, which can be overriden (by native for example)
        state: { value: require('./lib/state')(), configurable: true },
        // array of enabled rule functions
        rules: { value: [], enumerable: true, writeable: true, configurable: true },
        // eventual canary messages bound for analytics system
        message: { value: eventuate(), configurable: true },
        // eventual canary log messages
        log: { value: eventuate(), configurable: true },
        process: { value: processEvent, configurable: true },
        dispatch: { value: dispatchMessage, configurable: true },
        // suspend/resume event processing, will buffer by default
        suspend: { value: suspend, configurable: true },
        resume: { value: resume, configurable: true },
        isSuspended: { value: isSuspended, configurable: true },
        // safely extract timestamps from an event
        getTs: {
            value: typeof opts.timestamp === 'function'
                ? getTsByFunc
                : getTsByName,
            configurable: true
        }
    });

    return canary;

    // rules should be provides in the format of:
    // [ function rule1 () {}, function rule2 () {}, ... ]
    function applyRules (rules, options) {
        options = assign({ resume: true }, options);
        rules.forEach(function (rule) { // eslint-disable-line func-names
            rule(canary);
            canary.rules.push(rule);
            canary.log.produce('initialized rule: ' + (rule.identifier || rule.name));
        });
        if (options.resume) {
            canary.resume();
        }

        return canary;
    }

    // this is the gateway, called directly from app - we create an envelope and
    // store the payload provided in the payload property of the envelope - we
    // then produce it via the canary.event eventuate , which all rules are
    // capable of subscribing to during rule init
    function processEvent (payload) {
        var now = Date.now();
        // rts = the time canary received the event from the application
        // pts = the time canary "produced" the event (via canary.event), this
        //       is when the event becomes visible to rules
        //       (pts - rts = time in buffer)
        var evt = suspended
            ? { rts: now, payload: payload }
            : { rts: now, pts: now, payload: payload };
        evt.ts = canary.getTs(evt);

        if (suspended) {
            processBuffer.push(evt);
            if (processBuffer.length > opts.processBufferMax) {
                processBuffer.shift();
            }
        }
        else {
            canary.event.produce(evt);
        }
    }

    function produceEvent (evt) {
        // this message sat in the buffer, set pts now
        canary.event.produce(evt, {
            pts: Date.now()
        });
    }

    // dispatch is called by rules with any messages for analytics system
    function dispatchMessage (payload) {
        // just produce the outbound message, wire up delivery implementation elsewhere
        canary.message.produce(payload);
    }

    function suspend () {
        suspended = true;
        return canary;
    }

    function resume () {
        suspended = false;
        while (processBuffer.length > 0) {
            produceEvent(processBuffer.shift());
        }
        return canary;
    }

    function isSuspended () {
        return suspended;
    }

    function getTsByName (evt) {
        return (evt && typeof evt === 'object')
            ? (evt.payload && evt.payload[opts.timestamp])
                ? evt.payload[opts.timestamp]
                : evt.rts
            : null;
    }

    function getTsByFunc (evt) {
        return (evt && typeof evt === 'object')
            ? opts.timestamp(evt)
            : null;
    }
};
