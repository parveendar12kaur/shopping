/* eslint-disable func-names */
var test = require('tape');
var createState = require('../lib/state');

test('state should store key value pairs', function (t) {
    var state = createState();
    t.equal(state.get('x'), undefined, 'x not present by default');
    state.set('x', true);
    t.equal(state.get('x'), true, 'x present after set');

    t.end();
});

test('state should allow getter/setter to be overridden', function (t) {
    var state = createState();
    var myStore = {};
    state.setter(function (k, v) {
        myStore[k] = v;
    });
    state.getter(function (k) {
        return myStore[k];
    });

    t.equal(state.get('x'), undefined, 'x not present by default');
    state.set('x', true);
    t.equal(state.get('x'), true, 'x present after set');
    t.equal(myStore.x, true, 'x present in myStore');

    t.end();
});

test('state should throw when given incorrect setter/getter args', function (t) {
    var state = createState();

    t.throws(state.setter, 'setter throws on undefined');
    t.throws(function () {
        state.setter({});
    }, 'setter throws on obj');
    t.throws(function () {
        state.setter('');
    }, 'setter throws on string');

    t.throws(state.getter, 'getter throws on undefined');
    t.throws(function () {
        state.getter({});
    }, 'getter throws on obj');
    t.throws(function () {
        state.getter('');
    }, 'getter throws on string');

    t.end();
});

test('remove destroyes a value in default memory store', function (t) {
    t.plan(2);

    var state = createState();
    state.set('a', 1);
    t.equal(state.get('a'), 1);
    state.remove('a');
    t.equal(state.get('a'), undefined);
});

test('specifying an invalid { in } throws', function (t) {
    t.plan(1);

    var state = createState();

    t.throws(function () {
        state.set('test', 123, { in: 'invalid' });
    }, '{ in: invalid } throws');
});

test('state.registerStore adds { in } target', function (t) {
    t.plan(6);

    var state = createState();
    var store = {};
    state.registerStore(function () {
        return { name: 'valid', set: setter, get: getter, remove: remover };
    });

    state.set('abc', 123, { in: 'valid' });
    t.equal(store['abc'].v, 123);
    t.equal(state.get('abc', { in: 'valid' }), 123);
    state.remove('abc', { in: 'valid' });
    t.equal(store['abc'], undefined);

    function setter (k, v, opts) {
        t.equal(opts.in, 'valid', 'setter is passed opts');
        store[k] = v;
    }

    function getter (k, opts) {
        t.equal(opts.in, 'valid', 'getter is passed opts');
        return store[k];
    }

    function remover (k, opts) {
        t.equal(opts.in, 'valid', 'remover is passed opts');
        delete store[k];
    }
});

test('state.configure with empty config object has no impact', function (t) {
    t.plan(1);

    var state = createState().configure(function () {
        return {};
    });

    state.set('a', 1);
    t.equal(state.get('a'), 1);
});

test('state.configure registers multiple stores, sets default', function (t) {
    t.plan(3);

    var data1 = {};
    var data2 = {};

    var state = createState().configure(function () {
        return {
            defaultStore: 'store1',
            stores: [ store1, store2 ]
        };
    });

    state.set('a', 1, { in: 'store1' });
    state.set('b', 1);
    state.set('a', 2, { in: 'store2' });

    t.equal(state.get('a', { in: 'store1' }), 1);
    t.equal(data1.b.v, 1);
    t.equal(state.get('a', { in: 'store2' }), 2);

    function store1 () {
        return { name: 'store1', set: set, get: get, remove: remove };

        function set (k, v) {
            data1[k] = v;
        }

        function get (k) {
            return data1[k];
        }

        function remove (k) {
            delete data1[k];
        }
    }

    function store2 () {
        return { name: 'store2', set: set, get: get, remove: remove };

        function set (k, v) {
            data2[k] = v;
        }

        function get (k) {
            return data2[k];
        }

        function remove (k) {
            delete data2[k];
        }
    }
});

test('state.configure and state.registerStore also accept objects', function (t) {
    t.plan(3);

    var store1 = { name: 'store1' };
    var store2 = { name: 'store2' };

    var state = createState().configure({
        defaultStore: 'store1',
        stores: [ store1, store2 ]
    });

    t.equal(state.isStoreAvailable('store1'), true);
    t.equal(state.isStoreAvailable('store2'), true);
    t.equal(state.getDefaultStore(), 'store1');
});

test('state.set supports ttl expire on read', function (t) {
    t.plan(2);

    var state = createState();

    state.set('test', 123, { ttl: 10 });
    t.equal(state.get('test'), 123);

    setTimeout(function () {
        t.equal(state.get('test'), undefined);
    }, 50);
});

test('state.set supports ttl expire on read for custom store', function (t) {
    t.plan(3);

    var state = createState().registerStore(store1);
    var data = {};

    state.set('test', 123, { in: 'store1', ttl: 10 });
    t.equal(state.get('test', { in: 'store1' }), 123);

    setTimeout(function () {
        t.equal(state.get('test', { in: 'store1' }), undefined);
        t.equal(data.test, undefined);
    }, 50);

    function store1 () {
        return { name: 'store1', set: set, get: get, remove: remove };

        function set (k, v) {
            data[k] = v;
        }

        function get (k) {
            return data[k];
        }

        function remove (k) {
            delete data[k];
        }
    }
});

test('state.setDefaultStore changes default', function (t) {
    t.plan(6);

    var state = createState().registerStore(store1).setDefaultStore('store1');
    t.throws(function () {
        state.setDefaultStore('invalid');
    }, 'throws on invalid store');
    t.throws(state.setDefaultStore, 'throws on no store');
    var data = {};

    state.set('test', 123);
    t.equal(data.test.v, 123);
    t.equal(state.get('test'), 123);
    state.remove('test');
    t.equal(data.test, undefined);
    t.equal(state.get('test'), undefined);

    function store1 () {
        return { name: 'store1', set: set, get: get, remove: remove };

        function set (k, v) {
            data[k] = v;
        }

        function get (k) {
            return data[k];
        }

        function remove (k) {
            delete data[k];
        }
    }
});

test('state.unregisterStore removes a store', function (t) {
    t.plan(4);

    var state = createState().registerStore(store1);
    t.equal(state.isStoreAvailable('store1'), true);
    t.equal(state.unregisterStore('store1'), true);
    t.equal(state.isStoreAvailable('store1'), false);
    t.equal(state.unregisterStore('store1'), false);

    function store1 () {
        var data = {};
        return { name: 'store1', set: set, get: get, remove: remove };

        function set (k, v) {
            data[k] = v;
        }

        function get (k) {
            return data[k];
        }

        function remove (k) {
            delete data[k];
        }
    }
});
