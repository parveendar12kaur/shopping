"use strict";

/* eslint-disable no-invalid-this, quotes, curly, max-len, no-magic-numbers, prefer-template */

/*
 * WalmartLabs SOA Enterprise System Bus (ESB) Proxy 1.0 doesn't honor HTTP spec and require all "WM_*"
 * header field names to be upper case.
 *
 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html
 *
 * This was their response:
 *
 *
 * > I understand that as per RFC 2616, headers are case insensitive, but, SOARI 1.0 and ESB expect headers to be in upper
 * > case. Unfortunately, thatâ€™s the behavior limitation in SOA 1.0. As we move towards SOA 2.0, we will be rectifying this.
 *
 *
 * But NodeJS core always process HTTP headers in lower case.
 *
 * So we have to monkey patch NodeJS core to _not_ change the "WM_*" headers.
 *
 *
 * At the time of writing this, NodeJS core source for 8.3.0 from here:
 *
 * https://github.com/nodejs/node/blob/08b662a8e9eb4956adfb24952e96054826b6bbb3/lib/_http_outgoing.js
 * https://github.com/nodejs/node/blob/08b662a8e9eb4956adfb24952e96054826b6bbb3/lib/_http_incoming.js
 *
 */

const http = require("http");
const assert = require("assert");
const common = require("_http_common");
const checkIsHttpToken = common._checkIsHttpToken;
const checkInvalidHeaderChar = common._checkInvalidHeaderChar;
const debug = common.debug;

function findOutHeadersKeySymbol(symbols) {
  return symbols.find(s => {
    return typeof s === "symbol" && s.toString() === "Symbol(outHeadersKey)";
  });
}

function hackFinity() {
  const x = new http.OutgoingMessage();
  const s = findOutHeadersKeySymbol(Object.getOwnPropertySymbols(x));
  assert(s, "Unable to find http module's internal outHeadersKey symbol");
  return s;
}

const oldSetHeader = Symbol("oldSetHeader");
const outHeadersKey = hackFinity();

//
// copied from node core's _http_outgoing.js directly
//
function validateHeader(msg, name, value) {
  if (typeof name !== "string" || !name || !checkIsHttpToken(name))
    throw new TypeError(`Header name must be a valid HTTP Token ["${name}"]`);
  if (value === undefined) throw new Error('"value" required in setHeader("' + name + '", value)');
  if (msg._header) throw new Error("Can't set headers after they are sent.");
  if (checkInvalidHeaderChar(value)) {
    debug('Header "%s" contains invalid characters', name);
    throw new TypeError("The header content contains invalid characters");
  }
}

function patchHttpOutgoingSetHeader(name, value) {
  validateHeader(this, name, value);

  if (!this[outHeadersKey]) this[outHeadersKey] = {};

  let key = name.toLowerCase();

  if (key === "signedheaders") {
    key = name = "SignedHeaders";
  } else if (key.startsWith("wm_")) {
    key = name = name.toUpperCase();
  }

  this[outHeadersKey][key] = [name, value];

  switch (key.length) {
    case 10:
      if (key === "connection") this._removedConnection = false;
      break;
    case 14:
      if (key === "content-length") this._removedContLen = false;
      break;
    case 17:
      if (key === "transfer-encoding") this._removedTE = false;
      break;
  }
}

http.OutgoingMessage.prototype[oldSetHeader] = http.OutgoingMessage.prototype.setHeader;
http.OutgoingMessage.prototype.setHeader = patchHttpOutgoingSetHeader;

function register(server, options, next) {
  next();
}

const pkg = require("../package.json");

register.attributes = {
  pkg
};
module.exports = register;
