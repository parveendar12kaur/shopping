"use strict";

const os = require("os");
const _ = require("lodash");
const path = require("path");
const ElectrodeSwapi = require("@walmart/electrode-swapi");
const expCookieParser = require("./exp-cookie-parser");

const ccmClientPkg = require("../package.json");
const cwdPkg = require(path.join(process.cwd(), "package.json"));

const firstDefined = (a, b) => {
  if (a !== undefined) return a;
  return b;
};

class CCMClient extends ElectrodeSwapi {
  constructor(config, swagger, providerName) {
    super(config, swagger, providerName);
    //
    // From CCM team, for the scope template: /{environment}/{cloudEnvironment}/{cloud}/{node}
    //
    // ONEOPS_ENVPROFILE maps to environment
    // ONEOPS_ENVIRONMENT maps to cloudEnvironment
    // ONEOPS_CLOUD maps to cloud
    // hostname maps to node
    // node also can be generated by custom logic on non-OneOps env,
    // here: https://gecgithub01.walmart.com/platform/scm/blob/3dc5bd5b17418aa54c09cc93f4855132a01241ae/scm-client-parent/scm-client-impl/src/main/java/com/walmart/platform/scm/client/execution/ContextDiscoveryImpl.java#L199
    //
    this.oneOpsEnv = {
      environment: process.env.ONEOPS_ENVPROFILE,
      cloudEnvironment: process.env.ONEOPS_ENVIRONMENT,
      cloud: process.env.ONEOPS_CLOUD,
      node: (process.env.ONEOPS_ENVPROFILE && os.hostname()) || undefined,
      //
      // cloudDc is only for the header ccm.consumer.runOnCloudDc
      // Java CCM build it by looking at other OneOps env, but looks like
      // DATACENTER is what's epxected
      //
      cloudDc: process.env.DATACENTER
    };
  }

  static create(config, specOverride, providerName) {
    return ElectrodeSwapi.create({ Client: CCMClient, config, specOverride, providerName });
  }

  static get specFilename() {
    return path.join(__dirname, "../data/swagger.yaml");
  }

  static get providerName() {
    return "ccm";
  }

  static decodeExpoCookie(value) {
    return expCookieParser.parse(value);
  }

  static get serviceRegistry() {
    const registry = {
      default: {
        ENDPOINT: {
          schemes: ["http"],
          host: "scm.stg.walmart.com",
          basePath: "/scm-app/v2"
        },
        ESB_PROXY: {}
      },
      // if env is missing or not found, then use these (default still applies)
      missing: {},
      qa: {
        ENDPOINT: {
          schemes: ["http"],
          host: "scm.stg.walmart.com",
          basePath: "/scm-app/v2"
        },
        ESB_PROXY: {}
      },
      prod: {
        ENDPOINT: {
          schemes: ["http"],
          host: "scm.prod.walmart.com"
        },
        ESB_PROXY: {
          schemes: ["http"],
          host: "ultra-esb.prod-shared1.esb.platform.glb.prod.walmart.com"
        }
      }
    };

    registry.stg = registry.qa;
    registry.stg0 = registry.qa;

    return registry;
  }

  get context() {
    if (!this._staticContext) {
      const options = this.providerInfo.options;

      // CCM configuration used for posting telemetry data
      this._staticContext = _.pickBy(
        {
          clientType: "ElectrodeClient",
          "ccm.client.version": ccmClientPkg.version,
          "ccm.consumer.ip.address": firstDefined(
            options.hostIP,
            _.get(this, "config.electrode.hostIP")
          ),
          appName: firstDefined(options.appName, cwdPkg.name),
          appVersion: firstDefined(options.appVersion, cwdPkg.version),
          runOnEnv: firstDefined(options.environment, this.oneOpsEnv.environment),
          runOnCloudEnv: firstDefined(options.cloudEnvironment, this.oneOpsEnv.cloudEnvironment),
          runOnCloudDc: firstDefined(options.cloudDc, this.oneOpsEnv.cloudDc),
          runOnCloud: firstDefined(options.cloud, this.oneOpsEnv.cloud),
          runOnNode: firstDefined(options.node, this.oneOpsEnv.node)
        },
        x => x !== undefined
      );
    }

    return this._staticContext;
  }

  makeStaticHeaders(ref) {
    if (!this._staticHeaders) {
      const options = _.defaults({}, ref.options._swapi || {}, this.providerInfo.options);

      // Add CCM-specific headers. Based on inspecting `ccm-node-client`.
      this._staticHeaders = _.pickBy(
        {
          "ccm.client.type": "ElectrodeClient",
          "ccm.client.version": ccmClientPkg.version,
          "ccm.consumer.appName": firstDefined(options.appName, cwdPkg.name),
          "ccm.consumer.appVersion": firstDefined(options.appVersion, cwdPkg.version),
          "ccm.consumer.runOnEnv": firstDefined(options.environment, this.oneOpsEnv.environment),
          "ccm.consumer.runOnCloudEnv": firstDefined(
            options.cloudEnvironment,
            this.oneOpsEnv.cloudEnvironment
          ),
          "ccm.consumer.runOnCloudDc": firstDefined(options.cloudDc, this.oneOpsEnv.cloudDc),
          "ccm.consumer.runOnCloud": firstDefined(options.cloud, this.oneOpsEnv.cloud),
          "ccm.consumer.runOnNode": firstDefined(options.node, this.oneOpsEnv.node),
          [ElectrodeSwapi.WM_HEADERS.wmConsumerName]: firstDefined(options.appName, cwdPkg.name),

          // hard code this token until we figure out what to do.
          [ElectrodeSwapi.WM_HEADERS.secAuthToken]: "6KASDKKA-6JJS-6583-H435-8935JSDK4924"
        },
        x => x !== undefined
      );
    }
  }

  wmHeaders(ref) {
    const headers = super.wmHeaders(ref);

    this.makeStaticHeaders(ref);

    _.defaults(headers, this._staticHeaders);

    headers["ccm.consumer.ip.address"] = headers["WM_CONSUMER.IP"];

    return headers;
  }

  /**
   * Generate the scopeName from template and context
   *
   * @param {string} template - The template in the form of "/{ref1}/{ref2}/literal/literal"
   * @param {object} context - Context to lookup the ref tokens in the template
   *  If context doesn't contain a ref token, then lookup from provider options, and then oneOpsEnv
   *  The first non-undefined value is used, but if it's falsy, then use ""
   *
   * @returns {string} scope name
   */
  scopeName(template, context) {
    template = template || "/{environment}/{cloud}/{node}";
    const sources = [context || {}, this.providerInfo.options, this.oneOpsEnv];
    let i;
    const scope = template
      .replace(/{([^}]+)}/g, (m, t) => {
        for (i = 0; i < sources.length; ++i) {
          const v = sources[i][t];
          if (v !== undefined) return v || "";
        }
        return "";
      })
      .split("/")
      .filter(_.identity)
      .join("/");
    return `/${scope}`;
  }

  /**
   * Generate the payload parameter for calling getTypedConfig API
   *
   * @param {Object} params - params to be passed to invoking the API
   *  .configName - config name to be lookedup
   *
   * @param {Object} options - options with the following items
   *  .environment: Environment.  If not provided, then lookup from provider options
   *  .version: Version string. "1.0.0"
   *
   * @param {Object} meta - For retrieving cookies (Hapi request)
   *  .state.exp: the exp cookie for experimentation
   *
   * @returns {Object} payload parameter object
   */
  typedConfigPayload(params, options, meta) {
    return {
      header: null,
      payload: {
        environment: options.environment || this.providerInfo.options.environment,
        node: null,
        version: options.version,
        configContextProperties: {
          [params.configName]: [{}]
        },
        providerContextProperties: {
          "com.walmart.platform.exp.client.context.ExperimentationClientContextProvider": {
            exp: meta && meta.state && expCookieParser.parse(meta.state.exp)
          }
        }
      }
    };
  }
}

module.exports = CCMClient;
