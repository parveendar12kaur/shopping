"use strict";

const keyList = Symbol.for("electrode npm singleton packages list");
const enforceNpm = (global[keyList] = global[keyList] || {});
const assert = require("assert");
const modPkg = require("../package.json");
const fs = require("fs");
const Path = require("path");

function readPackage(path) {
  if (!path.endsWith("package.json")) {
    path = Path.join(path, "package.json");
  }

  assert(Path.isAbsolute(path), `${modPkg.name}: path must be absolute`);

  return JSON.parse(fs.readFileSync(path).toString());
}

function enforceNpmSingleton(modulePath) {
  assert(
    typeof modulePath === "string",
    "must pass full path to where module is installed for npm singleton"
  );
  const pkg = readPackage(modulePath);

  assert(pkg.name, `${modPkg.name}: pkg.name is falsy`);
  assert(pkg.version, `${modPkg.name}: pkg.version is falsy`);

  if (!enforceNpm[pkg.name]) {
    enforceNpm[pkg.name] = pkg.version;
  }

  const version = enforceNpm[pkg.name];

  assert(
    version === pkg.version,
    `${pkg.name} required singleton but multiple versions ${version} and ${pkg.version} found.`
  );
}

enforceNpmSingleton(Path.join(__dirname, ".."));

const cwd = process.cwd();

function findModuleDir(dir, mod) {
  if (fs.existsSync(Path.join(dir, `node_modules/${mod}`))) {
    /* istanbul ignore next */
    const multiple = dir !== cwd && fs.existsSync(Path.join(cwd, `node_modules/${mod}`));
    assert(
      !multiple,
      `npm-singleton: detected multiple instances of module ${mod} under ${dir} and CWD ${cwd}/node_modules` // eslint-disable-line
    );

    return dir;
  }

  return dir !== cwd && findModuleDir(Path.join(dir, ".."), mod);
}

module.exports = enforceNpmSingleton;

module.exports.findModuleDir = findModuleDir;
